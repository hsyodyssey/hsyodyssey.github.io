<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://www.hsyodyssey.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.hsyodyssey.com/" rel="alternate" type="text/html" /><updated>2023-03-12T20:45:12+08:00</updated><id>http://www.hsyodyssey.com/feed.xml</id><title type="html">Tech Notes | HSY</title><subtitle>Researching and Thinking
</subtitle><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><entry><title type="html">关于 Tornado Cash 事件的思考</title><link href="http://www.hsyodyssey.com/daily/2022/08/16/web3.html" rel="alternate" type="text/html" title="关于 Tornado Cash 事件的思考" /><published>2022-08-16T10:00:00+08:00</published><updated>2022-08-16T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/daily/2022/08/16/web3</id><content type="html" xml:base="http://www.hsyodyssey.com/daily/2022/08/16/web3.html">&lt;p&gt;最近美国财政部海外资产控制办公室（OFAC）宣布制裁Tornado Cash及其相关的地址。实际上，这并不是OFAC第一次宣布制裁某些加密货币的地址了。本次不同点在于这是第一次对链上的合约本身进行制裁。由此带来的后续效应是闻所未闻的，首先Circle冻结了Tornado Cash的USDC，紧接着Tornado Cash的Github仓库被移除，其项目的几个核心开发人员的Github账户被注销。甚至传出了项目的某位开发人员在荷兰被捕。同时，AAVE在前端网站禁止了一些与Tornado Cash有交易的相关账户的使用，以及后续 Tornado Cash 投毒事件，导致几个实名大户被禁止使用AAVE的前端网站上的服务。&lt;/p&gt;

&lt;p&gt;我们可以从本次风波中总结出以下的事实：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;美国政府可以随时制裁任何一个链上的合约及其相关的实体。&lt;/li&gt;
  &lt;li&gt;项目方可以停止提供合约的前端服务，但是无法停止合约本身。&lt;/li&gt;
  &lt;li&gt;项目方可以通过合约中的黑名单功能来冻结用户在合约中的资产或禁止某些地址使用合约中的服务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有关本次事件的讨论还在推特上发酵。不少乐观主义者认为&lt;strong&gt;事实2&lt;/strong&gt;正好反映了ETH生态的去中心化和稳健性。目前，已经有一些的开发者将龙卷风协议的前端部署到了IPFS上来继续提供服务。但是我们认为本次事件的带给了Crypto带了的影响是深远的。社区过于乐观而忽视了整个Crypto生态中脆弱的Infra本质。&lt;/p&gt;

&lt;p&gt;我们知道，使用合约首先构造Transaction，并将Transaction广播给Miner/Validator节点，最终由Miner/Validator节点打包到Block并更新到Blockchain中。在这个过程中至少需要：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;本地的签名器根据用户的私钥签名Transaction。&lt;/li&gt;
  &lt;li&gt;节点在网络中广播Transaction。&lt;/li&gt;
  &lt;li&gt;Miner/Validator节点打包Transaction。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个三个链上的执行流程是与项目方提不提供Web前端无关的。因此，在理论即使项目方不提供或暂停提供Web前端服务，用户还是可以使用链上的合约。目前最常见的链上工作流是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;用户通过Metamask执行了签名交易。&lt;/li&gt;
  &lt;li&gt;Metamask将交易发送给了Infura的节点服务，Infura的节点再将交易广播给网络中的其他的节点。&lt;/li&gt;
  &lt;li&gt;矿池节点在接收到交易后将其打包到Block中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是，Infura的母公司ConsenSys是一家美国公司。出于合规的考虑，他们完全可以在&lt;strong&gt;步骤2&lt;/strong&gt;中限制转发与Tornado Cash合约交互的Transaction。同时，在Ethereum转向PoS之后，出于合规的考虑PoS Proposer也可以在&lt;strong&gt;步骤3&lt;/strong&gt;选择不打包与Tornado Cash相关的Transaction。假如这两者都会发生，那么我们将不得不考虑”Ethereum的Layer 2的扩容方案的可用性的问题”。目前，L1与L2都是通过L1上的一个智能合约 (Bridge)来交互的。假如有人恶意的给这些L1-L2 Bridge合约转入Tornado Cash，导致Bridge的地址被制裁的话，会不会导致整个L2陷入失效中呢(节点拒绝转发该L2 Bridge合约的交易)？&lt;/p&gt;

&lt;p&gt;本次事件带给了社区新的思考。目前的数字世界服务的供应越来越中心化。十年前用户使用软件/互联网服务的主流方式是，从分散的下载站点或者软件的官方网站下载软件到本地安装。现在，用户可以直接使用项目/产品提供的web服务，或者通过大型公司维护的应用市场下载移动App在移动端使用。这种演化的发生是综合了多种因素自然选择的结果。从用户的角度来看，使用大型平台提供的渠道，保证了软件的安全性(早年从下载站下载的软件经常会捆绑其他的软件甚至包含了恶意软件)。从服务提供商的角度来看，这种方式有利于软件/服务的分发和管理。听上去这种演化带来了双赢的结果。但是，代价是什么呢？这种方式暴漏了一个很严重的缺口给监管方。如果监管有合规的要求，这些大型公司会毫不留情的下架项目。我们已经在华为，和滴滴等公司身上看到了现实的例子。本次的龙卷风协议被美国财政部制裁事件，也将这个事实带入了Web3/Crypto的领域。事实上在本次风波之后，整个DeFi生态已经处在了美国政府的监管阴影之下了。或许对于Web3来说，早年那种用户自己下载软件运行的模式更加的适合以及抗监管呢？&lt;/p&gt;

&lt;p&gt;当我们谈论Crypto/Web3的未来的时候，还需要更多的思考构建如何构建更稳健，更松散的Web3 Infra，而不是把未来都建立在活在监管阴影下的大公司们的手中。&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Daily" /><category term="Blockchain" /><category term="Daily" /><summary type="html">最近美国财政部海外资产控制办公室（OFAC）宣布制裁Tornado Cash及其相关的地址。实际上，这并不是OFAC第一次宣布制裁某些加密货币的地址了。本次不同点在于这是第一次对链上的合约本身进行制裁。由此带来的后续效应是闻所未闻的，首先Circle冻结了Tornado Cash的USDC，紧接着Tornado Cash的Github仓库被移除，其项目的几个核心开发人员的Github账户被注销。甚至传出了项目的某位开发人员在荷兰被捕。同时，AAVE在前端网站禁止了一些与Tornado Cash有交易的相关账户的使用，以及后续 Tornado Cash 投毒事件，导致几个实名大户被禁止使用AAVE的前端网站上的服务。 我们可以从本次风波中总结出以下的事实： 美国政府可以随时制裁任何一个链上的合约及其相关的实体。 项目方可以停止提供合约的前端服务，但是无法停止合约本身。 项目方可以通过合约中的黑名单功能来冻结用户在合约中的资产或禁止某些地址使用合约中的服务。 有关本次事件的讨论还在推特上发酵。不少乐观主义者认为事实2正好反映了ETH生态的去中心化和稳健性。目前，已经有一些的开发者将龙卷风协议的前端部署到了IPFS上来继续提供服务。但是我们认为本次事件的带给了Crypto带了的影响是深远的。社区过于乐观而忽视了整个Crypto生态中脆弱的Infra本质。 我们知道，使用合约首先构造Transaction，并将Transaction广播给Miner/Validator节点，最终由Miner/Validator节点打包到Block并更新到Blockchain中。在这个过程中至少需要： 本地的签名器根据用户的私钥签名Transaction。 节点在网络中广播Transaction。 Miner/Validator节点打包Transaction。 这个三个链上的执行流程是与项目方提不提供Web前端无关的。因此，在理论即使项目方不提供或暂停提供Web前端服务，用户还是可以使用链上的合约。目前最常见的链上工作流是： 用户通过Metamask执行了签名交易。 Metamask将交易发送给了Infura的节点服务，Infura的节点再将交易广播给网络中的其他的节点。 矿池节点在接收到交易后将其打包到Block中。 但是，Infura的母公司ConsenSys是一家美国公司。出于合规的考虑，他们完全可以在步骤2中限制转发与Tornado Cash合约交互的Transaction。同时，在Ethereum转向PoS之后，出于合规的考虑PoS Proposer也可以在步骤3选择不打包与Tornado Cash相关的Transaction。假如这两者都会发生，那么我们将不得不考虑”Ethereum的Layer 2的扩容方案的可用性的问题”。目前，L1与L2都是通过L1上的一个智能合约 (Bridge)来交互的。假如有人恶意的给这些L1-L2 Bridge合约转入Tornado Cash，导致Bridge的地址被制裁的话，会不会导致整个L2陷入失效中呢(节点拒绝转发该L2 Bridge合约的交易)？ 本次事件带给了社区新的思考。目前的数字世界服务的供应越来越中心化。十年前用户使用软件/互联网服务的主流方式是，从分散的下载站点或者软件的官方网站下载软件到本地安装。现在，用户可以直接使用项目/产品提供的web服务，或者通过大型公司维护的应用市场下载移动App在移动端使用。这种演化的发生是综合了多种因素自然选择的结果。从用户的角度来看，使用大型平台提供的渠道，保证了软件的安全性(早年从下载站下载的软件经常会捆绑其他的软件甚至包含了恶意软件)。从服务提供商的角度来看，这种方式有利于软件/服务的分发和管理。听上去这种演化带来了双赢的结果。但是，代价是什么呢？这种方式暴漏了一个很严重的缺口给监管方。如果监管有合规的要求，这些大型公司会毫不留情的下架项目。我们已经在华为，和滴滴等公司身上看到了现实的例子。本次的龙卷风协议被美国财政部制裁事件，也将这个事实带入了Web3/Crypto的领域。事实上在本次风波之后，整个DeFi生态已经处在了美国政府的监管阴影之下了。或许对于Web3来说，早年那种用户自己下载软件运行的模式更加的适合以及抗监管呢？ 当我们谈论Crypto/Web3的未来的时候，还需要更多的思考构建如何构建更稳健，更松散的Web3 Infra，而不是把未来都建立在活在监管阴影下的大公司们的手中。</summary></entry><entry><title type="html">实践的利他主义者</title><link href="http://www.hsyodyssey.com/daily/2022/06/05/altruism.html" rel="alternate" type="text/html" title="实践的利他主义者" /><published>2022-06-05T10:00:00+08:00</published><updated>2022-06-05T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/daily/2022/06/05/altruism</id><content type="html" xml:base="http://www.hsyodyssey.com/daily/2022/06/05/altruism.html">&lt;p&gt;“精致的利己主义者”这个词几年前在中文互联网上被炒得火热。这种“凡事利己”的行为准则确实可以在某些竞争中取得优势。但是我更推崇一种“实践的利他主义”。利他主义和利己主义并不是对立两端，利他并不一定会带来损己。反而更长的时间线上，利他主义反而可能会给个人带来超额的收益。&lt;/p&gt;

&lt;p&gt;一个例子是上个世纪兴起的开源软件运动。开源软件运动的先驱们就是带着利他的思想将自由软件精神发扬光大，带来了开源社区的繁荣。开源社区的繁荣降低了社区的参与门槛，引入了更多的参与者加入社区，最终推动整个计算机科技的进步。这种正向的滚雪球式的循环就是一个典型的利他主义给所有人带来超额回报的例子。从个人的角度，利他主义也可以给个人带来更稳固，更信赖的关系。当一个人被认为是“实践的利他主义者”的时候，往往能获得别人更多的信任。在现代社会中，这种高质量的信任关系的是无价的。&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Daily" /><category term="Blockchain" /><category term="Daily" /><summary type="html">“精致的利己主义者”这个词几年前在中文互联网上被炒得火热。这种“凡事利己”的行为准则确实可以在某些竞争中取得优势。但是我更推崇一种“实践的利他主义”。利他主义和利己主义并不是对立两端，利他并不一定会带来损己。反而更长的时间线上，利他主义反而可能会给个人带来超额的收益。 一个例子是上个世纪兴起的开源软件运动。开源软件运动的先驱们就是带着利他的思想将自由软件精神发扬光大，带来了开源社区的繁荣。开源社区的繁荣降低了社区的参与门槛，引入了更多的参与者加入社区，最终推动整个计算机科技的进步。这种正向的滚雪球式的循环就是一个典型的利他主义给所有人带来超额回报的例子。从个人的角度，利他主义也可以给个人带来更稳固，更信赖的关系。当一个人被认为是“实践的利他主义者”的时候，往往能获得别人更多的信任。在现代社会中，这种高质量的信任关系的是无价的。</summary></entry><entry><title type="html">细说 Blockchain 中的51% Attack</title><link href="http://www.hsyodyssey.com/blockchain/2022/05/29/blockchain_attacker.html" rel="alternate" type="text/html" title="细说 Blockchain 中的51% Attack" /><published>2022-05-29T10:00:00+08:00</published><updated>2022-05-29T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/05/29/blockchain_attacker</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/05/29/blockchain_attacker.html">&lt;h2 id=&quot;可怕但也没有那么可怕的51攻击&quot;&gt;可怕但也没有那么可怕的51%攻击&lt;/h2&gt;

&lt;p&gt;在数据库系统中，系统的管理员有着至高的权限，理论上数据的Administrator/Super Administrator可以修改数据库中的任意的数据。因此，对于一个数据库系统来说，拿到数据库管理员权限的攻击者对系统的威胁度是破坏性的。&lt;/p&gt;

&lt;p&gt;在Blockchain中，51%攻击(PoW)由于掌握了网络中绝大部分的算力，同样是被认为是高威胁攻击方式。但是相比于拿到数据库管理员权限的攻击者，Blockchain中的51%攻击者的造成的破坏是相对有限的。&lt;/p&gt;

&lt;p&gt;首先，由于Blockchain中数据的链式组成规则(i.e. 新的Block会将前一个区块的哈希值写入到区块头中)，51%攻击者几乎是不能修改/删除已经上链的历史数据的。同时，虽然51%的攻击者掌握了系统更新的权限(i.e. 生产新的区块)，但是攻击者并不能破坏现有的Block的验证规则。换句话说，攻击者产生的区块也必须是可以被其他的诚实节点验证的合法区块。比如在Bitcoin系统中，51%攻击者不能再次消费已经被消耗掉的UTXO，也不能去使用其他用户的UTXO来构造交易。同样的在以太坊中，51%攻击者不可以构造交易来花费其他用户的Ether。&lt;/p&gt;

&lt;p&gt;虽然攻击者不能随意的修改其他账户中的数据，但是他可以在“最长链规则下”做到:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Revert一个Blockchain。这种攻击方式称为分叉(fork)或者称为重组(reorg)。我们假设在当前的网络中节点正在$A$ Chain上开始产生区块，当前区块高度为100，网络中存在一个51%攻击者Bob。假如存在这样一个商业场景，某商家使用该Blockchain作为结算网络，当商家看到转账交易的被成功打包到Block并Append到Blockchain上时就给客户发货。假设，Bob使用了这个商家的服务，发送了一个转账交易。这个交易被打包到了101号Block中。当商家发现自己的收款交易，被打包到了101号区块后，立刻就给Bob发送了商品。那么此刻Bob可以做什么呢？由于Bob控制住了网络中大部分的算力，他可以将网络在100号区块开始进行分叉(fork)，生成一个没有包含给商家转账的101号区块，因此产生一个新的$B$ Chain。由于Bob控制了网络中的大部分算力，他可以尽可能在$B$ Chain继续产生区块，最终$B$ Chain成为了当前网络中最长的Chian。因此$A$ Chain最终会被作废掉，那么此刻在$A$ Chain上的101号块中的交易就作废了，而Bob白嫖了一个商家的服务。&lt;/li&gt;
  &lt;li&gt;Censor Transaction(交易审查)。Bob也可以进行一些更加隐秘的攻击，比如审查交易。假如Bob有一个竞争对手Alice(另一个Mining Pool)，那么Bob可以做到在所有它打包的Block中都不包括Alice的交易。更严重的，攻击者可以拒绝向Block中打包交易，造成网络拥堵，和事实上的停止服务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;值得注意的是，由于Blockchain是共识系统，分叉和交易审查的事件发生的时候，其他的诚实节点也是能够感知到的。因此，其他的诚实节点或者系统的开发团队(e.g. Ethereum Foundation)可以做出响应再分叉出一条诚实的Chain，以及做出一些补救措施来限制51%攻击者的行为。&lt;/p&gt;

&lt;p&gt;此外在有些区块链系统中，分叉是不被允许的比如Tendermint。在这种系统中，攻击者能做的事情就更加有限。&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Hack" /><summary type="html">可怕但也没有那么可怕的51%攻击 在数据库系统中，系统的管理员有着至高的权限，理论上数据的Administrator/Super Administrator可以修改数据库中的任意的数据。因此，对于一个数据库系统来说，拿到数据库管理员权限的攻击者对系统的威胁度是破坏性的。 在Blockchain中，51%攻击(PoW)由于掌握了网络中绝大部分的算力，同样是被认为是高威胁攻击方式。但是相比于拿到数据库管理员权限的攻击者，Blockchain中的51%攻击者的造成的破坏是相对有限的。 首先，由于Blockchain中数据的链式组成规则(i.e. 新的Block会将前一个区块的哈希值写入到区块头中)，51%攻击者几乎是不能修改/删除已经上链的历史数据的。同时，虽然51%的攻击者掌握了系统更新的权限(i.e. 生产新的区块)，但是攻击者并不能破坏现有的Block的验证规则。换句话说，攻击者产生的区块也必须是可以被其他的诚实节点验证的合法区块。比如在Bitcoin系统中，51%攻击者不能再次消费已经被消耗掉的UTXO，也不能去使用其他用户的UTXO来构造交易。同样的在以太坊中，51%攻击者不可以构造交易来花费其他用户的Ether。 虽然攻击者不能随意的修改其他账户中的数据，但是他可以在“最长链规则下”做到: Revert一个Blockchain。这种攻击方式称为分叉(fork)或者称为重组(reorg)。我们假设在当前的网络中节点正在$A$ Chain上开始产生区块，当前区块高度为100，网络中存在一个51%攻击者Bob。假如存在这样一个商业场景，某商家使用该Blockchain作为结算网络，当商家看到转账交易的被成功打包到Block并Append到Blockchain上时就给客户发货。假设，Bob使用了这个商家的服务，发送了一个转账交易。这个交易被打包到了101号Block中。当商家发现自己的收款交易，被打包到了101号区块后，立刻就给Bob发送了商品。那么此刻Bob可以做什么呢？由于Bob控制住了网络中大部分的算力，他可以将网络在100号区块开始进行分叉(fork)，生成一个没有包含给商家转账的101号区块，因此产生一个新的$B$ Chain。由于Bob控制了网络中的大部分算力，他可以尽可能在$B$ Chain继续产生区块，最终$B$ Chain成为了当前网络中最长的Chian。因此$A$ Chain最终会被作废掉，那么此刻在$A$ Chain上的101号块中的交易就作废了，而Bob白嫖了一个商家的服务。 Censor Transaction(交易审查)。Bob也可以进行一些更加隐秘的攻击，比如审查交易。假如Bob有一个竞争对手Alice(另一个Mining Pool)，那么Bob可以做到在所有它打包的Block中都不包括Alice的交易。更严重的，攻击者可以拒绝向Block中打包交易，造成网络拥堵，和事实上的停止服务。 值得注意的是，由于Blockchain是共识系统，分叉和交易审查的事件发生的时候，其他的诚实节点也是能够感知到的。因此，其他的诚实节点或者系统的开发团队(e.g. Ethereum Foundation)可以做出响应再分叉出一条诚实的Chain，以及做出一些补救措施来限制51%攻击者的行为。 此外在有些区块链系统中，分叉是不被允许的比如Tendermint。在这种系统中，攻击者能做的事情就更加有限。</summary></entry><entry><title type="html">如何使用Selenium来下载PDF文件</title><link href="http://www.hsyodyssey.com/python/selenium/2022/05/10/selenium.html" rel="alternate" type="text/html" title="如何使用Selenium来下载PDF文件" /><published>2022-05-10T10:00:00+08:00</published><updated>2022-05-10T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/python/selenium/2022/05/10/selenium</id><content type="html" xml:base="http://www.hsyodyssey.com/python/selenium/2022/05/10/selenium.html">&lt;h2 id=&quot;如何使用selenium来下载pdf&quot;&gt;如何使用Selenium来下载PDF？&lt;/h2&gt;

&lt;p&gt;今天帮老婆写了个爬虫，遇到了这么一个需求: 从给定的页面上下载一个PDF文件。&lt;/p&gt;

&lt;p&gt;但是我们遇到的问题是：不管怎么处理，PDF文件都会在模拟下载后使用Chrome打开，而不是另存为到目标文件夹。搜了一圈，发现不管中英文的结果都是如何把一个html页面保存成PDF。大概是有将页面保存成PDF的需求的人更多。&lt;/p&gt;

&lt;p&gt;这里分享一下结论，希望能帮助到遇到之后相同问题的开发人员:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chromedriver&lt;/code&gt;的时候，同时传入一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webdriver.chrome.options.Options&lt;/code&gt;, 如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 这里是自定义的下载文件夹地址
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;download_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_experimental_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;prefs&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;目标文件夹&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;download.default_directory&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;download_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;关闭用Chrome原生的打开PDF&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;download.prompt_for_download&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;download.directory_upgrade&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;plugins.always_open_pdf_externally&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;创建webdriver的时候额外传入options&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Chrome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrome_options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述的options可以使得Chrome在遇到一个目标为PDF类型的地址时，不会用原生浏览的方式打开它，而是将其保存(下载)到options中指定的目录中。&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Python" /><category term="Selenium" /><category term="Blockchain" /><category term="ZKP" /><category term="Groth16" /><summary type="html">如何使用Selenium来下载PDF？ 今天帮老婆写了个爬虫，遇到了这么一个需求: 从给定的页面上下载一个PDF文件。 但是我们遇到的问题是：不管怎么处理，PDF文件都会在模拟下载后使用Chrome打开，而不是另存为到目标文件夹。搜了一圈，发现不管中英文的结果都是如何把一个html页面保存成PDF。大概是有将页面保存成PDF的需求的人更多。 这里分享一下结论，希望能帮助到遇到之后相同问题的开发人员: 在创建chromedriver的时候，同时传入一个webdriver.chrome.options.Options, 如下: options = webdriver.chrome.options.Options() # 这里是自定义的下载文件夹地址 download_dir = &quot;&quot; options.add_experimental_option(&apos;prefs&apos;, { // 目标文件夹 &quot;download.default_directory&quot;: download_dir, // 关闭用Chrome原生的打开PDF &quot;download.prompt_for_download&quot;: False, &quot;download.directory_upgrade&quot;: True, &quot;plugins.always_open_pdf_externally&quot;: True } ) // 创建webdriver的时候额外传入options driver = webdriver.Chrome(chrome_options=options) 上述的options可以使得Chrome在遇到一个目标为PDF类型的地址时，不会用原生浏览的方式打开它，而是将其保存(下载)到options中指定的目录中。</summary></entry><entry><title type="html">理解Groth16，一些细节上的说明</title><link href="http://www.hsyodyssey.com/zk-snark/2022/03/22/groth16.html" rel="alternate" type="text/html" title="理解Groth16，一些细节上的说明" /><published>2022-03-22T10:00:00+08:00</published><updated>2022-03-22T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/zk-snark/2022/03/22/groth16</id><content type="html" xml:base="http://www.hsyodyssey.com/zk-snark/2022/03/22/groth16.html">&lt;p&gt;&lt;em&gt;Thanks to Zhang Ye, Peng Jingshu for review.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;zkSNARKs 是一种高级的(Advanced)密码学技术。这里的高级不单单指它的先进性，同时也代表了它属于密码学领域中的难以理解的“高级话题”。且不说理解 zkSNARKs 的理论原理，想要搞清楚如何使用 zkSNARKs 技术来解决实际问题都是一件蛮有难度的事情。在本文中，我们来探讨一下一个常用的 zkSNARK System: Groth16 中一些的细节。&lt;/p&gt;

&lt;p&gt;V神曾经写过一篇非常好的介绍 R1CS 与 QAP 问题的&lt;a href=&quot;https://vitalik.ca/general/2016/12/10/qap.html&quot;&gt;文章&lt;/a&gt;。但是，对于不熟悉密码学的，或者说如何使用密码学的思想来解决实际问题的zk票友们来说，文章中的一些逻辑上的跨度还是大了一些。尤其是在R1CS转换成多项式的地方，初次接触的人可能会一脸懵逼，不明白为什么要这么做。下面我就从我的理解来谈一谈，从 R1CS 到 QAP 这一过程。&lt;/p&gt;

&lt;p&gt;在 Groth16 的流程中，我们首先需要把&lt;strong&gt;计算问题&lt;/strong&gt;拍平成&lt;strong&gt;电路&lt;/strong&gt;的形式。在这一步骤中，我们会将原始的计算问题，解构成电路的形式(Circuit)。这个电路和原始的计算问题是等价。电路由若干的算数电路门(Gate)组成。通常情况下，这些电路门都是由两个输入变量，一个输出变量组成。然后我们基于每一个电路门，来构造 R1CS 约束。&lt;/p&gt;

\[a * b = c\]

&lt;p&gt;这里我们直接使用V神的&lt;a href=&quot;https://vitalik.ca/general/2016/12/10/qap.html&quot;&gt;博客&lt;/a&gt;中的例子。下面的三个矩阵是就是原问题对应的电路在 R1CS 约束下的约束矩阵。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A
[0, 1, 0, 0, 0, 0]
[0, 0, 0, 1, 0, 0]
[0, 1, 0, 0, 1, 0]
[5, 0, 0, 0, 0, 1]

B
[0, 1, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]

C
[0, 0, 0, 1, 0, 0]
[0, 0, 0, 0, 1, 0]
[0, 0, 0, 0, 0, 1]
[0, 0, 1, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这三个矩阵都包含了四个行向量，代表了原始的计算被拍平成了在 R1CS 约束下的四个电路门。到了这一步，我们的原问题”&lt;em&gt;我们知道原始计算的一个解&lt;/em&gt;“就转化成了，&lt;em&gt;“我们知道一个解向量，使得它在每个电路约束下都成立”&lt;/em&gt;。我们用 $S$ 来表示解向量，本例中 $S$ 的值如下所示。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1
3
35
9
27
30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时，如果我们想证明我们知道原始计算的一个解，那么就需要证明A，B，C矩阵中的&lt;strong&gt;每个&lt;/strong&gt;行向量与解向量$S$的内积之后的值是符合 R1CS约束的($A_i,B_i,C_i$表示矩阵中的行向量)：&lt;/p&gt;

\[(A_i*S)* (B_i*S) - C_i*S = 0\]

&lt;p&gt;在接下来的一步，我们需要将 R1CS 的约束转换成一个QAP问题。我觉得原文中没有提到的一点时，我们为什么要这么做的？这样的转换目的是什么？V神的原文只描述了这一步骤的目标是把向量的内积计算转化为多项式的形式，以及如何进行拉普拉斯插值求多项式。所以第一次读到这里的时候，我感觉一头雾水。&lt;/p&gt;

&lt;p&gt;这一过程是理解包括 Groth16 在内的所有ZK-Proof System的重点。这里阐述一下我的理解。这样做的原因是，如果只使用 R1CS 的约束矩阵来验证，我们只能一个电路门，一个电路门的，使用列向量与解向量的内积来验证是否满足R1CS的约束。这样在方式在大规模电路下（几十万，上百万的电路门）显然是十分低效的。&lt;/p&gt;

&lt;p&gt;那么接下来的自然思考方向就变成了，存不存在一种办法，可以让我们通过&lt;strong&gt;一次/个计算&lt;/strong&gt;来验证所有约束的正确性？&lt;/p&gt;

&lt;p&gt;我们如果仔细观察上面的计算过程，可以发现解向量中 $S$中的 $S_1$元素一定与约束矩阵中$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$这四个元素相乘。因此，我们假设存在这样一个多项式 $A_1(x)$，它经过$(1,0), (2,0), (3,0), (4,5)$这四个点。这个多项式 $A_1(x)$的数学意义是：当x的值为1时，多项式的值为0，当$x=2$时，多项式的值为0，当$x=3$时，多项式的值为0，当$x=4$时，多项式的值为5。这样，我们通过引入额外的参数x，使得可以使用一个的多项式$A_1(x)$来描述[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]这四个值。&lt;/p&gt;

&lt;p&gt;根据原文中提到的拉普拉斯插值法，我们可以求出关于[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]的多项式为：&lt;/p&gt;

\[A_1(x) = 0.833*x^3 -5.0*x^2 +9.166*x -5.0\]

&lt;p&gt;我们验证一下就可以发现，当x取1时，$A_1(x)$的值为0，等于原R1CS约束矩阵中的$A_{11}$的值。同样的，我们可以构造出其他列向量的多项式$A_i(x),B_i(x),C_i(x)$。&lt;/p&gt;

&lt;p&gt;那么这样，我们就可以使用这几个多项式来描述，向量内积是否满足R1CS约束的过程。我们将解向量$S$带入，原等式的左边可以写成下面的形式:&lt;/p&gt;

\[((1 * A_1(x))+(3 * A_2(x))+(35 * A_3(x)) + (9 * A_4(x)) +(27 * A_5(x))+(30 * A_6(x))) \\ *（(1 * B_1(x)+(3 * B_2(x))+(35 * B_3(x)) + (9 * B_4(x)) +(27 * B_5(x))+(30 * B_6(x))) \\ - （(1 * C_1(x)+(3 * C_2(x))+(35 * C_3(x)) + (9 * C_4(x)) +(27 * C_5(x))+(30 * C_6(x)))\]

&lt;p&gt;当x取1时，上面的多项式就等于验证第一个门电路是否满足 R1CS 约束；当x取2时，上面的多项式就等于验证第二个门电路是否满足R1CS约束。以此类推。现在我们已经将实际的值转换成了多项式，根据x的取值的不同，来描述不同的R1CS约束。&lt;/p&gt;

&lt;p&gt;那么，更进一步的来说，因为上面的式子中都是多项式，我们可以把等式左边展开成一个更简洁的多项式 $p(x)$:&lt;/p&gt;

\[p(x) = (-5.166*x^3+38.5*x^2-73.333*x+43)*(0.666*x^3-5.0*x^2+10.333*x-3.0)-(2.833*x^3-24.5*x^2+10.333*x-41.0)\\
       = -3.440556*x^6+51.471*x^5-294.720056*x^4+805.7885*x^3-1063.749889*x^2+592.652*x-88\]

&lt;p&gt;同时我们需要让等式右边的值等于0。因此，我们就可以先构造一个多项式$t(x)=(x-1)(x-2)(x-3)(x-4)$。显然$t(x)$在x的取值为[1，2，3，4]值情况下都等于0。在本例中，显然$t(x)$是不等于$t(x)$（多项式的阶不同），所以我们引入另一个多项式$h(x)$，使得$p(x)=t(x)h(x)$。&lt;/p&gt;

&lt;p&gt;这一步的操作中蕴含了一个数学引理: &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma&quot;&gt;Schwartz–Zippel lemma&lt;/a&gt;。感兴趣的读者可以深入了解一下这个引理。&lt;/p&gt;

&lt;p&gt;这样我们就实现了用一个多项式来描述所有的 R1CS 的约束了。我们可以设置x值取1，2，3，4，来验证对应的电路的 R1CS 约束是不是合法。在实际问题上，x的取值远不止范围1，2，3，4四个值。&lt;/p&gt;

&lt;p&gt;现在的关于&lt;strong&gt;Prover是否知道原问题的解的证明&lt;/strong&gt;转换成了，&lt;strong&gt;Prover是否知道一个基于原电路R1CS约束正确插值形成的多项式$p(x)$，使得$p(x)=t(x)h(x)$在x的域上都成立&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那么，顺着这个逻辑继续思考，&lt;em&gt;Prover如何向其他人证明，他/她知道这个多项式$P(x)$的存在的呢？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;最简单的方法就是，Prover直接把$p(x)$这个多项式发给Verifier。但是在现实中，多项式$p(x)$的degree可能非常的高，传输$p(x)$成本很大，不符合简洁证明的要求。那么，另一个简单的想法可以是这样的。在公式$p(x)=t(x)h(x)$中，$t(x)$是公开的多项式，那么作为知道$p(x)$的Prover，我们可以快速的计算出$h(x)=\frac{p(x)}{t(x)}$。那么，我们只要提供某个$x=r$对应的$h(r)$,$p(r)$的值给验证者。那么显然，验证者通过计算$t(r)*h(r)$的值，与Prover提供的$p(r)$的值进行比较验证。那么作为Prover，我们不需要公开$p(x)$的细节，就可以向Verifier证明我们知道多项式$p(x)$。&lt;/p&gt;

&lt;p&gt;那么想象一下，Alice对Bob说，我知道一个计算的解。那么Bob可以要求Alice计算$x=r$时，$h(r)$和$p(r)$的值，并且验证$h(r)*t(r)$是否与$p(r)$的值是否相等来判断Alice说的是否正确。同时，在这个过程我们完美的隐藏掉了原来解向量$S$的存在。&lt;/p&gt;

&lt;p&gt;通过，上面的过程，我们就完成了一个简单的零知识问题的转换。但是这个模型并不足够安全，比如Alice可以伪造合法的$h(r)$和$p(r)$的值，使得$p(r)=t(r)h(r)$成立。具体的来说，比如不管Bob请求任意r下的$h(r)$值，Alice总是返回$h(r),p(r) == 0$。用稍微正式的语言来描述这个现象就是：Alice知道了$r$的具体值之后，可以计算出另一组值$t(r’)$,$h(r’)$，使得$p(r’)=t(r)h(r’)$成立。因此在这种情况下，等式的左右两边仍然是相同的，但是不符合我们的目标。&lt;/p&gt;

&lt;p&gt;因此，顺着这个逻辑思考，接下来的需要解决的问题就变成了，&lt;em&gt;如何保证Prover不会伪造&lt;/em&gt;$h(r)$,$p(r)$的值呢？&lt;/p&gt;

&lt;p&gt;这一步就是文章中从QAP到PCP(Probabilistic Checkable Proofs)这一步. 目前这部分主要是通过KCA(Knowledge of Coefficient Test and Assumption)来实现的。Groth16中，我们需要对多项式(电路)建立Common Reference String(CRS)，来保证non-interactive。这也就是我们常常听到的Trusted Setup。Trusted Setup带了不少负面效果。一旦Trusted Setup时的信息发生了泄漏，整个的Proof System的安全性保证也就不存在了。同时在Groth16中，我们需要对每个多项式都进行Trusted Setup的。换句话说，我们需要对每个计算电路都要进行一次的Trusted Setup，这对于图灵完备的通用计算来说成本是非常高的。这也是为什么目前只有ZCash可以良好的运行 zkSNARKs，而很少见到在General-Purpose Blockchain中使用 zkSNARKs相关技术的原因之一。&lt;/p&gt;

&lt;p&gt;为了解决这方面的问题，研究人员提出了&lt;a href=&quot;https://crypto.stanford.edu/bulletproofs/&quot;&gt;BulletProofs&lt;/a&gt;。BulletProofs将Groth16中的多项式证明的部分升级成了基于Inner production-base Polynomial Commitment Scheme。在 BulletProofs中，多项式的验证不再需要 Trusted Setup，但是需要更大的 Proof Size，同时Verifier 需要更久的Verification Time。&lt;/p&gt;

&lt;p&gt;另一方面，研究人员提出了 Plonk协议，这是另一种证明体系。在Plonk中的电路约束不再是R1CS的形式，并且引入了&lt;a href=&quot;https://www.youtube.com/watch?v=W1E2CI_u6d0&quot;&gt;KZG(KATE Commitment)&lt;/a&gt;作为Polynomial Commitment Scheme。在Plonk体系中，只需要一次的Trusted Setup，就可以给多个多项式进行验证。目前，基于 zkRollup 技术的Layer-2解决方案 zkSync 就是基于 Plonk协议开发的。&lt;/p&gt;

&lt;p&gt;关于Plonk，PCS的技术在本篇中不做详解。感兴趣的读者可以搜索相关的关键词进行学习。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Bulletproofs: Short Proofs for Confidential Transactions and More, &lt;a href=&quot;https://crypto.stanford.edu/bulletproofs/&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Schwartz–Zippel lemma, &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Quadratic Arithmetic Programs: from Zero to Hero, &lt;a href=&quot;https://vitalik.ca/general/2016/12/10/qap.html&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Kate Commitments: A Primer, &lt;a href=&quot;https://hackmd.io/@tompocock/Hk2A7BD6U&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Constant-Size Commitments to Polynomials and Their Applications, &lt;a href=&quot;https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Understanding PLONK, &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="zk-SNARK" /><category term="Blockchain" /><category term="ZKP" /><category term="Groth16" /><summary type="html">Thanks to Zhang Ye, Peng Jingshu for review. zkSNARKs 是一种高级的(Advanced)密码学技术。这里的高级不单单指它的先进性，同时也代表了它属于密码学领域中的难以理解的“高级话题”。且不说理解 zkSNARKs 的理论原理，想要搞清楚如何使用 zkSNARKs 技术来解决实际问题都是一件蛮有难度的事情。在本文中，我们来探讨一下一个常用的 zkSNARK System: Groth16 中一些的细节。 V神曾经写过一篇非常好的介绍 R1CS 与 QAP 问题的文章。但是，对于不熟悉密码学的，或者说如何使用密码学的思想来解决实际问题的zk票友们来说，文章中的一些逻辑上的跨度还是大了一些。尤其是在R1CS转换成多项式的地方，初次接触的人可能会一脸懵逼，不明白为什么要这么做。下面我就从我的理解来谈一谈，从 R1CS 到 QAP 这一过程。 在 Groth16 的流程中，我们首先需要把计算问题拍平成电路的形式。在这一步骤中，我们会将原始的计算问题，解构成电路的形式(Circuit)。这个电路和原始的计算问题是等价。电路由若干的算数电路门(Gate)组成。通常情况下，这些电路门都是由两个输入变量，一个输出变量组成。然后我们基于每一个电路门，来构造 R1CS 约束。 \[a * b = c\] 这里我们直接使用V神的博客中的例子。下面的三个矩阵是就是原问题对应的电路在 R1CS 约束下的约束矩阵。 A [0, 1, 0, 0, 0, 0] [0, 0, 0, 1, 0, 0] [0, 1, 0, 0, 1, 0] [5, 0, 0, 0, 0, 1] B [0, 1, 0, 0, 0, 0] [0, 1, 0, 0, 0, 0] [1, 0, 0, 0, 0, 0] [1, 0, 0, 0, 0, 0] C [0, 0, 0, 1, 0, 0] [0, 0, 0, 0, 1, 0] [0, 0, 0, 0, 0, 1] [0, 0, 1, 0, 0, 0] 这三个矩阵都包含了四个行向量，代表了原始的计算被拍平成了在 R1CS 约束下的四个电路门。到了这一步，我们的原问题”我们知道原始计算的一个解“就转化成了，“我们知道一个解向量，使得它在每个电路约束下都成立”。我们用 $S$ 来表示解向量，本例中 $S$ 的值如下所示。 1 3 35 9 27 30 此时，如果我们想证明我们知道原始计算的一个解，那么就需要证明A，B，C矩阵中的每个行向量与解向量$S$的内积之后的值是符合 R1CS约束的($A_i,B_i,C_i$表示矩阵中的行向量)： \[(A_i*S)* (B_i*S) - C_i*S = 0\] 在接下来的一步，我们需要将 R1CS 的约束转换成一个QAP问题。我觉得原文中没有提到的一点时，我们为什么要这么做的？这样的转换目的是什么？V神的原文只描述了这一步骤的目标是把向量的内积计算转化为多项式的形式，以及如何进行拉普拉斯插值求多项式。所以第一次读到这里的时候，我感觉一头雾水。 这一过程是理解包括 Groth16 在内的所有ZK-Proof System的重点。这里阐述一下我的理解。这样做的原因是，如果只使用 R1CS 的约束矩阵来验证，我们只能一个电路门，一个电路门的，使用列向量与解向量的内积来验证是否满足R1CS的约束。这样在方式在大规模电路下（几十万，上百万的电路门）显然是十分低效的。 那么接下来的自然思考方向就变成了，存不存在一种办法，可以让我们通过一次/个计算来验证所有约束的正确性？ 我们如果仔细观察上面的计算过程，可以发现解向量中 $S$中的 $S_1$元素一定与约束矩阵中$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$这四个元素相乘。因此，我们假设存在这样一个多项式 $A_1(x)$，它经过$(1,0), (2,0), (3,0), (4,5)$这四个点。这个多项式 $A_1(x)$的数学意义是：当x的值为1时，多项式的值为0，当$x=2$时，多项式的值为0，当$x=3$时，多项式的值为0，当$x=4$时，多项式的值为5。这样，我们通过引入额外的参数x，使得可以使用一个的多项式$A_1(x)$来描述[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]这四个值。 根据原文中提到的拉普拉斯插值法，我们可以求出关于[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]的多项式为： \[A_1(x) = 0.833*x^3 -5.0*x^2 +9.166*x -5.0\] 我们验证一下就可以发现，当x取1时，$A_1(x)$的值为0，等于原R1CS约束矩阵中的$A_{11}$的值。同样的，我们可以构造出其他列向量的多项式$A_i(x),B_i(x),C_i(x)$。 那么这样，我们就可以使用这几个多项式来描述，向量内积是否满足R1CS约束的过程。我们将解向量$S$带入，原等式的左边可以写成下面的形式: \[((1 * A_1(x))+(3 * A_2(x))+(35 * A_3(x)) + (9 * A_4(x)) +(27 * A_5(x))+(30 * A_6(x))) \\ *（(1 * B_1(x)+(3 * B_2(x))+(35 * B_3(x)) + (9 * B_4(x)) +(27 * B_5(x))+(30 * B_6(x))) \\ - （(1 * C_1(x)+(3 * C_2(x))+(35 * C_3(x)) + (9 * C_4(x)) +(27 * C_5(x))+(30 * C_6(x)))\] 当x取1时，上面的多项式就等于验证第一个门电路是否满足 R1CS 约束；当x取2时，上面的多项式就等于验证第二个门电路是否满足R1CS约束。以此类推。现在我们已经将实际的值转换成了多项式，根据x的取值的不同，来描述不同的R1CS约束。 那么，更进一步的来说，因为上面的式子中都是多项式，我们可以把等式左边展开成一个更简洁的多项式 $p(x)$: \[p(x) = (-5.166*x^3+38.5*x^2-73.333*x+43)*(0.666*x^3-5.0*x^2+10.333*x-3.0)-(2.833*x^3-24.5*x^2+10.333*x-41.0)\\ = -3.440556*x^6+51.471*x^5-294.720056*x^4+805.7885*x^3-1063.749889*x^2+592.652*x-88\] 同时我们需要让等式右边的值等于0。因此，我们就可以先构造一个多项式$t(x)=(x-1)(x-2)(x-3)(x-4)$。显然$t(x)$在x的取值为[1，2，3，4]值情况下都等于0。在本例中，显然$t(x)$是不等于$t(x)$（多项式的阶不同），所以我们引入另一个多项式$h(x)$，使得$p(x)=t(x)h(x)$。 这一步的操作中蕴含了一个数学引理: Schwartz–Zippel lemma。感兴趣的读者可以深入了解一下这个引理。 这样我们就实现了用一个多项式来描述所有的 R1CS 的约束了。我们可以设置x值取1，2，3，4，来验证对应的电路的 R1CS 约束是不是合法。在实际问题上，x的取值远不止范围1，2，3，4四个值。 现在的关于Prover是否知道原问题的解的证明转换成了，Prover是否知道一个基于原电路R1CS约束正确插值形成的多项式$p(x)$，使得$p(x)=t(x)h(x)$在x的域上都成立。 那么，顺着这个逻辑继续思考，Prover如何向其他人证明，他/她知道这个多项式$P(x)$的存在的呢？ 最简单的方法就是，Prover直接把$p(x)$这个多项式发给Verifier。但是在现实中，多项式$p(x)$的degree可能非常的高，传输$p(x)$成本很大，不符合简洁证明的要求。那么，另一个简单的想法可以是这样的。在公式$p(x)=t(x)h(x)$中，$t(x)$是公开的多项式，那么作为知道$p(x)$的Prover，我们可以快速的计算出$h(x)=\frac{p(x)}{t(x)}$。那么，我们只要提供某个$x=r$对应的$h(r)$,$p(r)$的值给验证者。那么显然，验证者通过计算$t(r)*h(r)$的值，与Prover提供的$p(r)$的值进行比较验证。那么作为Prover，我们不需要公开$p(x)$的细节，就可以向Verifier证明我们知道多项式$p(x)$。 那么想象一下，Alice对Bob说，我知道一个计算的解。那么Bob可以要求Alice计算$x=r$时，$h(r)$和$p(r)$的值，并且验证$h(r)*t(r)$是否与$p(r)$的值是否相等来判断Alice说的是否正确。同时，在这个过程我们完美的隐藏掉了原来解向量$S$的存在。 通过，上面的过程，我们就完成了一个简单的零知识问题的转换。但是这个模型并不足够安全，比如Alice可以伪造合法的$h(r)$和$p(r)$的值，使得$p(r)=t(r)h(r)$成立。具体的来说，比如不管Bob请求任意r下的$h(r)$值，Alice总是返回$h(r),p(r) == 0$。用稍微正式的语言来描述这个现象就是：Alice知道了$r$的具体值之后，可以计算出另一组值$t(r’)$,$h(r’)$，使得$p(r’)=t(r)h(r’)$成立。因此在这种情况下，等式的左右两边仍然是相同的，但是不符合我们的目标。 因此，顺着这个逻辑思考，接下来的需要解决的问题就变成了，如何保证Prover不会伪造$h(r)$,$p(r)$的值呢？ 这一步就是文章中从QAP到PCP(Probabilistic Checkable Proofs)这一步. 目前这部分主要是通过KCA(Knowledge of Coefficient Test and Assumption)来实现的。Groth16中，我们需要对多项式(电路)建立Common Reference String(CRS)，来保证non-interactive。这也就是我们常常听到的Trusted Setup。Trusted Setup带了不少负面效果。一旦Trusted Setup时的信息发生了泄漏，整个的Proof System的安全性保证也就不存在了。同时在Groth16中，我们需要对每个多项式都进行Trusted Setup的。换句话说，我们需要对每个计算电路都要进行一次的Trusted Setup，这对于图灵完备的通用计算来说成本是非常高的。这也是为什么目前只有ZCash可以良好的运行 zkSNARKs，而很少见到在General-Purpose Blockchain中使用 zkSNARKs相关技术的原因之一。 为了解决这方面的问题，研究人员提出了BulletProofs。BulletProofs将Groth16中的多项式证明的部分升级成了基于Inner production-base Polynomial Commitment Scheme。在 BulletProofs中，多项式的验证不再需要 Trusted Setup，但是需要更大的 Proof Size，同时Verifier 需要更久的Verification Time。 另一方面，研究人员提出了 Plonk协议，这是另一种证明体系。在Plonk中的电路约束不再是R1CS的形式，并且引入了KZG(KATE Commitment)作为Polynomial Commitment Scheme。在Plonk体系中，只需要一次的Trusted Setup，就可以给多个多项式进行验证。目前，基于 zkRollup 技术的Layer-2解决方案 zkSync 就是基于 Plonk协议开发的。 关于Plonk，PCS的技术在本篇中不做详解。感兴趣的读者可以搜索相关的关键词进行学习。 References Bulletproofs: Short Proofs for Confidential Transactions and More, [link] Schwartz–Zippel lemma, [link] Quadratic Arithmetic Programs: from Zero to Hero, [link] Kate Commitments: A Primer, [link] Constant-Size Commitments to Polynomials and Their Applications, [link] Understanding PLONK, [link]</summary></entry><entry><title type="html">诈骗与PUA</title><link href="http://www.hsyodyssey.com/daily/2022/03/15/pua.html" rel="alternate" type="text/html" title="诈骗与PUA" /><published>2022-03-15T10:00:00+08:00</published><updated>2022-03-15T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/daily/2022/03/15/pua</id><content type="html" xml:base="http://www.hsyodyssey.com/daily/2022/03/15/pua.html">&lt;p&gt;早上的时候，我接到了一通来自泉州的移动电话。对方声称自己是京东的客服，并快速的介绍了自己的工号。一口流利的普通话，加上我对京东这个公司的好感度，让我并没有第一时间挂断他的电话。在对方准确的说出了我的名字以及学校之后，事情开始变得微妙起来。对方声称，因为两会的关系，上面要求未来京东不在对学生身份的用户提供金融服务，例如白条等，让我自行的在京东APP上关闭自己的学生认证，否则可能会出现征信上的问题。并好心的向我介绍了关闭的方法，在京东APP中搜索某个页面并关闭。之后就有礼貌的挂断了电话。我按照他的指示找到了他描述的页面，但是却不是他所描述的取消学生身份的页面，只是激活了一个学生身份的会员。&lt;/p&gt;

&lt;p&gt;其实事情发展到这里并没有什么特别异常的地方，我的第一感觉还是这是通来自京东的客服推销电话。结果到下午的时候，我接到了第二通电话。对方上来就是指责我并没有理会他同事的后续电话，没有按照他同事的要求取消我在京东上的学生认证，并警告我如果不及时处理，他们将会向我做出滞纳金处罚。我当下感觉十分的气愤，并强烈的回敬说京东算个鸡吧，作为你司长期股东加大客户，你凭什么收我的钱？对方大概是没有见到过我这么粗暴的“目标”，当下表示不是这个意思，只是为了帮我解决问题。但我余怒未消，感觉到作为京东大客户反遭背刺，臭骂对方一句，并扬言要自己打电话给官方投诉他，然后挂掉了电话。&lt;/p&gt;

&lt;p&gt;事情发展到这里，读者大概也已经猜到了，这是连续的电信诈骗电话。在挂掉电话后，我当下就打电话给了京东的官方客服，并向他询问我是不是遇到了诈骗。不得不说，真正的京东客服态度是真的好，非常和善的告诉我，他们不会对客户说出罚款之类的话，显然这就是电话诈骗。&lt;/p&gt;

&lt;p&gt;在这次事件中，我并没有什么损失，除了几分钟的气愤。但是，我也必须承认，这个骗子团伙确实骗到了我。其实在最开始的时候，我就问了他一个问题，为什么你们京东的客服电话是一个泉州的手机号码，而不是常见的官方电话，或者是宿迁的电话？但是在对方准确的叫出了我的名字，并给了一定的解释之后，我选择了相信。在第二通电话中，对方声称的上面要求的罚款，滞纳金，我还是相信了。单从骗人的角度来说，对面的骗子确实完成了既定目标，只不过我并没有顺着他设好的思维路径继续下去。&lt;/p&gt;

&lt;p&gt;我想诈骗和PUA一样，都是一种在精心设计好的框架下的精神控制。如果顺着对方的逻辑，受害者注定是逃不出对方的圈套的。仔细思考了一下，诈骗和PUA一样，首先都是要骗取受害人的信任，卸下防备。比如在上述的案例中，准确的说出我的名字和学校。第二步，充当善意的好人。在这一个步骤中，对方并不会对受害人索取什么，反而充当一种提供帮助的角色，不管是物质帮助，或者精神帮助。比如，在这次诈骗中，骗子的第一个电话的目的是为了帮我解决潜在的风险。第三步，对受害人开始有边界的威胁，这种威胁一定不是用力过猛的狠毒威胁，而是有边界的轻拿轻的放的威胁，比如利用受害人对公权力的敬畏。在我经历这个案例中，骗子就声称如果不解决这个问题，就会影响到我未来的征信记录。或者，利用人性的善意，比如新闻中的常客，杀猪盘，就是利用了人性中害怕失去的善良，仿佛如果你不打钱给对方，就会永远失去对方。&lt;/p&gt;

&lt;p&gt;PUA也好，诈骗也好，都是缺大德的下贱至极的行为。能做出这种事情的，也都是丧尽天良之人中的渣滓中的臭蛆。拉低人类这种生物的道德底线的烂人中的烂人。这种情况广泛存在于现实世界的各个角落，包括所谓的“高大上”的学术圈，更是丧尽祖宗十八代良心的Pua的高发地。&lt;/p&gt;

&lt;p&gt;破除PUA与诈骗的方式主要方式就是要忠于自己。当其他人试图精神控制的时候，跳出他们的思维路径，认真思考，&lt;strong&gt;假如我不按照他说的那么做，又会这样呢？&lt;/strong&gt;&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Daily" /><category term="Daily" /><summary type="html">早上的时候，我接到了一通来自泉州的移动电话。对方声称自己是京东的客服，并快速的介绍了自己的工号。一口流利的普通话，加上我对京东这个公司的好感度，让我并没有第一时间挂断他的电话。在对方准确的说出了我的名字以及学校之后，事情开始变得微妙起来。对方声称，因为两会的关系，上面要求未来京东不在对学生身份的用户提供金融服务，例如白条等，让我自行的在京东APP上关闭自己的学生认证，否则可能会出现征信上的问题。并好心的向我介绍了关闭的方法，在京东APP中搜索某个页面并关闭。之后就有礼貌的挂断了电话。我按照他的指示找到了他描述的页面，但是却不是他所描述的取消学生身份的页面，只是激活了一个学生身份的会员。 其实事情发展到这里并没有什么特别异常的地方，我的第一感觉还是这是通来自京东的客服推销电话。结果到下午的时候，我接到了第二通电话。对方上来就是指责我并没有理会他同事的后续电话，没有按照他同事的要求取消我在京东上的学生认证，并警告我如果不及时处理，他们将会向我做出滞纳金处罚。我当下感觉十分的气愤，并强烈的回敬说京东算个鸡吧，作为你司长期股东加大客户，你凭什么收我的钱？对方大概是没有见到过我这么粗暴的“目标”，当下表示不是这个意思，只是为了帮我解决问题。但我余怒未消，感觉到作为京东大客户反遭背刺，臭骂对方一句，并扬言要自己打电话给官方投诉他，然后挂掉了电话。 事情发展到这里，读者大概也已经猜到了，这是连续的电信诈骗电话。在挂掉电话后，我当下就打电话给了京东的官方客服，并向他询问我是不是遇到了诈骗。不得不说，真正的京东客服态度是真的好，非常和善的告诉我，他们不会对客户说出罚款之类的话，显然这就是电话诈骗。 在这次事件中，我并没有什么损失，除了几分钟的气愤。但是，我也必须承认，这个骗子团伙确实骗到了我。其实在最开始的时候，我就问了他一个问题，为什么你们京东的客服电话是一个泉州的手机号码，而不是常见的官方电话，或者是宿迁的电话？但是在对方准确的叫出了我的名字，并给了一定的解释之后，我选择了相信。在第二通电话中，对方声称的上面要求的罚款，滞纳金，我还是相信了。单从骗人的角度来说，对面的骗子确实完成了既定目标，只不过我并没有顺着他设好的思维路径继续下去。 我想诈骗和PUA一样，都是一种在精心设计好的框架下的精神控制。如果顺着对方的逻辑，受害者注定是逃不出对方的圈套的。仔细思考了一下，诈骗和PUA一样，首先都是要骗取受害人的信任，卸下防备。比如在上述的案例中，准确的说出我的名字和学校。第二步，充当善意的好人。在这一个步骤中，对方并不会对受害人索取什么，反而充当一种提供帮助的角色，不管是物质帮助，或者精神帮助。比如，在这次诈骗中，骗子的第一个电话的目的是为了帮我解决潜在的风险。第三步，对受害人开始有边界的威胁，这种威胁一定不是用力过猛的狠毒威胁，而是有边界的轻拿轻的放的威胁，比如利用受害人对公权力的敬畏。在我经历这个案例中，骗子就声称如果不解决这个问题，就会影响到我未来的征信记录。或者，利用人性的善意，比如新闻中的常客，杀猪盘，就是利用了人性中害怕失去的善良，仿佛如果你不打钱给对方，就会永远失去对方。 PUA也好，诈骗也好，都是缺大德的下贱至极的行为。能做出这种事情的，也都是丧尽天良之人中的渣滓中的臭蛆。拉低人类这种生物的道德底线的烂人中的烂人。这种情况广泛存在于现实世界的各个角落，包括所谓的“高大上”的学术圈，更是丧尽祖宗十八代良心的Pua的高发地。 破除PUA与诈骗的方式主要方式就是要忠于自己。当其他人试图精神控制的时候，跳出他们的思维路径，认真思考，假如我不按照他说的那么做，又会这样呢？</summary></entry><entry><title type="html">Rollup/zk-Rollup以及zkVM/zkEVM</title><link href="http://www.hsyodyssey.com/blockchain/2022/02/02/rollup_and_ZKVM.html" rel="alternate" type="text/html" title="Rollup/zk-Rollup以及zkVM/zkEVM" /><published>2022-02-02T10:00:00+08:00</published><updated>2022-02-02T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/02/02/rollup_and_ZKVM</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/02/02/rollup_and_ZKVM.html">&lt;p&gt;自从&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;EIP-1559&lt;/a&gt;生效后，由于币价的升高，和基础 Gas Price 的约束，Ethereum Mainnet上的单笔交易费用已经高到了离谱的程度。在上个月的一次实验中，我尝试了一把在Layer-1上调用一次古早的合约，大概花了100美刀左右的交易费。就像社区内经常听到的抱怨声那样，Ethereum  Mainnet已经成为了普通用户用不起的贵族链。&lt;/p&gt;

&lt;p&gt;显然，目前&lt;strong&gt;天价的交易费&lt;/strong&gt;以及&lt;strong&gt;有限的Throughput&lt;/strong&gt;已经成为了限制Ethereum继续发展的两大难题。幸运的是，&lt;strong&gt;rollup&lt;/strong&gt;技术的发展给社区展现了一种似乎可以一招解决两大难题的绝世武学。&lt;/p&gt;

&lt;p&gt;简单的来说，顾名思义，rollup，就是把一堆的transaction rollup到一个新的transaction。然后，通过某种神奇的技术，使得Ethereum Mainnet只需要验证这个新生成的transaction，就可以保证被Rollup之前的若干的Transaction的确定性，正确性，完整性。举个简单的例子，我们想象一个学校内交学费的场景。过去，每个学生(i.e. Account)都需要通过学校交费系统(i.e. Ethereum Mainnet)单独的将自己的学费转账(Transfer)给学校教务处。假如，现在计算机系有1000个学生，那么系统就要处理1000笔转账的交易(Transaction)。现在，系里新来一位叫做&lt;em&gt;Rollup&lt;/em&gt;的教授。他在学生中很有号召力。基于他的个人魅力(神奇的魔法)，&lt;strong&gt;私下里&lt;/strong&gt;让所有的的学生把钱通过&lt;strong&gt;某种方式&lt;/strong&gt;先转给他。当&lt;em&gt;Prof.Rollup&lt;/em&gt;收集到系里所有学生的学费之后，然后他通过构造一个transaction把所有的学费交给教务处。这个例子大概就是一个Rollup场景的简单抽象。我们把学校的交费系统看作为Ethereum Mainnet 或者说是Layer-1，那么私下里收集学生的学费就是所谓的&lt;strong&gt;Layer-2&lt;/strong&gt;进行的了。通常，我们把Layer-1上的交易称为on-chain transaction，把在Layer-2进行上的交易称为off-chain transaction。&lt;/p&gt;

&lt;p&gt;Rollup的好处是显而易见的，假如每次把&lt;strong&gt;N&lt;/strong&gt;个transaction rollup成一个，那么对于Mainnet来说，处理一条交易，实际效果等同于处理了之前系统中的&lt;strong&gt;N&lt;/strong&gt;个交易。同时，系统实际吞吐量的Upper Bound也实际上上市到了&lt;strong&gt;N*MAX_TPS&lt;/strong&gt;的水平。同时，对于用户来说，同样一条交易Mainnet Transaction Fee实际上是被&lt;strong&gt;N&lt;/strong&gt;个用户同时负担的。那么理论上，用户需要的实际交易费用也只有之前的&lt;strong&gt;1/N+c&lt;/strong&gt;。这里的&lt;strong&gt;c&lt;/strong&gt;代表rollup服务提供商收取的交易费，这个值是远远小于layer-1上交易所需要的交易费用的。&lt;/p&gt;

&lt;p&gt;Rollup看上去完美的解决了Ethereum面临的两大难题，通过分层的方式给Ethereum进行了扩容。但是，在实现layer-2 rollup时，还是有很多的细节有待商榷。比如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;怎么保证&lt;em&gt;Prof.Rollup&lt;/em&gt;一定会把学费交给教务处呢？ (Layer-2 交易的安全性)&lt;/li&gt;
  &lt;li&gt;怎么保证&lt;em&gt;Prof.Rollup&lt;/em&gt;会把全部的学费都交给教务处呢？(Layer-2 交易的完整性)&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Prof.Rollup&lt;/em&gt;什么时候才会把学费打给教务处呢？(Layer-2 到Layer-1 跨链交易的时效性问题)&lt;/li&gt;
  &lt;li&gt;等等..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就像华山派的剑宗和气宗分家一样，目前，在如何实现Rollup上，主要分为了两大流派，分别是&lt;strong&gt;Optimism-Rollup&lt;/strong&gt;，和&lt;strong&gt;ZK-Rollup&lt;/strong&gt;。两种路线各有所长，又各有不足。&lt;/p&gt;

&lt;h2 id=&quot;optimism-rollup&quot;&gt;Optimism-Rollup&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Optimism
    &lt;ul&gt;
      &lt;li&gt;原Plasma团队的作品，乐观模式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Arbitrum
    &lt;ul&gt;
      &lt;li&gt;乐观模式，Layer-2完全兼容EVM，通过设置挑战时间来保证跨链交易，目前是one week。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;zk-rollup&quot;&gt;ZK-Rollup&lt;/h2&gt;

&lt;p&gt;ZK-Rollup核心是利用了Zero-Knowledge Proof的技术来实现rollup。ZKP里面的细节比较多，在这里我们不展开描述。其中最重要的核心点是ZK-Rollup主要利用了ZK-SNARKs中的可验证性的正确性保障，以及Verification Time相对较快的特性，来保证layer-1上的Miner可以很快的验证大量交易的准确性。&lt;/p&gt;

&lt;p&gt;但是正因为ZKP的一些特性，使得ZK-Rollup相比于Optimism-Rollup，在开发上的并没有进行的那么顺利。&lt;/p&gt;

&lt;p&gt;拿一个应用广泛的ZK-SNARKs协议Groth16举例来说，其计算的基础来自于:&lt;em&gt;将一个计算电路(Circuit)，转化为R1CS的形式&lt;/em&gt;，继而转化为QAP问题，最终将问题的Witness生成零知识的Proof。如果我们想生成一个Problem/Computation/Function的ZK-SNARKs的Witness/Proof，那么首先我们需要要把这个问题转化为一个Circuit的形式。或者说用Circuit的语言，用R1CS的形式来描述原计算问题。对于简单的计算问题来说，比如加减计算，解方程组，将问题转化为电路的形式并不是特别的困难。但是对于Ethereum上各种支持图灵完备的智能合约的function来说这个问题就变得非常的棘手。主要因为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;转化生成的电路是静态的，虽然电路中有可以复用的部分(Garget)，但是每个Problem/Computation/Function都要构造新的电路。&lt;/li&gt;
  &lt;li&gt;对于通用计算问题，构造出来的电路需要的gate数量可能是惊人的高。这意味着ZK-Rollup可能需要非常长的时间来生成Proof。&lt;/li&gt;
  &lt;li&gt;对于目前EVM架构下的某些计算问题，生成其电路是非常困难的。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;附1&lt;/em&gt; 对于Groth16，每个新的电路，都需要一次Setup，成本非常高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两个问题属于General的ZK-SNARKs应用都会遇到的问题，目前已经有一些的研究人员/公司正在尝试解决这个问题。比如AleoHQ的创始人Howard Wu提出的&lt;a href=&quot;https://www.usenix.org/conference/usenixsecurity18/presentation/wu&quot;&gt;DIZK&lt;/a&gt;通过分布式的Cluster来并发计算Proof，以及Scroll的创始人&lt;a href=&quot;https://twitter.com/yezhang1998&quot;&gt;Zhang Ye&lt;/a&gt;，提出的&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/pipezk-accelerating-zero-knowledge-proof-with-a-pipelined-architecture/&quot;&gt;PipeZK&lt;/a&gt;通过ASIC来加速ZK计算。&lt;/p&gt;

&lt;p&gt;对于第三个问题，属于Ethereum中的专有的问题，也是目前zk-Rollup实现中最难，最需要攻克的问题。我们知道在Ethereum中，一条调用合约Function的Transaction的执行是基于/通过EVM的来执行的。EVM会将Transaction中的函数调用，基于合约代码，转换成opcodes的形式，保存在Stack中逐条执行。这个过程类似于编译过程中的IR代码生成，或者高级语言到汇编语言的过程。在执行这些opcodes时，本质上是在执行geth中对应的库函数，部分细节可以参考之前的&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2021/07/25/ethereum_txn.html&quot;&gt;blog&lt;/a&gt;。那么如果我们想把一个Transaction的合约调用转换成一个电路的话，本质上我们就要基于这个函数调用过程中执行过的opcodes来生成电路。目前的问题是，EVM在设计的时候并没有考虑到将来会被ZK-SNARKs化这一问题。所以，我们不得不面对现实，即EVM中的140个opcode中有些是难以构造电路的。同时Ehereum中大量使用的Keccek256哈希算法，和RLP编码都给构造电路带来了巨大的挑战。&lt;/p&gt;

&lt;p&gt;结果就是，在目前的ZK-Rollup的解决方案中，大部分&lt;strong&gt;仅支持基础的转账操作&lt;/strong&gt;，而&lt;strong&gt;不能支持&lt;/strong&gt;通用的图灵完备的计算。也就是说，目前的ZK-Rollup的解决方案都是不完整的，不能完整的发挥Ethereum图灵完备合约的特性，Layer-2又回到了仅支持Token转账的时代。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，使得Layer-2能支持像现在的Layer-1一样的功能，目前的技术主要在朝向两个方向发展，1. 构建ZK-SNARKs兼容的zkEVM，2.提出新的VM来兼容ZK-SNARKs，并想办法与Ethereum兼容。&lt;/p&gt;

&lt;h3 id=&quot;构建兼容evm的zkevm&quot;&gt;构建兼容EVM的zkEVM&lt;/h3&gt;

&lt;p&gt;这种方案好处在于，开发人员可以继续使用Solidity来构建智能合约。如何构造电路，完全交给底层的ZK-EVM来完成。ZK-EVM和现有的EVM是完全兼容的，现有的Ethereum Contract都可以直接移植到Layer-2上来使用。这种方案对现有的以太坊生态圈非常的友好，社区的合约开发人员在开发时，不需要学习什么额外的新知识，零门槛上手。&lt;/p&gt;

&lt;p&gt;这种方案的难点在于如何把现有的EVM, OPcode抽象成电路。目前正在研究这个路线的有下面两个团队，Scroll和Polygon Hermez。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scroll
    &lt;ul&gt;
      &lt;li&gt;通用zkEVM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.hermez.io/#start-here-for-hermez-10-documentation&quot;&gt;Polygon Hermez&lt;/a&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;Hermez 1.0: Support Ethereum Token transfer.&lt;/li&gt;
          &lt;li&gt;Hermez 2.0: Recreating all the EVM opcodes (Seem they have the same goal with Scroll).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;提出新的vm编程语言&quot;&gt;提出新的VM/编程语言&lt;/h3&gt;

&lt;p&gt;这种方案完全甩开了EVM的包袱，重新设计对ZK友好的VM以及对应的Programming Language。由于没有了包袱，所以这种方案开发起来比较快，目前进展最快的应该是StareWare团队开发的Cairo语言。&lt;/p&gt;

&lt;p&gt;但是基于这种解决方案Zk-Rollup，不能在Layer-2上直接使用Layer-1上已经编写好的Solidity合约。需要合约开发人员重新学习一门新的语言来重新编写合约。或者会将Solidity转译成另一种语言，但是可能有些语法无法兼容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;StareWare&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;专用语言: &lt;a href=&quot;https://cairo-lang.org/docs/&quot;&gt;Cairo&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;StarkNet uses the Cairo programing language both for infrastructure and for writing StarkNet contracts.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;专用硬件加速Proof生成&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Zksync&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;专用合约编程语言: &lt;a href=&quot;https://github.com/matter-labs/zinc&quot;&gt;Zinc&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;语法很像Rust&lt;/li&gt;
              &lt;li&gt;没有写自己编译器，使用的LLVM作为编译的前端和后端。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;SyncVM&lt;/li&gt;
          &lt;li&gt;专用硬件加速Proof生成(FPGA)&lt;/li&gt;
          &lt;li&gt;Proof System: &lt;a href=&quot;https://eprint.iacr.org/2019/953&quot;&gt;PLONK&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Con’t
        &lt;ul&gt;
          &lt;li&gt;并不支持所有EVM opcodes&lt;/li&gt;
          &lt;li&gt;支持部分的L1上的Solidity的合约直接使用，但是如果合约中涉及到SHA256 and Keccak256会被编译器直接修改会其他电路友好的哈希函数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;一些思考&quot;&gt;一些思考&lt;/h3&gt;

&lt;p&gt;从我个人的角度来说，提出新的VM/编程语言的方案不能算非常友好的。首先以太坊社区在Solidity生态建设方面已经做的非常的完善，有大量的已经审计过的合约可供开发人员参考，有大量的生产工具可供使用。对于智能合约来说，由于其代码部分不可修改的特性，合约安全是至关重要的。重新构造一个新的编程语言环境下的合约社区是非常困难的。第二，现在需要学习一门新语言的成本太高了，尤其是学习相比C++/Java/Python更加小众的智能合约开发语言。新的编程语言，为了不和现有的开发语言完全一致而设计的新的语法，语法糖，很容易让开发人员头大。在社区还不够成熟之前，很难吸引到足够多有能力的开发人员。&lt;/p&gt;

&lt;p&gt;所以我更看好类似Scroll/Polygon Hermez这种Layer-2项目的发展。&lt;/p&gt;

&lt;h3 id=&quot;其他zk-related-project&quot;&gt;其他ZK-Related Project&lt;/h3&gt;

&lt;p&gt;在阅读资料时发现的一个项目AleoHQ，看上去是一个原生支持ZKP的图灵完备的新的公链项目，由Berkeley的团队开发。Founder Howard Wu实力很强，是最早的Libsnarks的开发者之一。具体的细节我还在了解之中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/AleoHQ&quot;&gt;AleoHQ&lt;/a&gt;&lt;/strong&gt;, Developed by Howard Wu (UC Berkeley)
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;Aleo is the first decentralized, open-source platform to enable both private and programmable applications.&lt;/li&gt;
          &lt;li&gt;Strong privacy guarantees.&lt;/li&gt;
          &lt;li&gt;专用语言: &lt;a href=&quot;https://github.com/AleoHQ/leo&quot;&gt;Leo&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;Leo converts a developer’s high-level code into zero knowledge circuits.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;snarkOS:
            &lt;ul&gt;
              &lt;li&gt;Aleo runs on a decentralized operating system for private applications called snarkOS. (&lt;em&gt;HAN:Seems like zkGeth?&lt;/em&gt;)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Core Part: ZEXE (Zero Knowledge EXEcution)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;related-papers&quot;&gt;Related Papers&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Zexe: Enabling Decentralized Private Computation, &lt;a href=&quot;https://eprint.iacr.org/2018/962.pdf&quot;&gt;[Paper link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;DIZK: A Distributed Zero Knowledge Proof System, &lt;a href=&quot;https://www.usenix.org/conference/usenixsecurity18/presentation/wu&quot;&gt;[Paper link]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;EIP-1559: Fee market change for ETH 1.0 chain, &lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;gnark zk-SNARK library (go), &lt;a href=&quot;https://github.com/ConsenSys/gnark&quot;&gt;[Codebase]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;A specification for a ZK-EVM, &lt;a href=&quot;https://ethresear.ch/t/a-zk-evm-specification/11549&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;zkEVM, Zhang Ye, &lt;a href=&quot;https://hackmd.io/@yezhang/S1_KMMbGt&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="ZKP" /><category term="Layer-2" /><category term="Rollup" /><category term="zk-Rollup" /><summary type="html">自从EIP-1559生效后，由于币价的升高，和基础 Gas Price 的约束，Ethereum Mainnet上的单笔交易费用已经高到了离谱的程度。在上个月的一次实验中，我尝试了一把在Layer-1上调用一次古早的合约，大概花了100美刀左右的交易费。就像社区内经常听到的抱怨声那样，Ethereum Mainnet已经成为了普通用户用不起的贵族链。 显然，目前天价的交易费以及有限的Throughput已经成为了限制Ethereum继续发展的两大难题。幸运的是，rollup技术的发展给社区展现了一种似乎可以一招解决两大难题的绝世武学。 简单的来说，顾名思义，rollup，就是把一堆的transaction rollup到一个新的transaction。然后，通过某种神奇的技术，使得Ethereum Mainnet只需要验证这个新生成的transaction，就可以保证被Rollup之前的若干的Transaction的确定性，正确性，完整性。举个简单的例子，我们想象一个学校内交学费的场景。过去，每个学生(i.e. Account)都需要通过学校交费系统(i.e. Ethereum Mainnet)单独的将自己的学费转账(Transfer)给学校教务处。假如，现在计算机系有1000个学生，那么系统就要处理1000笔转账的交易(Transaction)。现在，系里新来一位叫做Rollup的教授。他在学生中很有号召力。基于他的个人魅力(神奇的魔法)，私下里让所有的的学生把钱通过某种方式先转给他。当Prof.Rollup收集到系里所有学生的学费之后，然后他通过构造一个transaction把所有的学费交给教务处。这个例子大概就是一个Rollup场景的简单抽象。我们把学校的交费系统看作为Ethereum Mainnet 或者说是Layer-1，那么私下里收集学生的学费就是所谓的Layer-2进行的了。通常，我们把Layer-1上的交易称为on-chain transaction，把在Layer-2进行上的交易称为off-chain transaction。 Rollup的好处是显而易见的，假如每次把N个transaction rollup成一个，那么对于Mainnet来说，处理一条交易，实际效果等同于处理了之前系统中的N个交易。同时，系统实际吞吐量的Upper Bound也实际上上市到了N*MAX_TPS的水平。同时，对于用户来说，同样一条交易Mainnet Transaction Fee实际上是被N个用户同时负担的。那么理论上，用户需要的实际交易费用也只有之前的1/N+c。这里的c代表rollup服务提供商收取的交易费，这个值是远远小于layer-1上交易所需要的交易费用的。 Rollup看上去完美的解决了Ethereum面临的两大难题，通过分层的方式给Ethereum进行了扩容。但是，在实现layer-2 rollup时，还是有很多的细节有待商榷。比如: 怎么保证Prof.Rollup一定会把学费交给教务处呢？ (Layer-2 交易的安全性) 怎么保证Prof.Rollup会把全部的学费都交给教务处呢？(Layer-2 交易的完整性) Prof.Rollup什么时候才会把学费打给教务处呢？(Layer-2 到Layer-1 跨链交易的时效性问题) 等等.. 就像华山派的剑宗和气宗分家一样，目前，在如何实现Rollup上，主要分为了两大流派，分别是Optimism-Rollup，和ZK-Rollup。两种路线各有所长，又各有不足。 Optimism-Rollup Optimism 原Plasma团队的作品，乐观模式。 Arbitrum 乐观模式，Layer-2完全兼容EVM，通过设置挑战时间来保证跨链交易，目前是one week。 ZK-Rollup ZK-Rollup核心是利用了Zero-Knowledge Proof的技术来实现rollup。ZKP里面的细节比较多，在这里我们不展开描述。其中最重要的核心点是ZK-Rollup主要利用了ZK-SNARKs中的可验证性的正确性保障，以及Verification Time相对较快的特性，来保证layer-1上的Miner可以很快的验证大量交易的准确性。 但是正因为ZKP的一些特性，使得ZK-Rollup相比于Optimism-Rollup，在开发上的并没有进行的那么顺利。 拿一个应用广泛的ZK-SNARKs协议Groth16举例来说，其计算的基础来自于:将一个计算电路(Circuit)，转化为R1CS的形式，继而转化为QAP问题，最终将问题的Witness生成零知识的Proof。如果我们想生成一个Problem/Computation/Function的ZK-SNARKs的Witness/Proof，那么首先我们需要要把这个问题转化为一个Circuit的形式。或者说用Circuit的语言，用R1CS的形式来描述原计算问题。对于简单的计算问题来说，比如加减计算，解方程组，将问题转化为电路的形式并不是特别的困难。但是对于Ethereum上各种支持图灵完备的智能合约的function来说这个问题就变得非常的棘手。主要因为： 转化生成的电路是静态的，虽然电路中有可以复用的部分(Garget)，但是每个Problem/Computation/Function都要构造新的电路。 对于通用计算问题，构造出来的电路需要的gate数量可能是惊人的高。这意味着ZK-Rollup可能需要非常长的时间来生成Proof。 对于目前EVM架构下的某些计算问题，生成其电路是非常困难的。 附1 对于Groth16，每个新的电路，都需要一次Setup，成本非常高。 前两个问题属于General的ZK-SNARKs应用都会遇到的问题，目前已经有一些的研究人员/公司正在尝试解决这个问题。比如AleoHQ的创始人Howard Wu提出的DIZK通过分布式的Cluster来并发计算Proof，以及Scroll的创始人Zhang Ye，提出的PipeZK通过ASIC来加速ZK计算。 对于第三个问题，属于Ethereum中的专有的问题，也是目前zk-Rollup实现中最难，最需要攻克的问题。我们知道在Ethereum中，一条调用合约Function的Transaction的执行是基于/通过EVM的来执行的。EVM会将Transaction中的函数调用，基于合约代码，转换成opcodes的形式，保存在Stack中逐条执行。这个过程类似于编译过程中的IR代码生成，或者高级语言到汇编语言的过程。在执行这些opcodes时，本质上是在执行geth中对应的库函数，部分细节可以参考之前的blog。那么如果我们想把一个Transaction的合约调用转换成一个电路的话，本质上我们就要基于这个函数调用过程中执行过的opcodes来生成电路。目前的问题是，EVM在设计的时候并没有考虑到将来会被ZK-SNARKs化这一问题。所以，我们不得不面对现实，即EVM中的140个opcode中有些是难以构造电路的。同时Ehereum中大量使用的Keccek256哈希算法，和RLP编码都给构造电路带来了巨大的挑战。 结果就是，在目前的ZK-Rollup的解决方案中，大部分仅支持基础的转账操作，而不能支持通用的图灵完备的计算。也就是说，目前的ZK-Rollup的解决方案都是不完整的，不能完整的发挥Ethereum图灵完备合约的特性，Layer-2又回到了仅支持Token转账的时代。 为了解决这个问题，使得Layer-2能支持像现在的Layer-1一样的功能，目前的技术主要在朝向两个方向发展，1. 构建ZK-SNARKs兼容的zkEVM，2.提出新的VM来兼容ZK-SNARKs，并想办法与Ethereum兼容。 构建兼容EVM的zkEVM 这种方案好处在于，开发人员可以继续使用Solidity来构建智能合约。如何构造电路，完全交给底层的ZK-EVM来完成。ZK-EVM和现有的EVM是完全兼容的，现有的Ethereum Contract都可以直接移植到Layer-2上来使用。这种方案对现有的以太坊生态圈非常的友好，社区的合约开发人员在开发时，不需要学习什么额外的新知识，零门槛上手。 这种方案的难点在于如何把现有的EVM, OPcode抽象成电路。目前正在研究这个路线的有下面两个团队，Scroll和Polygon Hermez。 Scroll 通用zkEVM Polygon Hermez General Hermez 1.0: Support Ethereum Token transfer. Hermez 2.0: Recreating all the EVM opcodes (Seem they have the same goal with Scroll). 提出新的VM/编程语言 这种方案完全甩开了EVM的包袱，重新设计对ZK友好的VM以及对应的Programming Language。由于没有了包袱，所以这种方案开发起来比较快，目前进展最快的应该是StareWare团队开发的Cairo语言。 但是基于这种解决方案Zk-Rollup，不能在Layer-2上直接使用Layer-1上已经编写好的Solidity合约。需要合约开发人员重新学习一门新的语言来重新编写合约。或者会将Solidity转译成另一种语言，但是可能有些语法无法兼容。 StareWare General 专用语言: Cairo StarkNet uses the Cairo programing language both for infrastructure and for writing StarkNet contracts. 专用硬件加速Proof生成 Zksync General 专用合约编程语言: Zinc 语法很像Rust 没有写自己编译器，使用的LLVM作为编译的前端和后端。 SyncVM 专用硬件加速Proof生成(FPGA) Proof System: PLONK Con’t 并不支持所有EVM opcodes 支持部分的L1上的Solidity的合约直接使用，但是如果合约中涉及到SHA256 and Keccak256会被编译器直接修改会其他电路友好的哈希函数。 一些思考 从我个人的角度来说，提出新的VM/编程语言的方案不能算非常友好的。首先以太坊社区在Solidity生态建设方面已经做的非常的完善，有大量的已经审计过的合约可供开发人员参考，有大量的生产工具可供使用。对于智能合约来说，由于其代码部分不可修改的特性，合约安全是至关重要的。重新构造一个新的编程语言环境下的合约社区是非常困难的。第二，现在需要学习一门新语言的成本太高了，尤其是学习相比C++/Java/Python更加小众的智能合约开发语言。新的编程语言，为了不和现有的开发语言完全一致而设计的新的语法，语法糖，很容易让开发人员头大。在社区还不够成熟之前，很难吸引到足够多有能力的开发人员。 所以我更看好类似Scroll/Polygon Hermez这种Layer-2项目的发展。 其他ZK-Related Project 在阅读资料时发现的一个项目AleoHQ，看上去是一个原生支持ZKP的图灵完备的新的公链项目，由Berkeley的团队开发。Founder Howard Wu实力很强，是最早的Libsnarks的开发者之一。具体的细节我还在了解之中。 AleoHQ, Developed by Howard Wu (UC Berkeley) General Aleo is the first decentralized, open-source platform to enable both private and programmable applications. Strong privacy guarantees. 专用语言: Leo Leo converts a developer’s high-level code into zero knowledge circuits. snarkOS: Aleo runs on a decentralized operating system for private applications called snarkOS. (HAN:Seems like zkGeth?) Core Part: ZEXE (Zero Knowledge EXEcution) Related Papers Zexe: Enabling Decentralized Private Computation, [Paper link] DIZK: A Distributed Zero Knowledge Proof System, [Paper link] Reference EIP-1559: Fee market change for ETH 1.0 chain, [link] gnark zk-SNARK library (go), [Codebase] A specification for a ZK-EVM, [link] zkEVM, Zhang Ye, [link]</summary></entry><entry><title type="html">理解以太坊 Go-Ethereum 源码剖析(02): 一个Ethereum Transaction的生老病死</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn.html" rel="alternate" type="text/html" title="理解以太坊 Go-Ethereum 源码剖析(02): 一个Ethereum Transaction的生老病死" /><published>2022-01-03T10:00:00+08:00</published><updated>2022-01-03T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn.html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html&quot;&gt;Account章节&lt;/a&gt;的开头，我们提到了，Ethereum 的运行依赖于基于交易的状态机模型(Transaction-based State Machine)。本章我们就来探索一下，Ethereum中的另一个基本数据单元Transaction。在本文中，我们提到的交易指的是在Ethereum Layer-1层面上构造的交易，以太坊生态中的Layer-2中的交易不在我们的讨论中。&lt;/p&gt;

&lt;p&gt;Transaction是Ethereum执行数据操作的媒介。它主要起到下面的几个作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在Layer-1网络上的Account之间进行Native Token的转账。&lt;/li&gt;
  &lt;li&gt;创建新的Contract。&lt;/li&gt;
  &lt;li&gt;调用Contract中会修改目标Contract中持久化数据或者间接修改其他Account/Contract数据的函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里我们对Transaction功能性的细节再进行额外的补充说明。首先，Transaction只能创建Contract账户，而不能用于创建外部账户(EOA)。其次，关于Transaction的第三个作用我们使用了很长的定语进行说明，这里是为了强调，如果调用的Contract函数只进行了查询的操作，是不需要构造依赖Transaction的。总结下来，所有参与Account/Contract数据修改的操作都需要通过Transaction来进行。第三，广义上的Transaction只能由外部账户(EOA)构建。Contract是没有办法显式构造Layer-1层面的交易的。在某些合约函数的执行过程中，Contract在可以通过构造internal transaction来与其他的合约进行交互，但是这种Internal transaction与我们提到的Layer-1层面的交易有所不同，我们会在之后的章节介绍。&lt;/p&gt;

&lt;h2 id=&quot;legacytx--accesslisttx--dynamicfeetx&quot;&gt;LegacyTx &amp;amp; AccessListTX &amp;amp; DynamicFeeTx&lt;/h2&gt;

&lt;p&gt;下面我们根据源代码中的Transaction的定义来了解一下Transaction的数据结构。Transaction结构体的定义位于&lt;em&gt;core/types/transaction.go&lt;/em&gt;中。Transaction的结构体如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxData&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Consensus contents of a transaction&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Time first seen locally (spam avoidance)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// caches&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从代码定义中我们可以看到，Transaction的结构体是非常简单的结构，它只包含了五个变量分别是, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TxData&lt;/code&gt;类型的inner，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt;类型的time，以及三个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic.Value&lt;/code&gt;类型的hash，size，以及from。这里我们需要重点关注一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inner&lt;/code&gt;这个变量。目前与Transaction直接相关的数据大部分都保存在了这个变量总。&lt;/p&gt;

&lt;p&gt;目前，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TxData&lt;/code&gt;类型是一个接口，它的定义如下面的代码所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxData&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// returns the type ID&lt;/span&gt;
 &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxData&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// creates a deep copy and initializes all fields&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;chainID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;accessList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasPrice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasTipCap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasFeeCap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;nonce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;rawSignatureValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;setSignatureValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里注意，在目前版本的geth中(1.10.*)，根据&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-2718&quot;&gt;EIP-2718&lt;/a&gt;的设计，原来的TxData现在被声明成了一个interface，而不是定义了具体的结构。这样的设计好处在于，后续版本的更新中可以对Transaction类型进行更加灵活的修改。目前，在Ethereum中定义了三种类型的Transaction来实现TxData这个接口。按照时间上的定义顺序来说，这三种类型的Transaction分别是，LegacyT，AccessListTx，TxDynamicFeeTx。LegacyTx顾名思义，是原始的Ethereum的Transaction设计，目前市面上大部分早年关于Ethereum Transaction结构的文档实际上都是在描述LegacyTx的结构。而AccessListTX是基于EIP-2930(Berlin分叉)的Transaction。DynamicFeeTx是&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;EIP-1559&lt;/a&gt;(伦敦分叉)生效之后的默认的Transaction。&lt;/p&gt;

&lt;p&gt;(PS:目前Ethereum的黄皮书只更新到了Berlin分叉的内容，还没有添加London分叉的更新, 2022.3.10)&lt;/p&gt;

&lt;h3 id=&quot;legacytx&quot;&gt;LegacyTx&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LegacyTx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// nonce of sender account&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasPrice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei per gas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// gas limit&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;To&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`rlp:&quot;nil&quot;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// nil means contract creation&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei amount&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// contract invocation input data&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// signature values&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;accesslisttx&quot;&gt;AccessListTX&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessListTx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ChainID&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// destination chain ID&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// nonce of sender account&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasPrice&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei per gas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// gas limit&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;To&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`rlp:&quot;nil&quot;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// nil means contract creation&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei amount&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// contract invocation input data&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// EIP-2930 access list&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// signature values&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dynamicfeetx&quot;&gt;DynamicFeeTx&lt;/h3&gt;

&lt;p&gt;如果我们观察DynamicFeeTx就会发现，DynamicFeeTx的定义其实就是在LegacyTx/AccessListTX的定义的基础上额外的增加了GasTipCap与GasFeeCap这两个字段。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DynamicFeeTx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ChainID&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasTipCap&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// a.k.a. maxPriorityFeePerGas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasFeeCap&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// a.k.a. maxFeePerGas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;To&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`rlp:&quot;nil&quot;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// nil means contract creation&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Signature values&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`json:&quot;v&quot; gencodec:&quot;required&quot;`&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`json:&quot;r&quot; gencodec:&quot;required&quot;`&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`json:&quot;s&quot; gencodec:&quot;required&quot;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;transaction修改合约中的值的&quot;&gt;Transaction修改合约中的值的&lt;/h2&gt;

&lt;p&gt;一个Transaction的执行，可以更新一个或多个Account的State的。Miner负责将一个或多个Transaction被打包到一个block中，并按照顺序执行他们。顺序执行的结构会被finalise成一个新的World State，并最终被保存到World State Trie中。这个过程成为World State的状态转移。&lt;/p&gt;

&lt;p&gt;在Ethereum中，当Miner开始构造新的区块的时候，首先会启动&lt;em&gt;miner/worker.go&lt;/em&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mainLoop()&lt;/code&gt;函数。具体的函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mainLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 设置接受该区块中挖矿奖励的账户地址&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RUnlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transactions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Txs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 这里看到，通过NewTransactionsByPriceAndNonce获取一部分的Tx并打包&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;txset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTransactionsByPriceAndNonce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseFee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcount&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//提交打包任务&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commitTransactions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Mining新区块前，Worker首先需要决定，那些Transaction会被打包到新的Block中。这里选取Transaction其实经历了两个步骤。首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txs&lt;/code&gt;变量保存了从Transaction Pool中拿去到的合法的，以及准备好被打包的交易。这里举一个例子，来说明什么是&lt;strong&gt;准备好被打包的交易&lt;/strong&gt;，比如Alice先后发了新三个交易到网络中，对应的Nonce分别是100和101，102。假如Miner只收到了100和102号交易。那么对于此刻的Transaction Pool来说Nonce 100的交易就是&lt;strong&gt;准备好被打包的交易&lt;/strong&gt;，交易Nonce 是102需要等待Nonce 101的交易被确认之后才能提交。&lt;/p&gt;

&lt;p&gt;在Worker会从Transaction Pool中拿出若干的transaction, 赋值给&lt;em&gt;txs&lt;/em&gt;之后, 然后调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NewTransactionsByPriceAndNonce&lt;/code&gt;函数按照Gas Price和Nonce对&lt;em&gt;txs&lt;/em&gt;进行排序，并将结果赋值给&lt;em&gt;txset&lt;/em&gt;。在拿到&lt;em&gt;txset&lt;/em&gt;之后，mainLoop函数会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransactions&lt;/code&gt;函数，正式进入Mining新区块的流程。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransactions&lt;/code&gt;函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commitTransactions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TransactionsByPriceAndNonce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// 首先给Block设置最大可以使用的Gas的上限&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gasLimit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasLimit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasLimit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 函数的主体是一个For循环&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.....&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// params.TxGas表示了transaction 需要的最少的Gas的数量&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// w.current.gasPool.Gas()可以获取当前block剩余可以用的Gas的Quota，如果剩余的Gas足以开启一个新的Tx，那么循环结束&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxGas&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Not enough gas for further transactions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;have&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;want&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 提交单条Transaction 进行验证&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commitTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransactions&lt;/code&gt;函数的主体是一个for循环，每次获取结构体切片头部的txs.Peek()的transaction，并作为参数调用函数miner/worker.go的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransaction()&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransaction()&lt;/code&gt;函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commitTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 在每次commitTransaction执行前都要记录当前StateDB的Snapshot,一旦交易执行失败则基于这个Snapshot进行回滚。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// TODO StateDB如何进行快照(Snapshot)和回滚的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;snap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Snapshot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 调用执行Transaction的函数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApplyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasUsed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetVMConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Blockchain系统中的Transaction和DBMS中的Transaction一样，要么完成要么失败。所以在调用执行Transaction的函数前，首先记录了一下当前world state的Snapshot，用于交易失败时回滚操作。之后调用core/state_processor.go/ApplyTransaction()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApplyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChainContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cfg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 将Transaction 转化为Message的形式&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MakeSigner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseFee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Create a new context to be used in the EVM environment&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;blockContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewEVMBlockContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vmenv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewEVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cfg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 调用执行Contract的函数&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmenv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 ApplyTransaction()函数中首先Transaction会被转换成Message的形式。在执行每一个Transaction的时候，都会生成一个新的EVM来执行。之后调用core/state_processor.go/applyTransaction()函数来执行Message。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChainContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockHash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Apply the transaction to the current state (included in the env).&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApplyMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/state_transition.go/ApplyMessage()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApplyMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewStateTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TransitionDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/state_transition.go/TransitionDb()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransitionDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/vm/evm.go/Call()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContractRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftOverGas&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Execute the contract&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interpreter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/vm/interpreter.go/Run()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Run loops and evaluates the contract&apos;s code with the given input data and returns&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// the return byte-slice and an error if one occurred.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVMInterpreter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constantGas&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// For tracing&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// UseGas 函数：当前剩余的gas quota减去input 参数。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 剩余的gas 小于input直接返回false&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 否则当前的gas quota减去input并返回true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UseGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constantGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ErrOutOfGas&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// execute the operation&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在更细粒度的对每个opcode循环调用core/vm/jump_table.go中的execute函数。这里值得一提的是，获取Contract中每条Operate的方式，是从Contact中的code数组中按照第n个拿取。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// GetOp returns the n&apos;th element in the contract&apos;s byte array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetOp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpCode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetByte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// GetByte returns the n&apos;th byte in the contract&apos;s byte array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetByte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OPCODE的具体实现代码位于core/vm/instructor.go文件中。比如，对Contract中持久化数据修改的OPSSTORE指令的实现位于opStore()函数中。而opStore的函数的具体操作又是调用了StateDB中的SetState函数，将Go-ethereum中的几个主要的模块串联了起来。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opSstore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interpreter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVMInterpreter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ScopeContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//根据指令跟地址来修改StateDB中某一存储位置的值。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interpreter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bytes32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bytes32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//core/state/stateDB&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetOrNewStateObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就完成了，一个新区块的形成过程中，Transaction如何修改StateDB的Workflow。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;commitTransactions -» commitTransaction -» ApplyTransaction -» applyTransaction -»  ApplyMessage -» TransactionDB -» Call  -» Run -» opSstore -» StateDB -» StateObject -» Key-Value-Trie&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Transaction Execution Flow](../figs/02/tx_execu_flow.png) --&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.codenong.com/cs105936343/&quot;&gt;https://www.codenong.com/cs105936343/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yangzhe.me/2019/08/12/ethereum-evm/&quot;&gt;https://yangzhe.me/2019/08/12/ethereum-evm/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">概述 在Account章节的开头，我们提到了，Ethereum 的运行依赖于基于交易的状态机模型(Transaction-based State Machine)。本章我们就来探索一下，Ethereum中的另一个基本数据单元Transaction。在本文中，我们提到的交易指的是在Ethereum Layer-1层面上构造的交易，以太坊生态中的Layer-2中的交易不在我们的讨论中。 Transaction是Ethereum执行数据操作的媒介。它主要起到下面的几个作用: 在Layer-1网络上的Account之间进行Native Token的转账。 创建新的Contract。 调用Contract中会修改目标Contract中持久化数据或者间接修改其他Account/Contract数据的函数。 这里我们对Transaction功能性的细节再进行额外的补充说明。首先，Transaction只能创建Contract账户，而不能用于创建外部账户(EOA)。其次，关于Transaction的第三个作用我们使用了很长的定语进行说明，这里是为了强调，如果调用的Contract函数只进行了查询的操作，是不需要构造依赖Transaction的。总结下来，所有参与Account/Contract数据修改的操作都需要通过Transaction来进行。第三，广义上的Transaction只能由外部账户(EOA)构建。Contract是没有办法显式构造Layer-1层面的交易的。在某些合约函数的执行过程中，Contract在可以通过构造internal transaction来与其他的合约进行交互，但是这种Internal transaction与我们提到的Layer-1层面的交易有所不同，我们会在之后的章节介绍。 LegacyTx &amp;amp; AccessListTX &amp;amp; DynamicFeeTx 下面我们根据源代码中的Transaction的定义来了解一下Transaction的数据结构。Transaction结构体的定义位于core/types/transaction.go中。Transaction的结构体如下所示。 type Transaction struct { inner TxData // Consensus contents of a transaction time time.Time // Time first seen locally (spam avoidance) // caches hash atomic.Value size atomic.Value from atomic.Value } 从代码定义中我们可以看到，Transaction的结构体是非常简单的结构，它只包含了五个变量分别是, TxData类型的inner，Time类型的time，以及三个atomic.Value类型的hash，size，以及from。这里我们需要重点关注一下inner这个变量。目前与Transaction直接相关的数据大部分都保存在了这个变量总。 目前，TxData类型是一个接口，它的定义如下面的代码所示。 type TxData interface { txType() byte // returns the type ID copy() TxData // creates a deep copy and initializes all fields chainID() *big.Int accessList() AccessList data() []byte gas() uint64 gasPrice() *big.Int gasTipCap() *big.Int gasFeeCap() *big.Int value() *big.Int nonce() uint64 to() *common.Address rawSignatureValues() (v, r, s *big.Int) setSignatureValues(chainID, v, r, s *big.Int) } 这里注意，在目前版本的geth中(1.10.*)，根据EIP-2718的设计，原来的TxData现在被声明成了一个interface，而不是定义了具体的结构。这样的设计好处在于，后续版本的更新中可以对Transaction类型进行更加灵活的修改。目前，在Ethereum中定义了三种类型的Transaction来实现TxData这个接口。按照时间上的定义顺序来说，这三种类型的Transaction分别是，LegacyT，AccessListTx，TxDynamicFeeTx。LegacyTx顾名思义，是原始的Ethereum的Transaction设计，目前市面上大部分早年关于Ethereum Transaction结构的文档实际上都是在描述LegacyTx的结构。而AccessListTX是基于EIP-2930(Berlin分叉)的Transaction。DynamicFeeTx是EIP-1559(伦敦分叉)生效之后的默认的Transaction。 (PS:目前Ethereum的黄皮书只更新到了Berlin分叉的内容，还没有添加London分叉的更新, 2022.3.10) LegacyTx type LegacyTx struct { Nonce uint64 // nonce of sender account GasPrice *big.Int // wei per gas Gas uint64 // gas limit To *common.Address `rlp:&quot;nil&quot;` // nil means contract creation Value *big.Int // wei amount Data []byte // contract invocation input data V, R, S *big.Int // signature values } AccessListTX type AccessListTx struct { ChainID *big.Int // destination chain ID Nonce uint64 // nonce of sender account GasPrice *big.Int // wei per gas Gas uint64 // gas limit To *common.Address `rlp:&quot;nil&quot;` // nil means contract creation Value *big.Int // wei amount Data []byte // contract invocation input data AccessList AccessList // EIP-2930 access list V, R, S *big.Int // signature values } DynamicFeeTx 如果我们观察DynamicFeeTx就会发现，DynamicFeeTx的定义其实就是在LegacyTx/AccessListTX的定义的基础上额外的增加了GasTipCap与GasFeeCap这两个字段。 type DynamicFeeTx struct { ChainID *big.Int Nonce uint64 GasTipCap *big.Int // a.k.a. maxPriorityFeePerGas GasFeeCap *big.Int // a.k.a. maxFeePerGas Gas uint64 To *common.Address `rlp:&quot;nil&quot;` // nil means contract creation Value *big.Int Data []byte AccessList AccessList // Signature values V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;` R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;` S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;` } Transaction修改合约中的值的 一个Transaction的执行，可以更新一个或多个Account的State的。Miner负责将一个或多个Transaction被打包到一个block中，并按照顺序执行他们。顺序执行的结构会被finalise成一个新的World State，并最终被保存到World State Trie中。这个过程成为World State的状态转移。 在Ethereum中，当Miner开始构造新的区块的时候，首先会启动miner/worker.go的 mainLoop()函数。具体的函数如下所示。 func (w *worker) mainLoop() { .... // 设置接受该区块中挖矿奖励的账户地址 coinbase := w.coinbase w.mu.RUnlock() txs := make(map[common.Address]types.Transactions) for _, tx := range ev.Txs { acc, _ := types.Sender(w.current.signer, tx) txs[acc] = append(txs[acc], tx) } // 这里看到，通过NewTransactionsByPriceAndNonce获取一部分的Tx并打包 txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs, w.current.header.BaseFee) tcount := w.current.tcount //提交打包任务 w.commitTransactions(txset, coinbase, nil) .... } 在Mining新区块前，Worker首先需要决定，那些Transaction会被打包到新的Block中。这里选取Transaction其实经历了两个步骤。首先，txs变量保存了从Transaction Pool中拿去到的合法的，以及准备好被打包的交易。这里举一个例子，来说明什么是准备好被打包的交易，比如Alice先后发了新三个交易到网络中，对应的Nonce分别是100和101，102。假如Miner只收到了100和102号交易。那么对于此刻的Transaction Pool来说Nonce 100的交易就是准备好被打包的交易，交易Nonce 是102需要等待Nonce 101的交易被确认之后才能提交。 在Worker会从Transaction Pool中拿出若干的transaction, 赋值给txs之后, 然后调用NewTransactionsByPriceAndNonce函数按照Gas Price和Nonce对txs进行排序，并将结果赋值给txset。在拿到txset之后，mainLoop函数会调用commitTransactions函数，正式进入Mining新区块的流程。commitTransactions函数如下所示。 func (w *worker) commitTransactions(txs *types.TransactionsByPriceAndNonce, coinbase common.Address, interrupt *int32) bool { .... // 首先给Block设置最大可以使用的Gas的上限 gasLimit := w.current.header.GasLimit if w.current.gasPool == nil { w.current.gasPool = new(core.GasPool).AddGas(gasLimit) // 函数的主体是一个For循环 for{ ..... // params.TxGas表示了transaction 需要的最少的Gas的数量 // w.current.gasPool.Gas()可以获取当前block剩余可以用的Gas的Quota，如果剩余的Gas足以开启一个新的Tx，那么循环结束 if w.current.gasPool.Gas() &amp;lt; params.TxGas { log.Trace(&quot;Not enough gas for further transactions&quot;, &quot;have&quot;, w.current.gasPool, &quot;want&quot;, params.TxGas)break } .... tx := txs.Peek() if tx == nil { break } .... // 提交单条Transaction 进行验证 logs, err := w.commitTransaction(tx, coinbase) .... } } commitTransactions函数的主体是一个for循环，每次获取结构体切片头部的txs.Peek()的transaction，并作为参数调用函数miner/worker.go的commitTransaction()。commitTransaction()函数如下所示。 func (w *worker) commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, error){ // 在每次commitTransaction执行前都要记录当前StateDB的Snapshot,一旦交易执行失败则基于这个Snapshot进行回滚。 // TODO StateDB如何进行快照(Snapshot)和回滚的 snap := w.current.state.Snapshot() // 调用执行Transaction的函数 receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;amp;w.current.header.GasUsed, *w.chain.GetVMConfig()) .... } Blockchain系统中的Transaction和DBMS中的Transaction一样，要么完成要么失败。所以在调用执行Transaction的函数前，首先记录了一下当前world state的Snapshot，用于交易失败时回滚操作。之后调用core/state_processor.go/ApplyTransaction()函数。 func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, error) { // 将Transaction 转化为Message的形式 msg, err := tx.AsMessage(types.MakeSigner(config, header.Number), header.BaseFee) if err != nil { return nil, err } // Create a new context to be used in the EVM environment blockContext := NewEVMBlockContext(header, bc, author) vmenv := vm.NewEVM(blockContext, vm.TxContext{}, statedb, config, cfg) // 调用执行Contract的函数 return applyTransaction(msg, config, bc, author, gp, statedb, header.Number, header.Hash(), tx, usedGas, vmenv) } 在 ApplyTransaction()函数中首先Transaction会被转换成Message的形式。在执行每一个Transaction的时候，都会生成一个新的EVM来执行。之后调用core/state_processor.go/applyTransaction()函数来执行Message。 func applyTransaction(msg types.Message, config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, blockNumber *big.Int, blockHash common.Hash, tx *types.Transaction, usedGas *uint64, evm *vm.EVM) (*types.Receipt, error) { .... // Apply the transaction to the current state (included in the env). result, err := ApplyMessage(evm, msg, gp) .... } 之后调用core/state_transition.go/ApplyMessage()函数。 func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) (*ExecutionResult, error) { return NewStateTransition(evm, msg, gp).TransitionDb() } 之后调用core/state_transition.go/TransitionDb()函数。 func (st *StateTransition) TransitionDb() (*ExecutionResult, error) { .... ret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value) .... } 之后调用core/vm/evm.go/Call()函数。 func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) { .... // Execute the contract ret, err = evm.interpreter.Run(contract, input, false) .... } 之后调用core/vm/interpreter.go/Run()函数。 // Run loops and evaluates the contract&apos;s code with the given input data and returns // the return byte-slice and an error if one occurred. func (in *EVMInterpreter) Run(contract *Contract, input []byte, readOnly bool) (ret []byte, err error) { .... cost = operation.constantGas // For tracing // UseGas 函数：当前剩余的gas quota减去input 参数。 // 剩余的gas 小于input直接返回false // 否则当前的gas quota减去input并返回true if !contract.UseGas(operation.constantGas) { return nil, ErrOutOfGas } .... // execute the operation res, err = operation.execute(&amp;amp;pc, in, callContext) .... } 在更细粒度的对每个opcode循环调用core/vm/jump_table.go中的execute函数。这里值得一提的是，获取Contract中每条Operate的方式，是从Contact中的code数组中按照第n个拿取。 // GetOp returns the n&apos;th element in the contract&apos;s byte array func (c *Contract) GetOp(n uint64) OpCode { return OpCode(c.GetByte(n)) } // GetByte returns the n&apos;th byte in the contract&apos;s byte array func (c *Contract) GetByte(n uint64) byte { if n &amp;lt; uint64(len(c.Code)) { return c.Code[n] } return 0 } OPCODE的具体实现代码位于core/vm/instructor.go文件中。比如，对Contract中持久化数据修改的OPSSTORE指令的实现位于opStore()函数中。而opStore的函数的具体操作又是调用了StateDB中的SetState函数，将Go-ethereum中的几个主要的模块串联了起来。 func opSstore(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) { loc := scope.Stack.pop() val := scope.Stack.pop() //根据指令跟地址来修改StateDB中某一存储位置的值。 interpreter.evm.StateDB.SetState(scope.Contract.Address(),loc.Bytes32(), val.Bytes32()) return nil, nil } //core/state/stateDB func (s *StateDB) SetState(addr common.Address, key, value common.Hash) { stateObject := s.GetOrNewStateObject(addr) if stateObject != nil { stateObject.SetState(s.db, key, value) } } 这样就完成了，一个新区块的形成过程中，Transaction如何修改StateDB的Workflow。 commitTransactions -» commitTransaction -» ApplyTransaction -» applyTransaction -» ApplyMessage -» TransactionDB -» Call -» Run -» opSstore -» StateDB -» StateObject -» Key-Value-Trie Reference https://www.codenong.com/cs105936343/ https://yangzhe.me/2019/08/12/ethereum-evm/</summary></entry><entry><title type="html">理解以太坊 Go-Ethereum 源码剖析(01): 账户与合约(Account and Contract)</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html" rel="alternate" type="text/html" title="理解以太坊 Go-Ethereum 源码剖析(01): 账户与合约(Account and Contract)" /><published>2022-01-02T11:00:00+08:00</published><updated>2022-01-02T11:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;我们常常听到这样一个说法，”Ethereum 和 Bitcoin 最大的不同之一是二者使用链上数据模型不同。其中，Bitcoin 是基于 UTXO 模型的 Blockchain/Ledger 系统，Ethereum是基于 Account/State 模型的系统”。那么，这个另辟蹊径的 Account/State 模型究竟不同在何处呢？在本文，我们就来探索一下以太坊中的基本数据单元(Metadata)之一的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Account&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;简单的来说，Ethereum 的运行是一种&lt;em&gt;基于交易的状态机模型&lt;/em&gt;(Transaction-based State Machine)。整个系统由若干的账户组成 (Account)，类似于银行账户。状态(State)反应了某一账户(Account)在&lt;em&gt;某一时刻&lt;/em&gt;下的值(value)。在以太坊中，State 对应的基本数据结构，称为 StateObject。当 StateObject 的值发生了变化时，我们称为&lt;em&gt;状态转移&lt;/em&gt;。在 Ethereum 的运行模型中，StateObject 所包含的数据会因为 Transaction 的执行引发数据更新/删除/创建，引发状态转移，我们说：StateObject 的状态从当前的 State 转移到另一个 State。&lt;/p&gt;

&lt;p&gt;在 Ethereum 中，承载 StateObject 的具体实例就是 Ethereum 中的 Account。通常，我们提到的 State 具体指的就是 Account 在某个时刻的包含的数据的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Account –&amp;gt; StateObject&lt;/li&gt;
  &lt;li&gt;State   –&amp;gt; The value/data of the Account&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说, Account (账户)是参与链上交易(Transaction)的基本角色，是Ethereum状态机模型中的基本单位，承担了链上交易的发起者以及接收者的角色。目前，在以太坊中，有两种类型的Account，分别是外部账户(EOA)以及合约账户(Contract)。&lt;/p&gt;

&lt;h3 id=&quot;eoa&quot;&gt;EOA&lt;/h3&gt;

&lt;p&gt;外部账户(EOA)是由用户直接控制的账户，负责签名并发起交易(Transaction)。用户通过Account 的私钥来保证对账户数据的控制权。&lt;/p&gt;

&lt;p&gt;合约账户(Contract)，简称为合约，是由外部账户通过Transaction创建的。合约账户，保存了&lt;strong&gt;不可篡改的图灵完备的代码段&lt;/strong&gt;，以及一些&lt;strong&gt;持久化的数据变量&lt;/strong&gt;。这些代码使用专用的图灵完备的编程语言编写(Solidity)，并通常提供一些对外部访问 API 接口函数。这些 API 接口函数可以通过构造 Transaction，或者通过本地/第三方提供的节点 RPC 服务来调用。这种模式构成了目前的 DApp 生态的基础。&lt;/p&gt;

&lt;p&gt;通常，合约中的函数用于计算以及查询或修改合约中的持久化数据。我们经常看到这样的描述”&lt;strong&gt;一旦被记录到区块链上数据不可被修改&lt;/strong&gt;，或者&lt;strong&gt;不可篡改的智能合约&lt;/strong&gt;“。现在我们知道这种笼统的描述其实是不准确。针对一个链上的智能合约，不可修改/篡改的部分是合约中的代码段，或说合约中的&lt;em&gt;函数逻辑&lt;/em&gt;/&lt;em&gt;代码逻辑是&lt;/em&gt;不可以被修改/篡改的。而合约中的&lt;strong&gt;持久化的数据变量&lt;/strong&gt;是可以通过调用代码段中的函数进行数据操作的(CURD)。具体的操作方式取决于合约函数中的代码逻辑。&lt;/p&gt;

&lt;p&gt;根据&lt;em&gt;合约中函数是否会修改合约中持久化的变量&lt;/em&gt;，合约中的函数可以分为两种: &lt;em&gt;只读函数&lt;/em&gt;和&lt;em&gt;写函数&lt;/em&gt;。如果用户&lt;strong&gt;只&lt;/strong&gt;希望查询某些合约中的持久化数据，而不对数据进行修改的话，那么用户只需要调用相关的只读函数。调用只读函数不需要通过构造一个 Transaction 来查询数据。用户可以通过直接调用本地节点或者第三方节点提供的 RPC 接口来直接调用对应的合约中的&lt;em&gt;只读函数&lt;/em&gt;。如果用户需要对合约中的数据进行更新，那么他就要构造一个Transaction 来调用合约中相对应的&lt;em&gt;写函数&lt;/em&gt;。注意，每个 Transaction 每次调用一个合约中的一个&lt;em&gt;写函数&lt;/em&gt;。因为，如果想在链上实现复杂的逻辑，需要将&lt;em&gt;写函数&lt;/em&gt;接口化，在其中调用更多的逻辑。&lt;/p&gt;

&lt;p&gt;对于如何编写合约，以及Ethereum如何解析Transaction并调用对应的合约中API的，我们会在后面的&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2021/07/25/ethereum_txn.html&quot;&gt;文章&lt;/a&gt;中详细的进行解析。&lt;/p&gt;

&lt;h2 id=&quot;stateobject-account-contract&quot;&gt;StateObject, Account, Contract&lt;/h2&gt;

&lt;p&gt;在实际代码中，这两种 Account 都是由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;这一数据结构定义的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;的相关代码位于&lt;em&gt;core/state/state_object.go&lt;/em&gt;文件中，隶属于&lt;em&gt;package state&lt;/em&gt;。我们摘录了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;的结构代码，如下所示。通过下面的代码，我们可以观察到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;是由小写字母开头。根据 go 语言的特性，我们可以知道这个结构主要用于 package 内部数据操作，并不对外暴露。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;addrHash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// hash of ethereum address of the account&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateAccount&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dbErr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Write caches.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;trie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trie&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// storage trie, which becomes non-nil on first access&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Code&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// contract bytecode, which gets set when code is loaded&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// 这里的Storage 是一个 map[common.Hash]common.Hash&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;originStorage&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Storage cache of original entries to dedup rewrites, reset for every transaction&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pendingStorage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Storage entries that need to be flushed to disk, at the end of an entire block&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dirtyStorage&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Storage entries that have been modified in the current transaction execution&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fakeStorage&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Fake storage which constructed by caller for debugging purpose.&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Cache flags.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// When an object is marked suicided it will be delete from the trie&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// during the &quot;update&quot; phase of the state transition.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dirtyCode&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// true if the code was updated&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;suicided&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;deleted&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;address&quot;&gt;Address&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;这一结构体中，开头的两个成员变量为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address&lt;/code&gt;以及 address 的哈希值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addrHash&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address&lt;/code&gt;是common.Address类型，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addrHash&lt;/code&gt;是common.Hash类型，它们分别对应了一个&lt;strong&gt;20字节&lt;/strong&gt;长的byte类型数组和一个32字节长的byte类型数组。关于这两种数据类型的定义如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Lengths of hashes and addresses in bytes.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// HashLength is the expected length of the hash&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// AddressLength is the expected length of the address&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AddressLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Address represents the 20 byte address of an Ethereum account.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddressLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Hash represents the 32 byte Keccak256 hash of arbitrary data.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Ethereum中，每个Account都拥有独一无二的地址。Address作为每个Account的身份信息，类似于现实生活中的身份证，它与用户信息时刻绑定而且不能被修改。&lt;/p&gt;

&lt;h3 id=&quot;data-and-stateaccount&quot;&gt;data and StateAccount&lt;/h3&gt;

&lt;p&gt;继续向下探索，我们会遇到成员变量data，它是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;types.StateAccount&lt;/code&gt;类型的变量。在上面的分析中我们提到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;这种类型只对Package State这个内部使用。所以相应的，Package State也为外部Package API提供了与Account相关的数据类型”State Account”。在上面的代码中我们就可以看到，”State Account”对应了State Object中”data Account”成员变量。State Account的具体数据结构的被定义在”core/types/state_account.go”文件中(&lt;del&gt;在之前的版本中Account的代码位于core/account.go&lt;/del&gt;)，其定义如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Account is the Ethereum consensus representation of accounts.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// These objects are stored in the main account trie.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateAccount&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Balance&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Root&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// merkle root of the storage trie&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;CodeHash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的包含四个变量为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nonce 表示该账户发送的交易序号，随着账户发送的交易数量的增加而单调增加。每次发送一个交易，Nonce 的值就会加1。&lt;/li&gt;
  &lt;li&gt;Balance 表示该账户的余额。这里的余额指的是链上的 Native Token Ether (以太)。&lt;/li&gt;
  &lt;li&gt;Root 表示当前账户的下 Storage 层的 Merkle Patricia Trie的 Root。这里的存储层是为了管理合约中持久化变量准备的。对于 EOA账户这个部分为空值。&lt;/li&gt;
  &lt;li&gt;CodeHash是该账户的Contract代码的哈希值。同样的，这个变量是用于保存合约账户中的代码的 hash ，EOA账户这个部分为空值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;db&quot;&gt;db&lt;/h3&gt;

&lt;p&gt;上述的几个成员变量基本覆盖了 Account 主生命周期相关的全部成员变量。那么我们继续向下看，会遇到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;db&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dbErr&lt;/code&gt;这两个成员变量。db这个变量保存了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateDB&lt;/code&gt; 类型的指针。这是为了方便调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateDB&lt;/code&gt; 相关的API对Account所对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt; 进行操作。StateDB本质上是用于管理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;信息的而抽象出来的内存数据库。所有的Account 数据的更新，检索都会使用 StateDB 提供的API。关于 StateDB 的具体实现，功能，以及如何与更底层物理存储层(leveldb)进行结合的，我们会在之后的文章中进行详细描述。&lt;/p&gt;

&lt;h3 id=&quot;cache&quot;&gt;Cache&lt;/h3&gt;

&lt;p&gt;对于剩下的成员变量，它们的主要用于内存Cache。trie用于保存和管理合约账户中的持久化变量存储的数据，code用于缓存合约中的代码段到内存中，它是一个byte数组。剩下的四个Storage 字段主要在执行 Transaction 的时候缓存合约修改的持久化数据，比如dirtyStorage 就用于缓存在 Block 被 Finalize 之前，Transaction所修改的合约中的持久化存储数据。对于外部账户，由于没有代码字段，所以对应 stateObject 对象中的code 字段，以及四个 Storage 类型的字段对应的变量的值都为空(originStorage, pendingStorage, dirtyStorage, fakeStorage)。&lt;/p&gt;

&lt;p&gt;从调用关系上看，这四个缓存变量的调用关系是originStorage –&amp;gt; dirtyStorage–&amp;gt; pendingStorage。关于Contract的Storage层的详细信息，我们会在后面部分进行详细的描述。&lt;/p&gt;

&lt;h2 id=&quot;深入account&quot;&gt;深入Account&lt;/h2&gt;

&lt;h3 id=&quot;private-key--public-kay--address&quot;&gt;Private Key &amp;amp; Public Kay &amp;amp; Address&lt;/h3&gt;

&lt;h4 id=&quot;账户安全的问题&quot;&gt;账户安全的问题&lt;/h4&gt;

&lt;p&gt;我们经常会在各种科技网站/自媒体上看到这样的说法，”用户在区块链系统中保存的Cryptocurrency/Token，除了用户自己，不存在第三方可以不经过用户的允许转走你的财富”。这个说法基本是正确的。目前，用户账户里的由链级别定义的 Crypto/Token，或者称为原生货币(Native Token)，比如Ether，Bitcoin，BNB(Only in BSC)，是没办法被第三方在不被批准的情况下转走的。这是因为链级别上的所有数据的修改都要执行由用户私钥(Private Key)签名的Transaction。因此，只要用户保管好自己账户的私钥(Private Key)，保证其没有被第三方知晓，就没有人可以转走你链上的财富。&lt;/p&gt;

&lt;p&gt;我们说上述说法是基本正确，而不是完全正确。原因有两个。首先，用户的链上数据安全是基于当前Ethereum使用的密码学工具足够保证：不存在第三方可以在&lt;strong&gt;有限的时间&lt;/strong&gt;内在&lt;strong&gt;不知道用户私钥的前提&lt;/strong&gt;下获取到用户的私钥信息来伪造签名交易。当然这个安全保证前提是当今Ethereum使用的密码学工具的强度足够大，没有计算机可以在有限的时间内 hack 出用户的私钥信息。在量子计算机出现之前，目前 Ethereum 和其他 Blockchain 使用的密码学工具的强度都是足够安全的。这也是为什么很多新的区块链项目在研究抗量子计算机密码体系的原因。第二点原因是，当今很多的所谓的 Crypto/Token 并不是链级别的代币，而是保存在合约中持久化变量中的数据，比如 ERC-20 Token 和NFT对应的 ERC-721 的Token。由于这部分的Token都是基于合约代码生成和维护的，所以这部分 Token 的安全依赖于合约本身的安全。如果合约本身的代码是有问题的，存在后门或者漏洞，比如存在给第三方任意提取其他账户下 Token 的漏洞。那么即使用户的私钥信息没有泄漏，合约中的Token仍然可以被第三方获取到。由于合约的代码段在链上是不可修改的，因此合约代码的安全性是极其重要的。目前有很多研究人员，技术团队在进行合约审计方面的工作，来保证上传的合约代码是安全的。随着Layer-2技术和一些跨链技术的发展，用户持有的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token&lt;/code&gt;，在很多情况下不是我们上面提到的安全的 Naive Token，而是 ERC-20 甚至只是其他合约中的简单数值记录。这种类型的资产的安全性是远低于低于layer-1上的 Native Toke n的。用户在持有这类资产的时候需要小心。这里我们推荐阅读 Jay Freeman 所分析的关于一个热门Layer-2系统Optimism上的由于非Naive Token造成的&lt;a href=&quot;https://www.saurik.com/optimism.html&quot;&gt;任意提取漏洞&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面我们简单讲述，一个账户的私钥和地址是如何产生的。- 这部分的示例代码位于: &lt;a href=&quot;example/signature&quot;&gt;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/signature/main.go&lt;/a&gt;]中。&lt;/p&gt;

&lt;h4 id=&quot;account-generation&quot;&gt;Account Generation&lt;/h4&gt;

&lt;p&gt;首先，EOA账户的创建分为本地创建和链上注册两个部分。当我们使用诸如 Metamask 等钱包工具创建账户的时候，在区块链上并没有同步注册账户信息。链上账户的创建和管理都是通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateDB&lt;/code&gt;模块来操作的，因此我们将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;中账户管理部分的代码整合到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StateDB&lt;/code&gt;模块章节来一起讲述。而合约账户，或者说智能合约的创建是需要通过 EOA 账户构造特定的交易生成的。关于这部分的细节我们也放在之后的章节中进行解析。&lt;/p&gt;

&lt;p&gt;下面我们简单分析一下，如何在本地创建一个 EOA 账户的。&lt;/p&gt;

&lt;p&gt;总的来说，创建新账户的依赖的入口函数&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NewAccount&lt;/code&gt;位于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accounts/keystore/keystore.go&lt;/code&gt;文件中。函数有一个string类型的passphrase参数。注意，这个参数仅用于加密本地保存私钥的Keystore文件，与生成账户的私钥，地址的生成都无关。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先我们通过随机得到一个长度64位account的私钥。这个私钥就是平时需要用户激活钱包时需要的记录，一旦这个私钥暴露了，钱包也将不再安全。
    &lt;ul&gt;
      &lt;li&gt;64个16进制位，256bit，32字节
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var AlicePrivateKey = &quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在得到私钥后，我们使用用私钥来计算公钥和account的地址。基于私钥，我们使用ECDSA算法，选择spec256k1曲线进行计算。通过将私钥带入到所选择的椭圆曲线中，计算出点的坐标即是公钥。以太坊和比特币使用了同样的spec256k1曲线，在实际的代码中，我们也可以看到在crypto中，go-Ethereum直接调用了比特币的代码。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ecdsaSK, err := crypto.ToECDSA(privateKey)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;对私钥进行椭圆加密之后，我们可以得到64bytes的数，它是由两个32bytes的数构成，这两个数代表了spec256k1曲线上某个点的XY值。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ecdsaPK := ecdsaSK.PublicKey&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;以太坊的地址，是基于上述公钥(ecdsaSK.PublicKey)的 [Keccak-256算法] 之后的后20个字节，并且用0x开头。
    &lt;ul&gt;
      &lt;li&gt;Keccak-256是SHA-3（Secure Hash Algorithm 3）标准下的一种哈希算法
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr := crypto.PubkeyToAddress(ecdsaSK.PublicKey)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;signature--verification&quot;&gt;Signature &amp;amp; Verification&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Hash（m,R）&lt;em&gt;X +R = S&lt;/em&gt; P&lt;/li&gt;
  &lt;li&gt;P是椭圆曲线函数的基点(base point) 可以理解为一个P是一个在曲线C上的一个order 为n的加法循环群的生成元. n为质数。&lt;/li&gt;
  &lt;li&gt;R = r * P (r 是个随机数，并不告知verifier)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以太坊签名校验的核心思想是:首先基于上面得到的ECDSA下的私钥ecdsaSK对数据msg进行签名(sign)得到msgSig.
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sig, err := crypto.Sign(msg[:], ecdsaSK)&lt;/code&gt;
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msgSig := decodeHex(hex.EncodeToString(sig))&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;然后基于msg和msgSig可以反推出来签名的公钥（用于生成账户地址的公钥ecdsaPK）。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recoveredPub, err := crypto.Ecrecover(msg[:],msgSig)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过反推出来的公钥得到发送者的地址，并与当前txn的发送者在ECDSA下的pk进行对比。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crypto.VerifySignature(testPk, msg[:], msgSig[:len(msgSig)-1])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;这套体系的安全性保证在于，即使知道了公钥ecdsaPk/ecdsaSK.PublicKey也难以推测出 ecdsaSK以及生成他的privateKey。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ecdsa--spec256k1曲线&quot;&gt;ECDSA &amp;amp; spec256k1曲线&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Elliptic curve point multiplication
    &lt;ul&gt;
      &lt;li&gt;Point addition P + Q = R&lt;/li&gt;
      &lt;li&gt;Point doubling P + P = 2P&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;y^2 = x^3 +7&lt;/li&gt;
  &lt;li&gt;Based Point P是在椭圆曲线上的群的生成元&lt;/li&gt;
  &lt;li&gt;x次computation on Based Point得到X点，x为私钥，X为公钥。x由Account Private Key得出。&lt;/li&gt;
  &lt;li&gt;在ECC中的+号不是四则运算中的加法，而是定义椭圆曲线C上的新的二元运算(Point Multiplication)。他代表了过两点P和Q的直线与椭圆曲线C的交点R‘关于X轴对称的点R。因为C是关于X轴对称的所以关于X对称的点也都在椭圆曲线上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;深入contract&quot;&gt;深入Contract&lt;/h2&gt;

&lt;h3 id=&quot;contract-storage-合约存储&quot;&gt;Contract Storage (合约存储)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#general Background&quot;&gt;在文章的开头&lt;/a&gt;我们提到，在外部账户对应的，stateObject结构体的实例中，有四个Storage类型的变量是空值。那显然的，这四个变量是为Contract类型的账户准备的。&lt;/p&gt;

&lt;p&gt;在”state_object.go”文件的开头部分(41行左右)，我们可以找到Storage类型的定义。具体如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到，&lt;em&gt;Storage&lt;/em&gt;是一个key和value都是common.Hash类型的map结构。common.Hash类型，则对应了一个长度为32bytes的byte类型数组。这个类型在go-ethereum中被大量使用，通常用于表示32字节长度的数据，比如Keccak256函数的哈希值。在之后的旅程中，我们也会经常看到它的身影，它的定义在common.type.go文件中。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// HashLength is the expected length of the hash&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Hash represents the 32 byte Keccak256 hash of arbitrary data.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从功能层面讲，外部账户(EOA)与合约账户(Contract)不同的点在于，外部账户并没有维护自己的代码(codeHash)以及额外的Storage层。相比与外部账户，合约账户额外保存了一个存储层(Storage)用于存储合约代码中持久化的变量的数据。在上文中我们提到，StateObject中的声明的四个Storage类型的变量，就是作为Contract Storage层的内存缓存。&lt;/p&gt;

&lt;p&gt;在Ethereum中，每个合约都维护了自己的&lt;em&gt;独立&lt;/em&gt;的Storage空间，我们称为Storage层。Storage层的基本组成单元称为槽 (Slot)，若干个Slot按照&lt;em&gt;Stack&lt;/em&gt;的方式集合在一起构造成了Storage 层。每个Slot的大小是256bits，也就是最多保存32 bytes的数据。作为基本的存储单元，Slot管理的方式与内存或者HDD中的基本单元的管理方式类似，通过地址索引的方式被上层函数访问。Slot的地址索引的长度同样是32 bytes(256 bits)，寻址空间从 0x0000000000000000000000000000000000000000000000000000000000000000 到 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。因此，每个Contract的Storage层最多可以保存$2^{256} - 1$个Slot。也就说在理论状态下，一个Contract可以最多保存$(2^{256} - 1)$ bytes的数据，这是个相当大的数字。Contract同样使用MPT来管理Storage 层的Slot。值得注意的是，Storage层的数据并不会被打包进入Block中。唯一与Chain内数据相关的是，Storage Trie的根数据被保存在StateAccount结构体中的Root变量中(它是一个32bytes长的byte数组)。当某个Contract的Storage层的数据发生变化时，根据骨牌效应，向上传导到World State Root的值发生变化，从而影响到Chain数据。目前，Storage层的数据读取和修改是在执行相关Transaction的时候，通过EVM调用两个专用的指令&lt;em&gt;OpSload&lt;/em&gt;和&lt;em&gt;OpSstore&lt;/em&gt;触发。&lt;/p&gt;

&lt;p&gt;我们知道目前Ethereum中的大部分合约都通过Solidity语言编写。Solidity做为强类型的图灵完备的语言，支持多种类型的变量。总的来说，根据变量的长度性质，Ethereum中的持久化的变量可以分为定长的变量和不定长度的变量两种。定长的变量有常见的单变量类型，比如 uint256。不定长的变量包括了由若干单变量组成的Array，以及KV形式的Map类型。&lt;/p&gt;

&lt;p&gt;根据上面的介绍，我们了解到对Contract Storage层的访问是通过Slot的地址来进行的。请读者先思考下面的几个问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;如何给定一个包含若干持久化存储变量的Solidity的合约，EVM是怎么给其包含的变量分配存储空间的呢？&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;怎么保证Contract Storage的一致性读写的？(怎么保证每个合约的验证者和执行者都能获取到相同的数据？)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将通过下面的一些实例来展示，在Ethereum中，Contract是如何保存持久化变量的，以及保证所有的参与者都能一致性读写的Contract中的数据的。&lt;/p&gt;

&lt;h3 id=&quot;contract-storage-example-one&quot;&gt;Contract Storage Example One&lt;/h3&gt;

&lt;p&gt;我们使用一个简单的合约来展示Contract Storage层的逻辑，合约代码如下所示。在本例中，我们使用了一个叫做”Storage”合约，其中定义了了三个持久化uint256类型的变量分别是number, number1, 以及number2。同时，我们定义一个stores函数给这个三个变量进行赋值。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们使用&lt;a href=&quot;https://remix.ethereum.org/&quot;&gt;Remix&lt;/a&gt;来在本地部署这个合约，并构造一个调用stores(1)函数的Transaction，同时使用Remix debugger来Storage层的变化。在Transaction生效之后，合约中三个变量的值将被分别赋给1，2，3。此时，我们观察Storage层会发现，存储层增加了三个Storage Object。这三个Storage Object对应了三个Slot。所以在本例中，合约增加了三个Slots来存储数据。我们可以发现每个Storage Object由三个字段组成，分别是一个32 bytes的key字段和32 bytess的value字段，以及外层的一个32 bytes 的字段。这三个字段在下面的例子中都表现为64位的16进制数(32 Bytes)。&lt;/p&gt;

&lt;p&gt;下面我们来逐个解释一下这个三个值的实际意义。首先我们观察内部的Key-Value对，可以发现下面三个Storage Object中key的值其实是从0开始的递增整数，分别是0，1，2。它代表了当前Slot的地址索引值，或者说该Slot在Storage层对应的绝对位置(Position)。比如，key的值为0时，它代表整个Storage层中的第1个Slot，或者说在1号位置的Slot，当key等于1时代表Storage层中的第2个Slot，以此类推。每个Storage Object中的value变量，存储了合约中三个变量的值(1,2,3)。而Storage Object外层的值由等于Storage Object的key的值的sha3的哈希值。比如，下面例子中的第一个Storage Object的外层索引值”0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563” 是通过keccak256(0)计算出的值，代表了第一个Slot position的Sha3的哈希，而”0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6” 对应了是keccak(1)的值。我们在&lt;a href=&quot;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/account/main.go&quot;&gt;示例代码&lt;/a&gt;中展示了如何计算的过程。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;读者可能以及发现了，在这个Storage Object中，外层的索引值其实与Key值的关系是一一对应的，或者说这两个键值本质上都是关于Slot位置的唯一索引。这里我们简单讲述一下这两个值在使用上的区别。Key值代表了Slot在Storage层的Position，这个值用于会作为stateObject.go/getState()以及setState()函数的参数，用于定位Slot。如果我们继续深入上面的两个函数，我们就会发现，当内存中不存在该Slot的缓存时，geth就会尝试从更底层的数据库中来获取这个Slot的值。而Storage在更底层的数据，是由Secure Trie来维护的，Secure Trie中的Key值都是需要Hash的。所以在Secure Trie层我们查询/修改需要的键值就是外层的hash值。具体的关于Secure Trie的描述可以参考&lt;a href=&quot;10_tire_statedb.md&quot;&gt;Trie&lt;/a&gt;这一章节。总结下来，在上层函数(stateObject)调用中使用的键值是Slot的Position，在下层的函数(Trie)调用中使用的键值是Slot的Position的哈希值。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecureTrie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TryGet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// Secure Trie中查询的例子&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 这里的key还是Slot的Position&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 但是在更下层的Call更下层的函数的时候使用了这个Key的hash值作为查询使用的键值。&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryGet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hashKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;account-storage-example-two&quot;&gt;Account Storage Example Two&lt;/h3&gt;

&lt;p&gt;下面我们来看另外的一个例子。在这个例子中，我们调整一下合约中变量的声明顺序，从(number，number1，number2)调整为(number 2, number 1, number)。合约代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样我们还是构造Transaction来调用合约中的stores函数。此时我们可以在Storage 层观察到不一样的结果。我们发现number2这个变量的值被存储在了第一个Slot中（Key:”0x0000000000000000000000000000000000000000000000000000000000000000”），而number这个变量的值北存储在了第三个Slot中 (Key:”0x0000000000000000000000000000000000000000000000000000000000000002”)。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子可以说明，在Ethereum中，变量对应的存储层的Slot，是&lt;em&gt;按照其在在合约中的声明顺序&lt;/em&gt;，从第一个Slot（position：0）开始分配的。&lt;/p&gt;

&lt;h3 id=&quot;account-storage-example-three&quot;&gt;Account Storage Example Three&lt;/h3&gt;

&lt;p&gt;我们再考虑另一种情况：声明的三个变量，但只对其中的两个变量进行赋值。具体的来说，我们按照number，number1，和number2的顺序声明三个uint256变量。但是，在函数stores中只对number1和number2进行赋值操作。合约代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基于上述合约，我们构造transaction 并调用stores函数，输入参数1，将number1和number2的值修改为2，和3。在transaction执行完成后，我们可以观察到Storage层Slot的结果如下所示。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以观察到，stores函数调用的结果只对在合约的Storage层中位置在1和2位置的两个Slot进行了赋值。值得注意的是，在本例中，对于Slot的赋值是从1号位置Slot的开始，而不是0号Slot。这说明对于固定长度的变量，其值的所占用的Slot的位置在Contract初始化开始的时候就已经分配的。即使变量只是被声明还没有真正的赋值，保存其值所需要的Slot也已经被EVM分配完毕。而不是在第一次进行变量赋值的时候，进行再对变量所需要的的Slot进行分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../assets/figs/01/remix.png&quot; alt=&quot;Remix Debugger&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;account-storage-example-four&quot;&gt;Account Storage Example Four&lt;/h3&gt;

&lt;p&gt;在Solidity中，有一类特殊的变量类型&lt;strong&gt;Address&lt;/strong&gt;，通常用于表示账户的地址信息。例如在ERC-20合约中，用户拥有的token信息是被存储在一个(address-&amp;gt;uint)的map结构中。在这个map中，key就是Address类型的，它表示了用户实际的address。目前Address的大小为160bits(20bytes)，并不足以填满一整个Slot。因此当Address作为value单独存储在的时候，它并不会排他的独占用一个Slot。我们使用下面的例子来说明。&lt;/p&gt;

&lt;p&gt;在下面的示例中，我们声明了三个变量，分别是number(uint256)，addr(address)，以及isTrue(bool)。我们知道，在以太坊中Address类型变量的长度是20 bytes，所以一个Address类型的变量是没办法填满整个的Slot(32 bytes)的。同时，布尔类型在以太坊中只需要一个bit(0 or 1)的空间。因此，我们构造transaction并调用函数storeaddr来给这三个变量赋值，函数的input参数是一个uint256的值，一个address类型的值，分别为{1, “0xb6186d3a3D32232BB21E87A33a4E176853a49d12”}。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;


    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isTrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// number1 = num + 1;
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// number2 = num + 2;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;storeaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;isTure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Transaction的运行后Storage层的结果如下面的Json所示。我们可以观察到，在本例中Contract声明了三个变量，但是在Storage层只调用了两个Slot。第一个Slot用于保存了uint256的值，而在第二个Slot中(Key:0x0000000000000000000000000000000000000000000000000000000000000001)保存了addr和isTrue的值。这里需要注意，虽然这种将两个小于32 bytes长的变量合并到一个Slot的做法节省了物理空间，但是也同样带来读写放大的问题。因为在Geth中，读操作最小的读的单位都是按照32bytes来进行的。在本例中，即使我们只需要读取isTrue或者addr这两个变量的值，在具体的函数调用中，我们仍然需要将对应的Slot先读取到内存中。同样的，如果我们想修改这两个变量的值，同样需要对整个的Slot进行重写。这无疑增加了额外的开销。所以在Ethereum使用32 bytes的变量，在某些情况下消耗的Gas反而比更小长度类型的变量要小(例如 unit8)。这也是为什么Ethereum官方也建议使用长度为32 bytes变量的原因。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x000000000000000000000001b6186d3a3d32232bb21e87a33a4e176853a49d12&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;account-storage-example-five&quot;&gt;Account Storage Example Five&lt;/h3&gt;

&lt;p&gt;对于变长数组和Map结构的变量存储分配则相对的复杂。虽然Map本身就是key-value的结构，但是在Storage 层并不直接使用map中key的值或者key的值的sha3 哈希值来作为Storage分配的Slot的索引值。目前，Geth首先会使用map中元素的key的值和当前Map变量声明位置对应的slot的值进行拼接，再使用拼接后的值的keccak256哈希值作为Slot的位置索引(Position)。我们在下面的例子中展示了Geth是如何处理map这种变长的数据结构的。在下面的合约中，我们声明了一个定长的uint256类型的对象number，和一个[string=&amp;gt;uint256]类型的Map对象。&lt;/p&gt;

&lt;!-- Todo: 变长数据结构的存储情况。 --&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hsy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lei&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们构造Transaction来调用了set_balance函数，在Transaction执行之后的Storage层的结果如下面的Json所示。我们发现，对于定长的变量number占据了第一个Slot的空间(Position:0x0000000000000000000000000000000000000000000000000000000000000000)。但是对于Map类型变量balances，它包含的两个数据并没有按照变量定义的物理顺序来定义Slot。此外，我们观察到存储这两个值的Slot的key，也并不是这两个字在mapping中key的直接hash。正如我们在上段中提到的那样，Geth会使用Map中元素的的key值与当前Map被分配的slot的位置进行拼接，之后对拼接之后对值进行使用keccak256函数求得哈希值，来最终得到map中元素最终的存储位置。比如在本例中，按照变量定义的顺序，balances这个Map变量会被分配到第二个Slot，对应的Slot Position是1。因此，balances中的kv对分配到的slot的位置就是，keccak(key, 1)，这里是一个特殊的拼接操作。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xa601d8e9cd2719ca27765dc16042655548d1ac3600a53ffc06b4a06a12b7c65c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0xbaded3bf529b04b554de2e4ee0f5702613335896b4041c50a5555b2d5e279f91&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x53ac6681d92653b13055d2e265b672e2db2b2a19407afb633928597f144edbb0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x56a8a0d158d59e2fd9317c46c65b1e902ed92f726ecfe82c06c33c015e8e6682&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了验证上面的说法，我们使用go语言编写了一段代码，来调用相关的库来验证一下上面的结论。对于 balances[“hsy”]，它被分配的Slot的位置可以由下面的代码求得。读者可以阅读/使用&lt;a href=&quot;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/account/main.go&quot;&gt;示例代码&lt;/a&gt;进行尝试。这里的k1是一个整形实数，代表了Slot的在storage层的位置(Position)。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;k1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solsha3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SoliditySHA3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hsy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solsha3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Test the Solidity Map storage Key1:         0x%x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c/&quot;&gt;https://www.freecodecamp.org/news/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">概述 我们常常听到这样一个说法，”Ethereum 和 Bitcoin 最大的不同之一是二者使用链上数据模型不同。其中，Bitcoin 是基于 UTXO 模型的 Blockchain/Ledger 系统，Ethereum是基于 Account/State 模型的系统”。那么，这个另辟蹊径的 Account/State 模型究竟不同在何处呢？在本文，我们就来探索一下以太坊中的基本数据单元(Metadata)之一的Account。 简单的来说，Ethereum 的运行是一种基于交易的状态机模型(Transaction-based State Machine)。整个系统由若干的账户组成 (Account)，类似于银行账户。状态(State)反应了某一账户(Account)在某一时刻下的值(value)。在以太坊中，State 对应的基本数据结构，称为 StateObject。当 StateObject 的值发生了变化时，我们称为状态转移。在 Ethereum 的运行模型中，StateObject 所包含的数据会因为 Transaction 的执行引发数据更新/删除/创建，引发状态转移，我们说：StateObject 的状态从当前的 State 转移到另一个 State。 在 Ethereum 中，承载 StateObject 的具体实例就是 Ethereum 中的 Account。通常，我们提到的 State 具体指的就是 Account 在某个时刻的包含的数据的值。 Account –&amp;gt; StateObject State –&amp;gt; The value/data of the Account 总的来说, Account (账户)是参与链上交易(Transaction)的基本角色，是Ethereum状态机模型中的基本单位，承担了链上交易的发起者以及接收者的角色。目前，在以太坊中，有两种类型的Account，分别是外部账户(EOA)以及合约账户(Contract)。 EOA 外部账户(EOA)是由用户直接控制的账户，负责签名并发起交易(Transaction)。用户通过Account 的私钥来保证对账户数据的控制权。 合约账户(Contract)，简称为合约，是由外部账户通过Transaction创建的。合约账户，保存了不可篡改的图灵完备的代码段，以及一些持久化的数据变量。这些代码使用专用的图灵完备的编程语言编写(Solidity)，并通常提供一些对外部访问 API 接口函数。这些 API 接口函数可以通过构造 Transaction，或者通过本地/第三方提供的节点 RPC 服务来调用。这种模式构成了目前的 DApp 生态的基础。 通常，合约中的函数用于计算以及查询或修改合约中的持久化数据。我们经常看到这样的描述”一旦被记录到区块链上数据不可被修改，或者不可篡改的智能合约“。现在我们知道这种笼统的描述其实是不准确。针对一个链上的智能合约，不可修改/篡改的部分是合约中的代码段，或说合约中的函数逻辑/代码逻辑是不可以被修改/篡改的。而合约中的持久化的数据变量是可以通过调用代码段中的函数进行数据操作的(CURD)。具体的操作方式取决于合约函数中的代码逻辑。 根据合约中函数是否会修改合约中持久化的变量，合约中的函数可以分为两种: 只读函数和写函数。如果用户只希望查询某些合约中的持久化数据，而不对数据进行修改的话，那么用户只需要调用相关的只读函数。调用只读函数不需要通过构造一个 Transaction 来查询数据。用户可以通过直接调用本地节点或者第三方节点提供的 RPC 接口来直接调用对应的合约中的只读函数。如果用户需要对合约中的数据进行更新，那么他就要构造一个Transaction 来调用合约中相对应的写函数。注意，每个 Transaction 每次调用一个合约中的一个写函数。因为，如果想在链上实现复杂的逻辑，需要将写函数接口化，在其中调用更多的逻辑。 对于如何编写合约，以及Ethereum如何解析Transaction并调用对应的合约中API的，我们会在后面的文章中详细的进行解析。 StateObject, Account, Contract 在实际代码中，这两种 Account 都是由stateObject这一数据结构定义的。stateObject的相关代码位于core/state/state_object.go文件中，隶属于package state。我们摘录了stateObject的结构代码，如下所示。通过下面的代码，我们可以观察到，stateObject是由小写字母开头。根据 go 语言的特性，我们可以知道这个结构主要用于 package 内部数据操作，并不对外暴露。 type stateObject struct { address common.Address addrHash common.Hash // hash of ethereum address of the account data types.StateAccount db *StateDB dbErr error // Write caches. trie Trie // storage trie, which becomes non-nil on first access code Code // contract bytecode, which gets set when code is loaded // 这里的Storage 是一个 map[common.Hash]common.Hash originStorage Storage // Storage cache of original entries to dedup rewrites, reset for every transaction pendingStorage Storage // Storage entries that need to be flushed to disk, at the end of an entire block dirtyStorage Storage // Storage entries that have been modified in the current transaction execution fakeStorage Storage // Fake storage which constructed by caller for debugging purpose. // Cache flags. // When an object is marked suicided it will be delete from the trie // during the &quot;update&quot; phase of the state transition. dirtyCode bool // true if the code was updated suicided bool deleted bool } Address 在stateObject这一结构体中，开头的两个成员变量为address以及 address 的哈希值addrHash。address是common.Address类型，addrHash是common.Hash类型，它们分别对应了一个20字节长的byte类型数组和一个32字节长的byte类型数组。关于这两种数据类型的定义如下所示。 // Lengths of hashes and addresses in bytes. const ( // HashLength is the expected length of the hash HashLength = 32 // AddressLength is the expected length of the address AddressLength = 20 ) // Address represents the 20 byte address of an Ethereum account. type Address [AddressLength]byte // Hash represents the 32 byte Keccak256 hash of arbitrary data. type Hash [HashLength]byte 在Ethereum中，每个Account都拥有独一无二的地址。Address作为每个Account的身份信息，类似于现实生活中的身份证，它与用户信息时刻绑定而且不能被修改。 data and StateAccount 继续向下探索，我们会遇到成员变量data，它是一个types.StateAccount类型的变量。在上面的分析中我们提到，stateObject这种类型只对Package State这个内部使用。所以相应的，Package State也为外部Package API提供了与Account相关的数据类型”State Account”。在上面的代码中我们就可以看到，”State Account”对应了State Object中”data Account”成员变量。State Account的具体数据结构的被定义在”core/types/state_account.go”文件中(在之前的版本中Account的代码位于core/account.go)，其定义如下所示。 // Account is the Ethereum consensus representation of accounts. // These objects are stored in the main account trie. type StateAccount struct { Nonce uint64 Balance *big.Int Root common.Hash // merkle root of the storage trie CodeHash []byte } 其中的包含四个变量为: Nonce 表示该账户发送的交易序号，随着账户发送的交易数量的增加而单调增加。每次发送一个交易，Nonce 的值就会加1。 Balance 表示该账户的余额。这里的余额指的是链上的 Native Token Ether (以太)。 Root 表示当前账户的下 Storage 层的 Merkle Patricia Trie的 Root。这里的存储层是为了管理合约中持久化变量准备的。对于 EOA账户这个部分为空值。 CodeHash是该账户的Contract代码的哈希值。同样的，这个变量是用于保存合约账户中的代码的 hash ，EOA账户这个部分为空值。 db 上述的几个成员变量基本覆盖了 Account 主生命周期相关的全部成员变量。那么我们继续向下看，会遇到db和dbErr这两个成员变量。db这个变量保存了一个 StateDB 类型的指针。这是为了方便调用 StateDB 相关的API对Account所对应的 stateObject 进行操作。StateDB本质上是用于管理stateObject信息的而抽象出来的内存数据库。所有的Account 数据的更新，检索都会使用 StateDB 提供的API。关于 StateDB 的具体实现，功能，以及如何与更底层物理存储层(leveldb)进行结合的，我们会在之后的文章中进行详细描述。 Cache 对于剩下的成员变量，它们的主要用于内存Cache。trie用于保存和管理合约账户中的持久化变量存储的数据，code用于缓存合约中的代码段到内存中，它是一个byte数组。剩下的四个Storage 字段主要在执行 Transaction 的时候缓存合约修改的持久化数据，比如dirtyStorage 就用于缓存在 Block 被 Finalize 之前，Transaction所修改的合约中的持久化存储数据。对于外部账户，由于没有代码字段，所以对应 stateObject 对象中的code 字段，以及四个 Storage 类型的字段对应的变量的值都为空(originStorage, pendingStorage, dirtyStorage, fakeStorage)。 从调用关系上看，这四个缓存变量的调用关系是originStorage –&amp;gt; dirtyStorage–&amp;gt; pendingStorage。关于Contract的Storage层的详细信息，我们会在后面部分进行详细的描述。 深入Account Private Key &amp;amp; Public Kay &amp;amp; Address 账户安全的问题 我们经常会在各种科技网站/自媒体上看到这样的说法，”用户在区块链系统中保存的Cryptocurrency/Token，除了用户自己，不存在第三方可以不经过用户的允许转走你的财富”。这个说法基本是正确的。目前，用户账户里的由链级别定义的 Crypto/Token，或者称为原生货币(Native Token)，比如Ether，Bitcoin，BNB(Only in BSC)，是没办法被第三方在不被批准的情况下转走的。这是因为链级别上的所有数据的修改都要执行由用户私钥(Private Key)签名的Transaction。因此，只要用户保管好自己账户的私钥(Private Key)，保证其没有被第三方知晓，就没有人可以转走你链上的财富。 我们说上述说法是基本正确，而不是完全正确。原因有两个。首先，用户的链上数据安全是基于当前Ethereum使用的密码学工具足够保证：不存在第三方可以在有限的时间内在不知道用户私钥的前提下获取到用户的私钥信息来伪造签名交易。当然这个安全保证前提是当今Ethereum使用的密码学工具的强度足够大，没有计算机可以在有限的时间内 hack 出用户的私钥信息。在量子计算机出现之前，目前 Ethereum 和其他 Blockchain 使用的密码学工具的强度都是足够安全的。这也是为什么很多新的区块链项目在研究抗量子计算机密码体系的原因。第二点原因是，当今很多的所谓的 Crypto/Token 并不是链级别的代币，而是保存在合约中持久化变量中的数据，比如 ERC-20 Token 和NFT对应的 ERC-721 的Token。由于这部分的Token都是基于合约代码生成和维护的，所以这部分 Token 的安全依赖于合约本身的安全。如果合约本身的代码是有问题的，存在后门或者漏洞，比如存在给第三方任意提取其他账户下 Token 的漏洞。那么即使用户的私钥信息没有泄漏，合约中的Token仍然可以被第三方获取到。由于合约的代码段在链上是不可修改的，因此合约代码的安全性是极其重要的。目前有很多研究人员，技术团队在进行合约审计方面的工作，来保证上传的合约代码是安全的。随着Layer-2技术和一些跨链技术的发展，用户持有的Token，在很多情况下不是我们上面提到的安全的 Naive Token，而是 ERC-20 甚至只是其他合约中的简单数值记录。这种类型的资产的安全性是远低于低于layer-1上的 Native Toke n的。用户在持有这类资产的时候需要小心。这里我们推荐阅读 Jay Freeman 所分析的关于一个热门Layer-2系统Optimism上的由于非Naive Token造成的任意提取漏洞。 下面我们简单讲述，一个账户的私钥和地址是如何产生的。- 这部分的示例代码位于: https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/signature/main.go]中。 Account Generation 首先，EOA账户的创建分为本地创建和链上注册两个部分。当我们使用诸如 Metamask 等钱包工具创建账户的时候，在区块链上并没有同步注册账户信息。链上账户的创建和管理都是通过StateDB模块来操作的，因此我们将geth中账户管理部分的代码整合到StateDB模块章节来一起讲述。而合约账户，或者说智能合约的创建是需要通过 EOA 账户构造特定的交易生成的。关于这部分的细节我们也放在之后的章节中进行解析。 下面我们简单分析一下，如何在本地创建一个 EOA 账户的。 总的来说，创建新账户的依赖的入口函数NewAccount位于 accounts/keystore/keystore.go文件中。函数有一个string类型的passphrase参数。注意，这个参数仅用于加密本地保存私钥的Keystore文件，与生成账户的私钥，地址的生成都无关。 首先我们通过随机得到一个长度64位account的私钥。这个私钥就是平时需要用户激活钱包时需要的记录，一旦这个私钥暴露了，钱包也将不再安全。 64个16进制位，256bit，32字节 var AlicePrivateKey = &quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot; 在得到私钥后，我们使用用私钥来计算公钥和account的地址。基于私钥，我们使用ECDSA算法，选择spec256k1曲线进行计算。通过将私钥带入到所选择的椭圆曲线中，计算出点的坐标即是公钥。以太坊和比特币使用了同样的spec256k1曲线，在实际的代码中，我们也可以看到在crypto中，go-Ethereum直接调用了比特币的代码。 ecdsaSK, err := crypto.ToECDSA(privateKey) 对私钥进行椭圆加密之后，我们可以得到64bytes的数，它是由两个32bytes的数构成，这两个数代表了spec256k1曲线上某个点的XY值。 ecdsaPK := ecdsaSK.PublicKey 以太坊的地址，是基于上述公钥(ecdsaSK.PublicKey)的 [Keccak-256算法] 之后的后20个字节，并且用0x开头。 Keccak-256是SHA-3（Secure Hash Algorithm 3）标准下的一种哈希算法 addr := crypto.PubkeyToAddress(ecdsaSK.PublicKey) Signature &amp;amp; Verification Hash（m,R）X +R = S P P是椭圆曲线函数的基点(base point) 可以理解为一个P是一个在曲线C上的一个order 为n的加法循环群的生成元. n为质数。 R = r * P (r 是个随机数，并不告知verifier) 以太坊签名校验的核心思想是:首先基于上面得到的ECDSA下的私钥ecdsaSK对数据msg进行签名(sign)得到msgSig. sig, err := crypto.Sign(msg[:], ecdsaSK) msgSig := decodeHex(hex.EncodeToString(sig)) 然后基于msg和msgSig可以反推出来签名的公钥（用于生成账户地址的公钥ecdsaPK）。 recoveredPub, err := crypto.Ecrecover(msg[:],msgSig) 通过反推出来的公钥得到发送者的地址，并与当前txn的发送者在ECDSA下的pk进行对比。 crypto.VerifySignature(testPk, msg[:], msgSig[:len(msgSig)-1]) 这套体系的安全性保证在于，即使知道了公钥ecdsaPk/ecdsaSK.PublicKey也难以推测出 ecdsaSK以及生成他的privateKey。 ECDSA &amp;amp; spec256k1曲线 Elliptic curve point multiplication Point addition P + Q = R Point doubling P + P = 2P y^2 = x^3 +7 Based Point P是在椭圆曲线上的群的生成元 x次computation on Based Point得到X点，x为私钥，X为公钥。x由Account Private Key得出。 在ECC中的+号不是四则运算中的加法，而是定义椭圆曲线C上的新的二元运算(Point Multiplication)。他代表了过两点P和Q的直线与椭圆曲线C的交点R‘关于X轴对称的点R。因为C是关于X轴对称的所以关于X对称的点也都在椭圆曲线上。 深入Contract Contract Storage (合约存储) 在文章的开头我们提到，在外部账户对应的，stateObject结构体的实例中，有四个Storage类型的变量是空值。那显然的，这四个变量是为Contract类型的账户准备的。 在”state_object.go”文件的开头部分(41行左右)，我们可以找到Storage类型的定义。具体如下所示。 type Storage map[common.Hash]common.Hash 我们可以看到，Storage是一个key和value都是common.Hash类型的map结构。common.Hash类型，则对应了一个长度为32bytes的byte类型数组。这个类型在go-ethereum中被大量使用，通常用于表示32字节长度的数据，比如Keccak256函数的哈希值。在之后的旅程中，我们也会经常看到它的身影，它的定义在common.type.go文件中。 // HashLength is the expected length of the hash HashLength = 32 // Hash represents the 32 byte Keccak256 hash of arbitrary data. type Hash [HashLength]byte 从功能层面讲，外部账户(EOA)与合约账户(Contract)不同的点在于，外部账户并没有维护自己的代码(codeHash)以及额外的Storage层。相比与外部账户，合约账户额外保存了一个存储层(Storage)用于存储合约代码中持久化的变量的数据。在上文中我们提到，StateObject中的声明的四个Storage类型的变量，就是作为Contract Storage层的内存缓存。 在Ethereum中，每个合约都维护了自己的独立的Storage空间，我们称为Storage层。Storage层的基本组成单元称为槽 (Slot)，若干个Slot按照Stack的方式集合在一起构造成了Storage 层。每个Slot的大小是256bits，也就是最多保存32 bytes的数据。作为基本的存储单元，Slot管理的方式与内存或者HDD中的基本单元的管理方式类似，通过地址索引的方式被上层函数访问。Slot的地址索引的长度同样是32 bytes(256 bits)，寻址空间从 0x0000000000000000000000000000000000000000000000000000000000000000 到 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。因此，每个Contract的Storage层最多可以保存$2^{256} - 1$个Slot。也就说在理论状态下，一个Contract可以最多保存$(2^{256} - 1)$ bytes的数据，这是个相当大的数字。Contract同样使用MPT来管理Storage 层的Slot。值得注意的是，Storage层的数据并不会被打包进入Block中。唯一与Chain内数据相关的是，Storage Trie的根数据被保存在StateAccount结构体中的Root变量中(它是一个32bytes长的byte数组)。当某个Contract的Storage层的数据发生变化时，根据骨牌效应，向上传导到World State Root的值发生变化，从而影响到Chain数据。目前，Storage层的数据读取和修改是在执行相关Transaction的时候，通过EVM调用两个专用的指令OpSload和OpSstore触发。 我们知道目前Ethereum中的大部分合约都通过Solidity语言编写。Solidity做为强类型的图灵完备的语言，支持多种类型的变量。总的来说，根据变量的长度性质，Ethereum中的持久化的变量可以分为定长的变量和不定长度的变量两种。定长的变量有常见的单变量类型，比如 uint256。不定长的变量包括了由若干单变量组成的Array，以及KV形式的Map类型。 根据上面的介绍，我们了解到对Contract Storage层的访问是通过Slot的地址来进行的。请读者先思考下面的几个问题: 如何给定一个包含若干持久化存储变量的Solidity的合约，EVM是怎么给其包含的变量分配存储空间的呢？ 怎么保证Contract Storage的一致性读写的？(怎么保证每个合约的验证者和执行者都能获取到相同的数据？) 我们将通过下面的一些实例来展示，在Ethereum中，Contract是如何保存持久化变量的，以及保证所有的参与者都能一致性读写的Contract中的数据的。 Contract Storage Example One 我们使用一个简单的合约来展示Contract Storage层的逻辑，合约代码如下所示。在本例中，我们使用了一个叫做”Storage”合约，其中定义了了三个持久化uint256类型的变量分别是number, number1, 以及number2。同时，我们定义一个stores函数给这个三个变量进行赋值。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; uint256 number1; uint256 number2; function stores(uint256 num) public { number = num; number1 = num + 1; number2 = num + 2; } function get_number() public view returns (uint256){ return number; } function get_number1() public view returns (uint256){ return number1; } function get_number2() public view returns (uint256){ return number2; } } 我们使用Remix来在本地部署这个合约，并构造一个调用stores(1)函数的Transaction，同时使用Remix debugger来Storage层的变化。在Transaction生效之后，合约中三个变量的值将被分别赋给1，2，3。此时，我们观察Storage层会发现，存储层增加了三个Storage Object。这三个Storage Object对应了三个Slot。所以在本例中，合约增加了三个Slots来存储数据。我们可以发现每个Storage Object由三个字段组成，分别是一个32 bytes的key字段和32 bytess的value字段，以及外层的一个32 bytes 的字段。这三个字段在下面的例子中都表现为64位的16进制数(32 Bytes)。 下面我们来逐个解释一下这个三个值的实际意义。首先我们观察内部的Key-Value对，可以发现下面三个Storage Object中key的值其实是从0开始的递增整数，分别是0，1，2。它代表了当前Slot的地址索引值，或者说该Slot在Storage层对应的绝对位置(Position)。比如，key的值为0时，它代表整个Storage层中的第1个Slot，或者说在1号位置的Slot，当key等于1时代表Storage层中的第2个Slot，以此类推。每个Storage Object中的value变量，存储了合约中三个变量的值(1,2,3)。而Storage Object外层的值由等于Storage Object的key的值的sha3的哈希值。比如，下面例子中的第一个Storage Object的外层索引值”0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563” 是通过keccak256(0)计算出的值，代表了第一个Slot position的Sha3的哈希，而”0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6” 对应了是keccak(1)的值。我们在示例代码中展示了如何计算的过程。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; }, &quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot; } } 读者可能以及发现了，在这个Storage Object中，外层的索引值其实与Key值的关系是一一对应的，或者说这两个键值本质上都是关于Slot位置的唯一索引。这里我们简单讲述一下这两个值在使用上的区别。Key值代表了Slot在Storage层的Position，这个值用于会作为stateObject.go/getState()以及setState()函数的参数，用于定位Slot。如果我们继续深入上面的两个函数，我们就会发现，当内存中不存在该Slot的缓存时，geth就会尝试从更底层的数据库中来获取这个Slot的值。而Storage在更底层的数据，是由Secure Trie来维护的，Secure Trie中的Key值都是需要Hash的。所以在Secure Trie层我们查询/修改需要的键值就是外层的hash值。具体的关于Secure Trie的描述可以参考Trie这一章节。总结下来，在上层函数(stateObject)调用中使用的键值是Slot的Position，在下层的函数(Trie)调用中使用的键值是Slot的Position的哈希值。 func (t *SecureTrie) TryGet(key []byte) ([]byte, error) { // Secure Trie中查询的例子 // 这里的key还是Slot的Position // 但是在更下层的Call更下层的函数的时候使用了这个Key的hash值作为查询使用的键值。 return t.trie.TryGet(t.hashKey(key)) } Account Storage Example Two 下面我们来看另外的一个例子。在这个例子中，我们调整一下合约中变量的声明顺序，从(number，number1，number2)调整为(number 2, number 1, number)。合约代码如下所示。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number2; uint256 number; uint256 number; function stores(uint256 num) public { number = num; number1 = num + 1; number2 = num + 2; } function get_number() public view returns (uint256){ return number; } function get_number1() public view returns (uint256){ return number1; } function get_number2() public view returns (uint256){ return number2; } } 同样我们还是构造Transaction来调用合约中的stores函数。此时我们可以在Storage 层观察到不一样的结果。我们发现number2这个变量的值被存储在了第一个Slot中（Key:”0x0000000000000000000000000000000000000000000000000000000000000000”），而number这个变量的值北存储在了第三个Slot中 (Key:”0x0000000000000000000000000000000000000000000000000000000000000002”)。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot; }, &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; }, &quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; } } 这个例子可以说明，在Ethereum中，变量对应的存储层的Slot，是按照其在在合约中的声明顺序，从第一个Slot（position：0）开始分配的。 Account Storage Example Three 我们再考虑另一种情况：声明的三个变量，但只对其中的两个变量进行赋值。具体的来说，我们按照number，number1，和number2的顺序声明三个uint256变量。但是，在函数stores中只对number1和number2进行赋值操作。合约代码如下所示。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; uint256 number1; uint256 number2; function stores(uint256 num) public { number1 = num + 1; number2 = num + 2; } function get_number() public view returns (uint256){ return number; } function get_number1() public view returns (uint256){ return number1; } function get_number2() public view returns (uint256){ return number2; } } 基于上述合约，我们构造transaction 并调用stores函数，输入参数1，将number1和number2的值修改为2，和3。在transaction执行完成后，我们可以观察到Storage层Slot的结果如下所示。 { &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; }, &quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot; } } 我们可以观察到，stores函数调用的结果只对在合约的Storage层中位置在1和2位置的两个Slot进行了赋值。值得注意的是，在本例中，对于Slot的赋值是从1号位置Slot的开始，而不是0号Slot。这说明对于固定长度的变量，其值的所占用的Slot的位置在Contract初始化开始的时候就已经分配的。即使变量只是被声明还没有真正的赋值，保存其值所需要的Slot也已经被EVM分配完毕。而不是在第一次进行变量赋值的时候，进行再对变量所需要的的Slot进行分配。 Account Storage Example Four 在Solidity中，有一类特殊的变量类型Address，通常用于表示账户的地址信息。例如在ERC-20合约中，用户拥有的token信息是被存储在一个(address-&amp;gt;uint)的map结构中。在这个map中，key就是Address类型的，它表示了用户实际的address。目前Address的大小为160bits(20bytes)，并不足以填满一整个Slot。因此当Address作为value单独存储在的时候，它并不会排他的独占用一个Slot。我们使用下面的例子来说明。 在下面的示例中，我们声明了三个变量，分别是number(uint256)，addr(address)，以及isTrue(bool)。我们知道，在以太坊中Address类型变量的长度是20 bytes，所以一个Address类型的变量是没办法填满整个的Slot(32 bytes)的。同时，布尔类型在以太坊中只需要一个bit(0 or 1)的空间。因此，我们构造transaction并调用函数storeaddr来给这三个变量赋值，函数的input参数是一个uint256的值，一个address类型的值，分别为{1, “0xb6186d3a3D32232BB21E87A33a4E176853a49d12”}。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; address addr; bool isTrue; function stores(uint256 num) public { // number1 = num + 1; // number2 = num + 2; } function storeaddr(uint256 num, address a) public { number = num; addr = a; isTure = true; } function get_number() public view returns (uint256){ return number; } } Transaction的运行后Storage层的结果如下面的Json所示。我们可以观察到，在本例中Contract声明了三个变量，但是在Storage层只调用了两个Slot。第一个Slot用于保存了uint256的值，而在第二个Slot中(Key:0x0000000000000000000000000000000000000000000000000000000000000001)保存了addr和isTrue的值。这里需要注意，虽然这种将两个小于32 bytes长的变量合并到一个Slot的做法节省了物理空间，但是也同样带来读写放大的问题。因为在Geth中，读操作最小的读的单位都是按照32bytes来进行的。在本例中，即使我们只需要读取isTrue或者addr这两个变量的值，在具体的函数调用中，我们仍然需要将对应的Slot先读取到内存中。同样的，如果我们想修改这两个变量的值，同样需要对整个的Slot进行重写。这无疑增加了额外的开销。所以在Ethereum使用32 bytes的变量，在某些情况下消耗的Gas反而比更小长度类型的变量要小(例如 unit8)。这也是为什么Ethereum官方也建议使用长度为32 bytes变量的原因。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x000000000000000000000001b6186d3a3d32232bb21e87a33a4e176853a49d12&quot; } } Account Storage Example Five 对于变长数组和Map结构的变量存储分配则相对的复杂。虽然Map本身就是key-value的结构，但是在Storage 层并不直接使用map中key的值或者key的值的sha3 哈希值来作为Storage分配的Slot的索引值。目前，Geth首先会使用map中元素的key的值和当前Map变量声明位置对应的slot的值进行拼接，再使用拼接后的值的keccak256哈希值作为Slot的位置索引(Position)。我们在下面的例子中展示了Geth是如何处理map这种变长的数据结构的。在下面的合约中，我们声明了一个定长的uint256类型的对象number，和一个[string=&amp;gt;uint256]类型的Map对象。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; mapping(string =&amp;gt; uint256) balances; function set_balance(uint256 num) public { number = num; balances[&quot;hsy&quot;] = num; balances[&quot;lei&quot;] = num + 1; } function get_number() public view returns (uint256){ return number; } } 我们构造Transaction来调用了set_balance函数，在Transaction执行之后的Storage层的结果如下面的Json所示。我们发现，对于定长的变量number占据了第一个Slot的空间(Position:0x0000000000000000000000000000000000000000000000000000000000000000)。但是对于Map类型变量balances，它包含的两个数据并没有按照变量定义的物理顺序来定义Slot。此外，我们观察到存储这两个值的Slot的key，也并不是这两个字在mapping中key的直接hash。正如我们在上段中提到的那样，Geth会使用Map中元素的的key值与当前Map被分配的slot的位置进行拼接，之后对拼接之后对值进行使用keccak256函数求得哈希值，来最终得到map中元素最终的存储位置。比如在本例中，按照变量定义的顺序，balances这个Map变量会被分配到第二个Slot，对应的Slot Position是1。因此，balances中的kv对分配到的slot的位置就是，keccak(key, 1)，这里是一个特殊的拼接操作。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0xa601d8e9cd2719ca27765dc16042655548d1ac3600a53ffc06b4a06a12b7c65c&quot;: { &quot;key&quot;: &quot;0xbaded3bf529b04b554de2e4ee0f5702613335896b4041c50a5555b2d5e279f91&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0x53ac6681d92653b13055d2e265b672e2db2b2a19407afb633928597f144edbb0&quot;: { &quot;key&quot;: &quot;0x56a8a0d158d59e2fd9317c46c65b1e902ed92f726ecfe82c06c33c015e8e6682&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; } } 为了验证上面的说法，我们使用go语言编写了一段代码，来调用相关的库来验证一下上面的结论。对于 balances[“hsy”]，它被分配的Slot的位置可以由下面的代码求得。读者可以阅读/使用示例代码进行尝试。这里的k1是一个整形实数，代表了Slot的在storage层的位置(Position)。 k1 := solsha3.SoliditySHA3([]byte(&quot;hsy&quot;), solsha3.Uint256(big.NewInt(int64(1)))) fmt.Printf(&quot;Test the Solidity Map storage Key1: 0x%x\n&quot;, k1) Reference https://www.freecodecamp.org/news/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c/</summary></entry><entry><title type="html">理解以太坊 Go-Ethereum 源码剖析(00): 万物的起点: Geth Start !</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/02/geth.html" rel="alternate" type="text/html" title="理解以太坊 Go-Ethereum 源码剖析(00): 万物的起点: Geth Start !" /><published>2022-01-02T10:00:00+08:00</published><updated>2022-01-02T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/02/geth</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/02/geth.html">&lt;h2 id=&quot;什么是geth&quot;&gt;什么是Geth？&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;是以太坊基金会基于 Go 语言开发以太坊的官方客户端，它实现了 Ethereum 协议(黄皮书)中所有需要的实现的功能模块。我们可以通过启动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt; 来运行一个 Ethereum 的节点。在以太坊 Merge 之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt; 作为节点的执行层继续在以太坊生态中发挥重要的作用。 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go-ethereum&lt;/code&gt;是包含了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt; 客户端代码和以及编译 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt; 所需要的其他代码在内的一个完整的代码库。在本系列中我们会通过深入 go-ethereum 代码库，从High-level 的 API 接口出发，沿着 Ethereum 主 Workflow，逐一的理解 Ethereum 具体实现的细节。&lt;/p&gt;

&lt;p&gt;为了方便区分，在接下来的文章中，我们用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;来表示 Geth 客户端程序，用go-ethereum(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Geth&lt;/code&gt;)来表示 go-ethereum 的代码库。&lt;/p&gt;

&lt;p&gt;总结的来说:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go-ethereum&lt;/code&gt;代码库中的代码，我们可以编译出&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;客户端程序。&lt;/li&gt;
  &lt;li&gt;通过运行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;客户端程序我们可以启动一个 Ethereum 的节点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;go-ethereum-codebase-结构&quot;&gt;Go-ethereum Codebase 结构&lt;/h3&gt;

&lt;p&gt;为了更好的从整体工作流的角度来理解Ethereum，根据主要的业务功能，我们将go-ethereum划分成如下几个模块来分析。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Geth Client 模块&lt;/li&gt;
  &lt;li&gt;Core 数据结构模块&lt;/li&gt;
  &lt;li&gt;State Management 模块
    &lt;ul&gt;
      &lt;li&gt;StateDB 模块&lt;/li&gt;
      &lt;li&gt;Trie 数据结构模块&lt;/li&gt;
      &lt;li&gt;State Optimization (Pruning)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mining 模块&lt;/li&gt;
  &lt;li&gt;EVM 模块&lt;/li&gt;
  &lt;li&gt;P2P 网络模块
    &lt;ul&gt;
      &lt;li&gt;节点数据同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Storage 模块
    &lt;ul&gt;
      &lt;li&gt;抽象数据库层&lt;/li&gt;
      &lt;li&gt;LevelDB 调用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前，go-ethereum项目的主要目录结构如下所示:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd/ 以太坊基金会官方开发的一些 Command-line 程序。该目录下的每个子目录都是一个单独运行的 CLI 程序。
   |── clef/ 以太坊官方推出的账户管理程序.
   |── geth/ 以太坊官方的节点客户端。
core/   以太坊核心模块，包括核心数据结构，statedb，EVM等算法实现
   |── rawdb/ db 相关函数的高层封装(在ethdb和更底层的leveldb之上的封装)
      ├──accessors_state.go 从 Disk Level 读取/写入与 State 相关的数据结构。
   |── state/
      ├──statedb.go  StateDB 是管理以太坊 World State 最核心的代码，用于管理链上所有的 State 相关操作。
   |── txpool        Transaction Pool 相关的代码。
      |── txpool.go  Transaction Pool 的具体实现。
consensus/
   |── types/  以太坊中最核心的数据结构
      |── block.go   以太坊 Block 的的数据结构定义与相关函数实现
      |── bloom9.go  以太坊使用的一个 Bloom Filter 的实现
      |── transaction.go 以太坊 Transaction 的数据结构定义与相关函数实现。
      |── transaction_signing.go 用于对 Transaction 进行签名的函数的实现。
      |── receipt.go  以太坊交易收据的实现，用于记录以太坊 Transaction 执行的结果
   |── vm/            以太坊的核心中核心 EVM 相关的一些的数据结构的定义。
      |── instructions.go   EVM 指令的具体的定义，核心中的核心中的核心文件。
      |── logger.go   用于追踪 EVM 执行交易过程的日志接口的定义。具体的实现在eth/tracers/logger/logger.go 文件中。
   |── genesis.go     创世区块相关的函数。每个 geth 客户端/以太坊节点初始化的都需要调用这个模块。
   |── consensus.go   共识相关的参数设定，包括 Block Reward 的数量。
console/
   |── bridge.go
   |── console.go  Geth Web3 控制台的入口
ethdb/    Ethereum 本地存储的相关实现, 包括 leveldb 的调用
   |── leveldb/   Go-Ethereum使用的与 Bitcoin Core version一样的Leveldb作为本机存储用的数据库
internal/ 一些内部使用的工具库的集合，比如在测试用例中模拟 cmd 的工具。在构建 Ethereum 生态相关的工具时值得注意这个文件夹。
miner/
   |── miner.go   矿工模块的实现。
   |── worker.go  Block generation 的实现，包括打包 transaction，计算合法的Block
p2p/     Ethereum 的P2P模块
   |── params    Ethereum 的一些参数的配置，例如: bootnode的enode地址
   |── bootnodes.go  bootnode 的 enode 地址 like: aws 的一些节点，azure 的一些节点，Ethereum Foundation 的节点和 Rinkeby 测试网的节点
rlp/     RLP的 Encode与 Decode的相关
rpc/     Ethereum RPC客户端的实现
les/     Ethereum light client 轻节点的实现
trie/    Ethereum 中至关重要的数据结构 Merkle Patrica Trie(MPT) 的实现
   |── committer.go    Trie向Memory Database 提交数据的工具函数。
   |── database.go     Memory Database，是Trie数据和 Disk Database 提交的中间层。同时还实现了Trie剪枝的功能。**非常重要**
   |── node.go         MPT中的节点的定义以及相关的函数。
   |── secure_trie.go  基于 Trie 的封装的结构。与 trie 中的函数功能相同，不过secure_trie中的 key 是经过hashKey()函数hash过的，无法通过路径获得原始的 key值 
   |── stack_trie.go   Block中使用的Transaction/Receipt Trie的实现
   |── trie.go         MPT具体功能的函数实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;geth-start&quot;&gt;Geth Start&lt;/h2&gt;

&lt;h3 id=&quot;前奏-geth-console&quot;&gt;前奏: Geth Console&lt;/h3&gt;

&lt;p&gt;当我们想要部署一个 Ethereum 节点的时候，最直接的方式就是下载官方提供的发行版的geth 客户端程序。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;是一个基于CLI的应用，启动&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;和调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;的功能性API需要使用对应的指令来操作。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;提供了一个相对友好的 console 来方便用户调用各种指令。当我第一次阅读 Ethereum 的文档的时候，我曾经有过这样的疑问，为什么&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;是由Go语言编写的，但是在官方文档中的 Web3 的API却是基于 Javascript 的调用？&lt;/p&gt;

&lt;p&gt;这是因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;内置了一个 Javascript 的解释器:å&lt;em&gt;Goja&lt;/em&gt; (interpreter)，来作为用户与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth&lt;/code&gt;交互的 CLI Console。我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console/console.go&lt;/code&gt;中找到它的定义。&lt;/p&gt;

&lt;!-- /*Goja is an implementation of ECMAScript 5.1 in Pure GO*/ --&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Console is a JavaScript interpreted runtime environment. It is a fully fledged&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// JavaScript console attached to a running node via an external or in-process RPC&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// client.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// RPC client to execute Ethereum requests through&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;jsre&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jsre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSRE&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// JavaScript runtime environment running the interpreter&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// Input prompt prefix string&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;prompter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserPrompter&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Input prompter to allow interactive user feedback&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;histPath&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// Absolute path to the console scrollback history&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// Scroll history maintained by the console&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;// Output writer to serialize any display strings to&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;

&lt;p&gt;了解Ethereum，我们首先要了解Ethereum客户端Geth是怎么运行的。&lt;/p&gt;

&lt;p&gt;&lt;!-- `geth console 2` --&gt;&lt;/p&gt;

&lt;p&gt;Geth的启动点位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd/geth/main.go/main()&lt;/code&gt;函数处，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数非常的简短，其主要功能就是启动一个解析 command line命令的工具: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gopkg.in/urfave/cli.v1&lt;/code&gt;。继续深入，我们会发现在 cli app 初始化的时候会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.Action = geth&lt;/code&gt;，来调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数。而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数就是用于启动 Ethereum 节点的顶层函数，其代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;invalid command: %q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;makeFullNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;startNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数中，有三个比较重要的函数调用，分别是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeFullNode()&lt;/code&gt;，以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startNode()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare()&lt;/code&gt; 函数的实现就在当前的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.go&lt;/code&gt;文件中。它主要用于设置一些节点初始化需要的配置。比如，我们在节点启动时看到的这句话: &lt;em&gt;Starting Geth on Ethereum mainnet…&lt;/em&gt; 就是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;函数中被打印出来的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeFullNode()&lt;/code&gt;函数的实现位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd/geth/config.go&lt;/code&gt;文件中。它会将Geth启动时的命令的上下文加载到配置中，并生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt;这两个实例。其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;是一个Node 类型的实例，它是通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeFullNode()&lt;/code&gt;函数调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeConfigNode()&lt;/code&gt;函数来生成。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 是 geth 生命周期中最顶级的实例，它负责管理节点中的P2P Server, Http Server, database 等业务无关的高级抽象。关于 Node 类型的定义位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node/node.go&lt;/code&gt;文件中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt;实例是指的是具体 Ethereum Client 的功能性实例。它是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt; 类型的实例，负责提供更为具体的以太坊的功能性Service, 负责与以太坊业务直接相关的抽象，比如管理Blockchain，共识算法等具体模块。它根据上下文的配置信息在调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.RegisterEthService()&lt;/code&gt;函数生成。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.RegisterEthService()&lt;/code&gt;函数中，首先会根据当前的config来判断需要生成的Ethereum backend的类型，是light node backend还是full node backend。我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eth/backend/new()&lt;/code&gt;函数和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;les/client.go/new()&lt;/code&gt;中找到这两种 Ethereum backend 的实例是如何初始化的。Ethereum backend的实例定义了一些更底层的配置，比如chainid，链使用的共识算法的类型等。这两种后端服务的一个典型的区别是 light node backend 不能启动Mining服务。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.RegisterEthService()&lt;/code&gt;函数的最后，调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodes.RegisterAPIs()&lt;/code&gt;函数，将刚刚生成的backend实例注册到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;实例中。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;eth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ethereum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;eventMux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EventMux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;accountManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AccountManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;ethconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateConsensusEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethashConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Noverify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;closeBloomHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;networkID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NetworkId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;gasPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPrice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;etherbase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Etherbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bloomRequests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bloombits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Retrieval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bloomIndexer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewBloomIndexer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BloomBitsBlocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BloomConfirms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p2pServer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;shutdownTracker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;shutdowncheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewShutdownTracker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startNode()&lt;/code&gt;函数的作用是正式的启动一个Ethereum Node。它通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.StartNode()&lt;/code&gt;函数来触发&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.Start()&lt;/code&gt;函数来启动&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt;实例（Node）。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.Start()&lt;/code&gt;函数中，会遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.lifecycles&lt;/code&gt;中注册的后端实例，并在启动它们。此外，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startNode()&lt;/code&gt;函数中，还是调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlockAccounts()&lt;/code&gt;函数，并将解锁的钱包注册到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;中，以及通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.Attach()&lt;/code&gt;函数创建了与local Geth交互的RPClient模块。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数的最后，函数通过执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.Wait()&lt;/code&gt;，使得主线程进入了阻塞状态，其他的功能模块的服务被分散到其他的子协程中进行维护。&lt;/p&gt;

&lt;h3 id=&quot;node&quot;&gt;Node&lt;/h3&gt;

&lt;p&gt;正如我们前面提到的，Node 类型在 geth 的生命周期性中属于顶级实例，它负责作为与外部通信的高级抽象模块的管理员，比如管理 rpc server，http server，Web Socket，以及P2P Server外部接口。同时，Node中维护了节点运行所需要的后端的实例和服务(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycles  []Lifecycle&lt;/code&gt;)。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Node is a container on which services can be registered.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;eventmux&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMux&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;accman&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accounts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Manager&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;keyDir&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// key store directory&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;keyDirTemp&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// If true, key directory will be removed by Stop&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;dirLock&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;fileutil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Releaser&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// prevents concurrent use of instance directory&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;// Channel to wait for termination notifications&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;// Currently running P2P networking layer&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;startStopLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// Start/Stop are protected by an additional lock&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;         &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;// Tracks state of node lifecycle&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;lifecycles&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lifecycle&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// All registered backends, services, and auxiliary services that have a lifecycle&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;rpcAPIs&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// List of APIs currently provided by the node&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ws&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;httpAuth&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;wsAuth&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ipc&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipcServer&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Stores information about the ipc http server&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;inprocHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// In-process RPC request handler to process the API requests&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;databases&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closeTrackingDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// All open databases&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;node的关闭&quot;&gt;Node的关闭&lt;/h4&gt;

&lt;p&gt;在前面我们提到，整个程序的主线程因为调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.Wait()&lt;/code&gt;而进入了阻塞状态。我们可以看到 Node 结构中声明了一个叫做&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop&lt;/code&gt;的channel。由于这个 Channel 一直没有被赋值，所以整个 geth 的主进程才进入了阻塞状态，持续并发的执行其他的业务协程。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Wait blocks until the node is closed.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n.stop&lt;/code&gt;这个Channel被赋予值的时候，geth函数就会停止当前的阻塞状态，并开始执行相应的一系列的资源释放的操作。这个地方的写法还是非常有意思的，值得我们参考。我们为读者编写了一个简单的示例:如何使用Channel来管理Go程序的生命周期。&lt;/p&gt;

&lt;p&gt;值得注意的是，在目前的go-ethereum的codebase中，并没有直接通过给&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stop&lt;/code&gt;这个channel赋值方式来结束主进程的阻塞状态，而是使用一种更简洁粗暴的方式: 调用close函数直接关闭Channel。我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node.doClose()&lt;/code&gt;找到相关的实现。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close&lt;/code&gt;是go语言的原生函数，用于关闭 Channel 时使用。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// doClose releases resources acquired by New(), collecting errors.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// Close databases. This needs the lock because it needs to&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// synchronize with OpenDatabase*.&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closedState&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closeDatabases&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accman&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyDirTemp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RemoveAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keyDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Release instance directory lock.&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closeDataDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Unblock n.Wait.&lt;/span&gt;
 &lt;span class=&quot;nb&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Report any errors that might have occurred.&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%v&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ethereum-api-backend&quot;&gt;Ethereum API Backend&lt;/h3&gt;

&lt;p&gt;我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eth/backend.go&lt;/code&gt;中找到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;这个结构体的定义。这个结构体包含的成员变量以及接收的方法实现了一个Ethereum full node所需要的全部功能和数据结构。我们可以在下面的代码定义中看到，Ethereum结构体中包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TxPool&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Blockchain&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consensus.Engine&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;miner&lt;/code&gt;等最核心的几个数据结构作为成员变量，我们会在后面的章节中详细的讲述这些核心数据结构的主要功能，以及它们的实现的方法。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Ethereum implements the Ethereum full node service.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ethereum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Handlers&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txPool&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxPool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;blockchain&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockChain&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ethDialCandidates&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;enode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;snapDialCandidates&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Merger&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// DB interfaces&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ethdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Block chain database&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;eventMux&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMux&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;consensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;accountManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accounts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Manager&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;bloomRequests&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bloombits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Retrieval&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Channel receiving bloom data retrieval requests&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;bloomIndexer&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainIndexer&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;// Bloom indexer operating during block imports&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;closeBloomHandler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;APIBackend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EthAPIBackend&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;miner&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasPrice&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;etherbase&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;networkID&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;netRPCService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethapi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PublicNetAPI&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;p2pServer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RWMutex&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Protects the variadic fields (e.g. gas price and etherbase)&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;shutdownTracker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shutdowncheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShutdownTracker&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Tracks if and when the node has shutdown ungracefully&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;节点启动和停止Mining的就是通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.StartMining()&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.StopMining()&lt;/code&gt;实现的。设置Mining的收益账户是通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.SetEtherbase()&lt;/code&gt;实现的。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// StartMining starts the miner with the given number of CPU threads. If mining&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// is already running, this method adjust the number of threads allowed to use&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// and updates the minimum price required by the transaction pool.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ethereum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartMining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// If the miner was not running, initialize it&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsMining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// Start Mining&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们额外关注一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;这个成员变量。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;的定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eth/handler.go&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;我们从从宏观角度来看，一个节点的主工作流需要: 1.从网络中获取/同步Transaction和Block的数据 2. 将网络中获取到Block添加到Blockchain中。而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;就维护了backend中同步/请求数据的实例，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;downloader.Downloader&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetcher.TxFetcher&lt;/code&gt;。关于这些成员变量的具体实现，我们会在后续的文章中详细介绍。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;networkID&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;forkFilter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forkid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Fork ID filter, constant across the lifetime of the node&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;snapSync&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Flag whether snap sync is enabled (gets disabled if we already have blocks)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;acceptTxs&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Flag whether we&apos;re considered synchronised (enables transaction processing)&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;checkpointNumber&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// Block number for the sync progress validator to cross reference&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;checkpointHash&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Block hash for the sync progress validator to cross reference&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ethdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txpool&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;txPool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockChain&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;maxPeers&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Downloader&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;blockFetcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockFetcher&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txFetcher&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxFetcher&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;peers&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peerSet&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Merger&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;eventMux&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMux&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txsCh&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTxsEvent&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txsSub&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Subscription&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;minedBlockSub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMuxSubscription&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;peerRequiredBlocks&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// channels for fetcher, syncer, txsyncLoop&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;quitSync&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;chainSync&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainSyncer&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;peerWG&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，我们就介绍了Geth及其所需要的基本模块是如何启动的。我们在接下来将视角转入到各个模块中，从更细粒度的角度深入Ethereum的实现。&lt;/p&gt;

&lt;h3 id=&quot;appendix&quot;&gt;Appendix&lt;/h3&gt;

&lt;p&gt;这里补充一个Go语言的语法知识: &lt;strong&gt;类型断言&lt;/strong&gt;。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.StartMining()&lt;/code&gt;函数中，出现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if c, ok := s.engine.(*clique.Clique); ok&lt;/code&gt;的写法。这中写法是Golang中的语法糖，称为类型断言。具体的语法是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value, ok := element.(T)&lt;/code&gt;，它的含义是如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;element&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;类型的话，那么ok等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;element&lt;/code&gt;的值。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if c, ok := s.engine.(*clique.Clique); ok&lt;/code&gt;语句中，就是在判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s.engine&lt;/code&gt;的是否为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*clique.Clique&lt;/code&gt;类型。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clique&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clique&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clique&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beacon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Beacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnerEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clique&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">什么是Geth？ geth是以太坊基金会基于 Go 语言开发以太坊的官方客户端，它实现了 Ethereum 协议(黄皮书)中所有需要的实现的功能模块。我们可以通过启动 geth 来运行一个 Ethereum 的节点。在以太坊 Merge 之后，geth 作为节点的执行层继续在以太坊生态中发挥重要的作用。 go-ethereum是包含了 geth 客户端代码和以及编译 geth 所需要的其他代码在内的一个完整的代码库。在本系列中我们会通过深入 go-ethereum 代码库，从High-level 的 API 接口出发，沿着 Ethereum 主 Workflow，逐一的理解 Ethereum 具体实现的细节。 为了方便区分，在接下来的文章中，我们用geth来表示 Geth 客户端程序，用go-ethereum(Geth)来表示 go-ethereum 的代码库。 总结的来说: 基于go-ethereum代码库中的代码，我们可以编译出geth客户端程序。 通过运行geth客户端程序我们可以启动一个 Ethereum 的节点。 Go-ethereum Codebase 结构 为了更好的从整体工作流的角度来理解Ethereum，根据主要的业务功能，我们将go-ethereum划分成如下几个模块来分析。 Geth Client 模块 Core 数据结构模块 State Management 模块 StateDB 模块 Trie 数据结构模块 State Optimization (Pruning) Mining 模块 EVM 模块 P2P 网络模块 节点数据同步 Storage 模块 抽象数据库层 LevelDB 调用 … 目前，go-ethereum项目的主要目录结构如下所示: cmd/ 以太坊基金会官方开发的一些 Command-line 程序。该目录下的每个子目录都是一个单独运行的 CLI 程序。 |── clef/ 以太坊官方推出的账户管理程序. |── geth/ 以太坊官方的节点客户端。 core/ 以太坊核心模块，包括核心数据结构，statedb，EVM等算法实现 |── rawdb/ db 相关函数的高层封装(在ethdb和更底层的leveldb之上的封装) ├──accessors_state.go 从 Disk Level 读取/写入与 State 相关的数据结构。 |── state/ ├──statedb.go StateDB 是管理以太坊 World State 最核心的代码，用于管理链上所有的 State 相关操作。 |── txpool Transaction Pool 相关的代码。 |── txpool.go Transaction Pool 的具体实现。 consensus/ |── types/ 以太坊中最核心的数据结构 |── block.go 以太坊 Block 的的数据结构定义与相关函数实现 |── bloom9.go 以太坊使用的一个 Bloom Filter 的实现 |── transaction.go 以太坊 Transaction 的数据结构定义与相关函数实现。 |── transaction_signing.go 用于对 Transaction 进行签名的函数的实现。 |── receipt.go 以太坊交易收据的实现，用于记录以太坊 Transaction 执行的结果 |── vm/ 以太坊的核心中核心 EVM 相关的一些的数据结构的定义。 |── instructions.go EVM 指令的具体的定义，核心中的核心中的核心文件。 |── logger.go 用于追踪 EVM 执行交易过程的日志接口的定义。具体的实现在eth/tracers/logger/logger.go 文件中。 |── genesis.go 创世区块相关的函数。每个 geth 客户端/以太坊节点初始化的都需要调用这个模块。 |── consensus.go 共识相关的参数设定，包括 Block Reward 的数量。 console/ |── bridge.go |── console.go Geth Web3 控制台的入口 ethdb/ Ethereum 本地存储的相关实现, 包括 leveldb 的调用 |── leveldb/ Go-Ethereum使用的与 Bitcoin Core version一样的Leveldb作为本机存储用的数据库 internal/ 一些内部使用的工具库的集合，比如在测试用例中模拟 cmd 的工具。在构建 Ethereum 生态相关的工具时值得注意这个文件夹。 miner/ |── miner.go 矿工模块的实现。 |── worker.go Block generation 的实现，包括打包 transaction，计算合法的Block p2p/ Ethereum 的P2P模块 |── params Ethereum 的一些参数的配置，例如: bootnode的enode地址 |── bootnodes.go bootnode 的 enode 地址 like: aws 的一些节点，azure 的一些节点，Ethereum Foundation 的节点和 Rinkeby 测试网的节点 rlp/ RLP的 Encode与 Decode的相关 rpc/ Ethereum RPC客户端的实现 les/ Ethereum light client 轻节点的实现 trie/ Ethereum 中至关重要的数据结构 Merkle Patrica Trie(MPT) 的实现 |── committer.go Trie向Memory Database 提交数据的工具函数。 |── database.go Memory Database，是Trie数据和 Disk Database 提交的中间层。同时还实现了Trie剪枝的功能。**非常重要** |── node.go MPT中的节点的定义以及相关的函数。 |── secure_trie.go 基于 Trie 的封装的结构。与 trie 中的函数功能相同，不过secure_trie中的 key 是经过hashKey()函数hash过的，无法通过路径获得原始的 key值 |── stack_trie.go Block中使用的Transaction/Receipt Trie的实现 |── trie.go MPT具体功能的函数实现。 Geth Start 前奏: Geth Console 当我们想要部署一个 Ethereum 节点的时候，最直接的方式就是下载官方提供的发行版的geth 客户端程序。geth是一个基于CLI的应用，启动geth和调用geth的功能性API需要使用对应的指令来操作。geth提供了一个相对友好的 console 来方便用户调用各种指令。当我第一次阅读 Ethereum 的文档的时候，我曾经有过这样的疑问，为什么geth是由Go语言编写的，但是在官方文档中的 Web3 的API却是基于 Javascript 的调用？ 这是因为geth内置了一个 Javascript 的解释器:åGoja (interpreter)，来作为用户与geth交互的 CLI Console。我们可以在console/console.go中找到它的定义。 // Console is a JavaScript interpreted runtime environment. It is a fully fledged // JavaScript console attached to a running node via an external or in-process RPC // client. type Console struct { client *rpc.Client // RPC client to execute Ethereum requests through jsre *jsre.JSRE // JavaScript runtime environment running the interpreter prompt string // Input prompt prefix string prompter prompt.UserPrompter // Input prompter to allow interactive user feedback histPath string // Absolute path to the console scrollback history history []string // Scroll history maintained by the console printer io.Writer // Output writer to serialize any display strings to } 启动 了解Ethereum，我们首先要了解Ethereum客户端Geth是怎么运行的。 Geth的启动点位于cmd/geth/main.go/main()函数处，如下所示。 func main() { if err := app.Run(os.Args); err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(1) } } 我们可以看到main()函数非常的简短，其主要功能就是启动一个解析 command line命令的工具: gopkg.in/urfave/cli.v1。继续深入，我们会发现在 cli app 初始化的时候会调用app.Action = geth，来调用geth()函数。而 geth()函数就是用于启动 Ethereum 节点的顶层函数，其代码如下所示。 func geth(ctx *cli.Context) error { if args := ctx.Args(); len(args) &amp;gt; 0 { return fmt.Errorf(&quot;invalid command: %q&quot;, args[0]) } prepare(ctx) stack, backend := makeFullNode(ctx) defer stack.Close() startNode(ctx, stack, backend, false) stack.Wait() return nil } 在geth()函数中，有三个比较重要的函数调用，分别是：prepare()，makeFullNode()，以及startNode()。 prepare() 函数的实现就在当前的main.go文件中。它主要用于设置一些节点初始化需要的配置。比如，我们在节点启动时看到的这句话: Starting Geth on Ethereum mainnet… 就是在prepare()函数中被打印出来的。 makeFullNode()函数的实现位于cmd/geth/config.go文件中。它会将Geth启动时的命令的上下文加载到配置中，并生成stack和backend这两个实例。其中stack是一个Node 类型的实例，它是通过makeFullNode()函数调用makeConfigNode()函数来生成。Node 是 geth 生命周期中最顶级的实例，它负责管理节点中的P2P Server, Http Server, database 等业务无关的高级抽象。关于 Node 类型的定义位于node/node.go文件中。 backend实例是指的是具体 Ethereum Client 的功能性实例。它是一个 Ethereum 类型的实例，负责提供更为具体的以太坊的功能性Service, 负责与以太坊业务直接相关的抽象，比如管理Blockchain，共识算法等具体模块。它根据上下文的配置信息在调用utils.RegisterEthService()函数生成。在utils.RegisterEthService()函数中，首先会根据当前的config来判断需要生成的Ethereum backend的类型，是light node backend还是full node backend。我们可以在eth/backend/new()函数和les/client.go/new()中找到这两种 Ethereum backend 的实例是如何初始化的。Ethereum backend的实例定义了一些更底层的配置，比如chainid，链使用的共识算法的类型等。这两种后端服务的一个典型的区别是 light node backend 不能启动Mining服务。在utils.RegisterEthService()函数的最后，调用了Nodes.RegisterAPIs()函数，将刚刚生成的backend实例注册到stack实例中。 eth := &amp;amp;Ethereum{ config: config, merger: merger, chainDb: chainDb, eventMux: stack.EventMux(), accountManager: stack.AccountManager(), engine: ethconfig.CreateConsensusEngine(stack, chainConfig, &amp;amp;ethashConfig, config.Miner.Notify, config.Miner.Noverify, chainDb), closeBloomHandler: make(chan struct{}), networkID: config.NetworkId, gasPrice: config.Miner.GasPrice, etherbase: config.Miner.Etherbase, bloomRequests: make(chan chan *bloombits.Retrieval), bloomIndexer: core.NewBloomIndexer(chainDb, params.BloomBitsBlocks, params.BloomConfirms), p2pServer: stack.Server(), shutdownTracker: shutdowncheck.NewShutdownTracker(chainDb), } startNode()函数的作用是正式的启动一个Ethereum Node。它通过调用utils.StartNode()函数来触发Node.Start()函数来启动Stack实例（Node）。在Node.Start()函数中，会遍历Node.lifecycles中注册的后端实例，并在启动它们。此外，在startNode()函数中，还是调用了unlockAccounts()函数，并将解锁的钱包注册到stack中，以及通过stack.Attach()函数创建了与local Geth交互的RPClient模块。 在geth()函数的最后，函数通过执行stack.Wait()，使得主线程进入了阻塞状态，其他的功能模块的服务被分散到其他的子协程中进行维护。 Node 正如我们前面提到的，Node 类型在 geth 的生命周期性中属于顶级实例，它负责作为与外部通信的高级抽象模块的管理员，比如管理 rpc server，http server，Web Socket，以及P2P Server外部接口。同时，Node中维护了节点运行所需要的后端的实例和服务(lifecycles []Lifecycle)。 // Node is a container on which services can be registered. type Node struct { eventmux *event.TypeMux config *Config accman *accounts.Manager log log.Logger keyDir string // key store directory keyDirTemp bool // If true, key directory will be removed by Stop dirLock fileutil.Releaser // prevents concurrent use of instance directory stop chan struct{} // Channel to wait for termination notifications server *p2p.Server // Currently running P2P networking layer startStopLock sync.Mutex // Start/Stop are protected by an additional lock state int // Tracks state of node lifecycle lock sync.Mutex lifecycles []Lifecycle // All registered backends, services, and auxiliary services that have a lifecycle rpcAPIs []rpc.API // List of APIs currently provided by the node http *httpServer // ws *httpServer // httpAuth *httpServer // wsAuth *httpServer // ipc *ipcServer // Stores information about the ipc http server inprocHandler *rpc.Server // In-process RPC request handler to process the API requests databases map[*closeTrackingDB]struct{} // All open databases } Node的关闭 在前面我们提到，整个程序的主线程因为调用了stack.Wait()而进入了阻塞状态。我们可以看到 Node 结构中声明了一个叫做stop的channel。由于这个 Channel 一直没有被赋值，所以整个 geth 的主进程才进入了阻塞状态，持续并发的执行其他的业务协程。 // Wait blocks until the node is closed. func (n *Node) Wait() { &amp;lt;-n.stop } 当n.stop这个Channel被赋予值的时候，geth函数就会停止当前的阻塞状态，并开始执行相应的一系列的资源释放的操作。这个地方的写法还是非常有意思的，值得我们参考。我们为读者编写了一个简单的示例:如何使用Channel来管理Go程序的生命周期。 值得注意的是，在目前的go-ethereum的codebase中，并没有直接通过给stop这个channel赋值方式来结束主进程的阻塞状态，而是使用一种更简洁粗暴的方式: 调用close函数直接关闭Channel。我们可以在node.doClose()找到相关的实现。close是go语言的原生函数，用于关闭 Channel 时使用。 // doClose releases resources acquired by New(), collecting errors. func (n *Node) doClose(errs []error) error { // Close databases. This needs the lock because it needs to // synchronize with OpenDatabase*. n.lock.Lock() n.state = closedState errs = append(errs, n.closeDatabases()...) n.lock.Unlock() if err := n.accman.Close(); err != nil { errs = append(errs, err) } if n.keyDirTemp { if err := os.RemoveAll(n.keyDir); err != nil { errs = append(errs, err) } } // Release instance directory lock. n.closeDataDir() // Unblock n.Wait. close(n.stop) // Report any errors that might have occurred. switch len(errs) { case 0: return nil case 1: return errs[0] default: return fmt.Errorf(&quot;%v&quot;, errs) } } Ethereum API Backend 我们可以在eth/backend.go中找到Ethereum这个结构体的定义。这个结构体包含的成员变量以及接收的方法实现了一个Ethereum full node所需要的全部功能和数据结构。我们可以在下面的代码定义中看到，Ethereum结构体中包含了TxPool，Blockchain，consensus.Engine，miner等最核心的几个数据结构作为成员变量，我们会在后面的章节中详细的讲述这些核心数据结构的主要功能，以及它们的实现的方法。 // Ethereum implements the Ethereum full node service. type Ethereum struct { config *ethconfig.Config // Handlers txPool *core.TxPool blockchain *core.BlockChain handler *handler ethDialCandidates enode.Iterator snapDialCandidates enode.Iterator merger *consensus.Merger // DB interfaces chainDb ethdb.Database // Block chain database eventMux *event.TypeMux engine consensus.Engine accountManager *accounts.Manager bloomRequests chan chan *bloombits.Retrieval // Channel receiving bloom data retrieval requests bloomIndexer *core.ChainIndexer // Bloom indexer operating during block imports closeBloomHandler chan struct{} APIBackend *EthAPIBackend miner *miner.Miner gasPrice *big.Int etherbase common.Address networkID uint64 netRPCService *ethapi.PublicNetAPI p2pServer *p2p.Server lock sync.RWMutex // Protects the variadic fields (e.g. gas price and etherbase) shutdownTracker *shutdowncheck.ShutdownTracker // Tracks if and when the node has shutdown ungracefully } 节点启动和停止Mining的就是通过调用Ethereum.StartMining()和Ethereum.StopMining()实现的。设置Mining的收益账户是通过调用Ethereum.SetEtherbase()实现的。 // StartMining starts the miner with the given number of CPU threads. If mining // is already running, this method adjust the number of threads allowed to use // and updates the minimum price required by the transaction pool. func (s *Ethereum) StartMining(threads int) error { ... // If the miner was not running, initialize it if !s.IsMining() { ... // Start Mining go s.miner.Start(eb) } return nil } 这里我们额外关注一下handler这个成员变量。handler的定义在eth/handler.go中。 我们从从宏观角度来看，一个节点的主工作流需要: 1.从网络中获取/同步Transaction和Block的数据 2. 将网络中获取到Block添加到Blockchain中。而handler就维护了backend中同步/请求数据的实例，比如downloader.Downloader，fetcher.TxFetcher。关于这些成员变量的具体实现，我们会在后续的文章中详细介绍。 type handler struct { networkID uint64 forkFilter forkid.Filter // Fork ID filter, constant across the lifetime of the node snapSync uint32 // Flag whether snap sync is enabled (gets disabled if we already have blocks) acceptTxs uint32 // Flag whether we&apos;re considered synchronised (enables transaction processing) checkpointNumber uint64 // Block number for the sync progress validator to cross reference checkpointHash common.Hash // Block hash for the sync progress validator to cross reference database ethdb.Database txpool txPool chain *core.BlockChain maxPeers int downloader *downloader.Downloader blockFetcher *fetcher.BlockFetcher txFetcher *fetcher.TxFetcher peers *peerSet merger *consensus.Merger eventMux *event.TypeMux txsCh chan core.NewTxsEvent txsSub event.Subscription minedBlockSub *event.TypeMuxSubscription peerRequiredBlocks map[uint64]common.Hash // channels for fetcher, syncer, txsyncLoop quitSync chan struct{} chainSync *chainSyncer wg sync.WaitGroup peerWG sync.WaitGroup } 这样，我们就介绍了Geth及其所需要的基本模块是如何启动的。我们在接下来将视角转入到各个模块中，从更细粒度的角度深入Ethereum的实现。 Appendix 这里补充一个Go语言的语法知识: 类型断言。在Ethereum.StartMining()函数中，出现了if c, ok := s.engine.(*clique.Clique); ok的写法。这中写法是Golang中的语法糖，称为类型断言。具体的语法是value, ok := element.(T)，它的含义是如果element是T类型的话，那么ok等于True, value等于element的值。在if c, ok := s.engine.(*clique.Clique); ok语句中，就是在判断s.engine的是否为*clique.Clique类型。 var cli *clique.Clique if c, ok := s.engine.(*clique.Clique); ok { cli = c } else if cl, ok := s.engine.(*beacon.Beacon); ok { if c, ok := cl.InnerEngine().(*clique.Clique); ok { cli = c } }</summary></entry></feed>