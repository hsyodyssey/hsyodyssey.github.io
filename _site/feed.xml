<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://www.hsyodyssey.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.hsyodyssey.com/" rel="alternate" type="text/html" /><updated>2022-05-12T21:09:33+08:00</updated><id>http://www.hsyodyssey.com/feed.xml</id><title type="html">Tech Notes | HSY</title><subtitle>Researching and Thinking
</subtitle><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><entry><title type="html">如何使用Selenium来下载PDF文件</title><link href="http://www.hsyodyssey.com/python/selenium/2022/05/10/selenium.html" rel="alternate" type="text/html" title="如何使用Selenium来下载PDF文件" /><published>2022-05-10T10:00:00+08:00</published><updated>2022-05-10T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/python/selenium/2022/05/10/selenium</id><content type="html" xml:base="http://www.hsyodyssey.com/python/selenium/2022/05/10/selenium.html">&lt;h2 id=&quot;如何使用selenium来下载pdf&quot;&gt;如何使用Selenium来下载PDF？&lt;/h2&gt;

&lt;p&gt;今天帮老婆写了个爬虫，遇到了这么一个问题: 需要从某个页面上下载一个PDF文件，但是不管怎么搞，PDF文件都会在Chrome内打开，而不是另存为或者下载。搜了一圈，发现不管中英文的结果都是如何把一个html页面保存成PDF。大概是有将页面保存成PDF的需求的人更多。&lt;/p&gt;

&lt;p&gt;这里分享一下结论，希望能帮助到遇到之后相同问题的开发人员:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在创建&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chromedriver&lt;/code&gt;的时候，同时传入一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;webdriver.chrome.options.Options&lt;/code&gt;, 如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 这里是自定义的下载文件夹地址
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;download_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_experimental_option&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;prefs&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;目标文件夹&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;download.default_directory&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;download_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;关闭用Chrome原生的打开PDF&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;download.prompt_for_download&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;download.directory_upgrade&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;plugins.always_open_pdf_externally&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;创建webdriver的时候额外传入options&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;webdriver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Chrome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chrome_options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述的options可以使得Chrome在遇到一个目标为PDF类型的地址时，不会用原生浏览的方式打开它，而是将其保存(下载)到options中指定的目录中。&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Python" /><category term="Selenium" /><category term="Blockchain" /><category term="ZKP" /><category term="Groth16" /><summary type="html">如何使用Selenium来下载PDF？ 今天帮老婆写了个爬虫，遇到了这么一个问题: 需要从某个页面上下载一个PDF文件，但是不管怎么搞，PDF文件都会在Chrome内打开，而不是另存为或者下载。搜了一圈，发现不管中英文的结果都是如何把一个html页面保存成PDF。大概是有将页面保存成PDF的需求的人更多。 这里分享一下结论，希望能帮助到遇到之后相同问题的开发人员: 在创建chromedriver的时候，同时传入一个webdriver.chrome.options.Options, 如下: options = webdriver.chrome.options.Options() # 这里是自定义的下载文件夹地址 download_dir = &quot;&quot; options.add_experimental_option(&apos;prefs&apos;, { // 目标文件夹 &quot;download.default_directory&quot;: download_dir, // 关闭用Chrome原生的打开PDF &quot;download.prompt_for_download&quot;: False, &quot;download.directory_upgrade&quot;: True, &quot;plugins.always_open_pdf_externally&quot;: True } ) // 创建webdriver的时候额外传入options driver = webdriver.Chrome(chrome_options=options) 上述的options可以使得Chrome在遇到一个目标为PDF类型的地址时，不会用原生浏览的方式打开它，而是将其保存(下载)到options中指定的目录中。</summary></entry><entry><title type="html">理解Groth16，一些细节上的说明</title><link href="http://www.hsyodyssey.com/zk-snark/2022/03/22/groth16.html" rel="alternate" type="text/html" title="理解Groth16，一些细节上的说明" /><published>2022-03-22T10:00:00+08:00</published><updated>2022-03-22T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/zk-snark/2022/03/22/groth16</id><content type="html" xml:base="http://www.hsyodyssey.com/zk-snark/2022/03/22/groth16.html">&lt;p&gt;&lt;em&gt;Thanks to Zhang Ye, Peng Jingshu for review.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;V神曾经写过一篇非常好的介绍R1CS与QAP问题的&lt;a href=&quot;https://vitalik.ca/general/2016/12/10/qap.html&quot;&gt;文章&lt;/a&gt;。但是，对于不熟悉密码学的，或者说如何使用密码学的思想来解决问题的票友们来说，文章中的一些逻辑上的跨度还是大了一些。尤其是在R1CS转换成多项式的地方，初次接触的人可能会一脸懵逼，不明白为什么要这么做。下面我就从我的理解来谈一谈，从R1CS到QAP这一过程。&lt;/p&gt;

&lt;p&gt;在Groth16的流程中，我们首先需要把&lt;strong&gt;计算问题&lt;/strong&gt;拍平成&lt;strong&gt;电路&lt;/strong&gt;的形式。在这一步骤中，我们会将原始的计算问题，解构成电路的形式(Circuit)。这个电路和原始的计算问题是等价。电路由若干的有输入有输出的算数电路门(Gate)组成。通常情况下，这些电路门都是由两个输入变量，一个输出变量组成。然后我们基于每一个电路门，来构造R1CS约束。&lt;/p&gt;

\[a * b = c\]

&lt;p&gt;这里我们直接使用V神的&lt;a href=&quot;https://vitalik.ca/general/2016/12/10/qap.html&quot;&gt;博客&lt;/a&gt;中的例子。下面的三个矩阵是就是原问题对应的电路的R1CS的约束矩阵。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A
[0, 1, 0, 0, 0, 0]
[0, 0, 0, 1, 0, 0]
[0, 1, 0, 0, 1, 0]
[5, 0, 0, 0, 0, 1]

B
[0, 1, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]

C
[0, 0, 0, 1, 0, 0]
[0, 0, 0, 0, 1, 0]
[0, 0, 0, 0, 0, 1]
[0, 0, 1, 0, 0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这三个矩阵都包含了四个行向量，代表了原始的计算被拍平成了在R1CS约束下的四个电路门。到了这一步，我们的原问题”&lt;em&gt;我们知道原始计算的一个解&lt;/em&gt;“就转化成了，&lt;em&gt;“我们知道一个解向量，使得它在每个电路约束下都成立”&lt;/em&gt;。我们用$S$来表示解向量，本例中$S$的值如下所示。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1
3
35
9
27
30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时，如果我们想证明我们知道原始计算的一个解，那么就需要证明A，B，C矩阵中的&lt;strong&gt;每个&lt;/strong&gt;行向量与解向量$S$的内积之后的值是符合R1CS约束的($A_i,B_i,C_i$表示矩阵中的行向量)：&lt;/p&gt;

\[(A_i*S)* (B_i*S) - C_i*S = 0\]

&lt;p&gt;在接下来的一步，我们需要将R1CS的约束转换成一个QAP问题。我觉得原文中没有提到的一点时，我们为什么要这么做的？这样的转换目的是什么？V神的原文只描述了这一步骤的目标是把向量的内积计算转化为多项式的形式，以及如何进行拉普拉斯插值求多项式。所以第一次读到这里的时候，我感觉一头雾水。&lt;/p&gt;

&lt;p&gt;这一过程是理解包括Groth16在内的所有ZK-Proof System的重点。这里阐述一下我的理解。这样做的原因是，如果只使用R1CS的约束矩阵来验证，我们只能一个电路门，一个电路门的，使用列向量与解向量的内积来验证是否满足R1CS的约束。这样在方式在大规模电路下（几十万，上百万的电路门）显然是十分低效的。&lt;/p&gt;

&lt;p&gt;那么接下来的自然思考方向就变成了，存不存在一种办法，可以让我们通过&lt;strong&gt;一次/个计算&lt;/strong&gt;来验证所有约束的正确性？&lt;/p&gt;

&lt;p&gt;我们如果仔细观察上面的计算过程，可以发现解向量中 $S$中的 $S_1$元素一定与约束矩阵中$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$这四个元素相乘。因此，我们假设存在这样一个多项式 $A_1(x)$，它经过$(1,0), (2,0), (3,0), (4,5)$这四个点。这个多项式 $A_1(x)$的数学意义是：当x的值为1时，多项式的值为0，当$x=2$时，多项式的值为0，当$x=3$时，多项式的值为0，当$x=4$时，多项式的值为5。这样，我们通过引入额外的参数x，使得可以使用一个的多项式$A_1(x)$来描述[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]这四个值。&lt;/p&gt;

&lt;p&gt;根据原文中提到的拉普拉斯插值法，我们可以求出关于[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]的多项式为：&lt;/p&gt;

\[A_1(x) = 0.833*x^3 -5.0*x^2 +9.166*x -5.0\]

&lt;p&gt;我们验证一下就可以发现，当x取1时，$A_1(x)$的值为0，等于原R1CS约束矩阵中的$A_{11}$的值。同样的，我们可以构造出其他列向量的多项式$A_i(x),B_i(x),C_i(x)$。&lt;/p&gt;

&lt;p&gt;那么这样，我们就可以使用这几个多项式来描述，向量内积是否满足R1CS约束的过程。我们将解向量$S$带入，原等式的左边可以写成下面的形式:&lt;/p&gt;

\[((1 * A_1(x))+(3 * A_2(x))+(35 * A_3(x)) + (9 * A_4(x)) +(27 * A_5(x))+(30 * A_6(x))) \\ *（(1 * B_1(x)+(3 * B_2(x))+(35 * B_3(x)) + (9 * B_4(x)) +(27 * B_5(x))+(30 * B_6(x))) \\ - （(1 * C_1(x)+(3 * C_2(x))+(35 * C_3(x)) + (9 * C_4(x)) +(27 * C_5(x))+(30 * C_6(x)))\]

&lt;p&gt;当x取1时，上面的多项式就等于验证第一个门电路是否满足R1CS约束；当x取2时，上面的多项式就等于验证第二个门电路是否满足R1CS约束。以此类推。现在我们已经将实际的值转换成了多项式，根据x的取值的不同，来描述不同的R1CS约束。&lt;/p&gt;

&lt;p&gt;那么，更进一步的来说，因为上面的式子中都是多项式，我们可以把等式左边展开成一个更简洁的多项式 $p(x)$:&lt;/p&gt;

\[p(x) = (-5.166*x^3+38.5*x^2-73.333*x+43)*(0.666*x^3-5.0*x^2+10.333*x-3.0)-(2.833*x^3-24.5*x^2+10.333*x-41.0)\\
       = -3.440556*x^6+51.471*x^5-294.720056*x^4+805.7885*x^3-1063.749889*x^2+592.652*x-88\]

&lt;p&gt;同时我们需要让等式右边的值等于0。因此，我们就可以先构造一个多项式$t(x)=(x-1)(x-2)(x-3)(x-4)$。显然$t(x)$在x的取值为[1，2，3，4]值情况下都等于0。在本例中，显然$t(x)$是不等于$t(x)$（多项式的阶不同），所以我们引入另一个多项式$h(x)$，使得$p(x)=t(x)h(x)$。&lt;/p&gt;

&lt;p&gt;这一步的操作中蕴含了一个数学引理: &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma&quot;&gt;Schwartz–Zippel lemma&lt;/a&gt;。感兴趣的读者可以深入了解一下这个引理。&lt;/p&gt;

&lt;p&gt;这样我们就实现了用一个多项式来描述所有的R1CS的约束了。我们可以设置x值取1，2，3，4，来验证对应的电路的R1CS约束是不是合法。在实际问题上，x的取值远不止范围1，2，3，4四个值。&lt;/p&gt;

&lt;p&gt;现在的关于&lt;strong&gt;Prover是否知道原问题的解的证明&lt;/strong&gt;转换成了，&lt;strong&gt;Prover是否知道一个基于原电路R1CS约束正确插值形成的多项式$p(x)$，使得$p(x)=t(x)h(x)$在x的域上都成立&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;那么，顺着这个逻辑继续思考，&lt;em&gt;Prover如何向其他人证明，他/她知道这个多项式$P(x)$的存在的呢？&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;最简单的方法就是，Prover直接把$p(x)$这个多项式发给Verifier。但是在现实中，多项式$p(x)$的degree可能非常的高，传输$p(x)$成本很大，不符合简洁证明的要求。那么，另一个简单的想法可以是这样的。在公式$p(x)=t(x)h(x)$中，$t(x)$是公开的多项式，那么作为知道$p(x)$的Prover，我们可以快速的计算出$h(x)=\frac{p(x)}{t(x)}$。那么，我们只要提供某个$x=r$对应的$h(r)$,$p(r)$的值给验证者。那么显然，验证者通过计算$t(r)*h(r)$的值，与Prover提供的$p(r)$的值进行比较验证。那么作为Prover，我们不需要公开$p(x)$的细节，就可以向Verifier证明我们知道多项式$p(x)$。&lt;/p&gt;

&lt;p&gt;那么想象一下，Alice对Bob说，我知道一个计算的解。那么Bob可以要求Alice计算$x=r$时，$h(r)$和$t(r)$的值，并且验证$h(r)*z(r)$是否与$t(r)$的值是否相等来判断Alice说的是否正确。同时，在这个过程我们完美的隐藏掉了原来解向量$S$的存在。&lt;/p&gt;

&lt;p&gt;通过，上面的过程，我们就完成了一个简单的零知识问题的转换。但是这个模型并不足够安全，比如Alice可以伪造合法的$h(r)$和$t(r)$的值，使得$t(r)=z(r)h(r)$成立。具体的来说，比如不管Bob请求任意r下的$h(r)$值，Alice总是返回$h(r),t(r) == 0$。用稍微正式的语言来描述这个现象就是：Alice知道了$r$的具体值之后，可以计算出另一组值$t(r’)$,$h(r’)$，使得$t(r’)=z(r)h(r’)$成立。因此在这种情况下，等式的左右两边仍然是相同的，但是不符合我们的目标。&lt;/p&gt;

&lt;p&gt;因此，顺着这个逻辑思考，接下来的需要解决的问题就变成了，&lt;em&gt;如何保证Prover不会伪造&lt;/em&gt;$h(r)$,$p(r)$的值呢？&lt;/p&gt;

&lt;p&gt;这一步就是文章中从QAP到PCP(Probabilistic Checkable Proofs)这一步. 目前这部分主要是通过KCA(Knowledge of Coefficient Test and Assumption)来实现的。Groth16中，我们需要对多项式(电路)建立Common Reference String(CRS)，来保证non-interactive。这也就是我们常常听到的Trusted Setup。Trusted Setup带了不少负面效果。一旦Trusted Setup时的信息发生了泄漏，整个的Proof System的安全性保证也就不存在了。同时在Groth16中，我们需要对每个多项式都进行Trusted Setup的。换句话说，我们需要对每个计算电路都要进行一次的Trusted Setup，这对于图灵完备的通用计算来说成本是非常高的。这也是为什么目前只有ZCash可以良好的运行ZK-SNARKs，而很少见到在General-Purpose Blockchain中使用ZK-SNARKs相关技术的原因之一。&lt;/p&gt;

&lt;p&gt;为了解决这方面的问题，研究人员提出了&lt;a href=&quot;https://crypto.stanford.edu/bulletproofs/&quot;&gt;BulletProofs&lt;/a&gt;。BulletProofs将Groth16中的多项式证明的部分升级成了基于Inner production-base Polynomial Commitment Scheme。在BulletProofs中，多项式的验证不再需要Trusted Setup，但是需要更大的Proof Size。&lt;/p&gt;

&lt;p&gt;另一方面，研究人员提出了Plonk协议，这是另一种证明体系。在Plonk中的电路约束不再是R1CS的形式，并且引入了&lt;a href=&quot;https://www.youtube.com/watch?v=W1E2CI_u6d0&quot;&gt;KZG(KATE Commitment)&lt;/a&gt;作为Polynomial Commitment Scheme。在Plonk体系中，只需要一次的Trusted Setup，就可以给多个多项式进行验证。目前，基于zk-rollup技术的Layer-2解决方案ZKSync就是基于Plonk协议开发的。&lt;/p&gt;

&lt;p&gt;关于Plonk，PCS的技术在本篇中不做详解。感兴趣的读者可以搜索相关的关键词进行学习。&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Bulletproofs: Short Proofs for Confidential Transactions and More, &lt;a href=&quot;https://crypto.stanford.edu/bulletproofs/&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Schwartz–Zippel lemma, &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Quadratic Arithmetic Programs: from Zero to Hero, &lt;a href=&quot;https://vitalik.ca/general/2016/12/10/qap.html&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Kate Commitments: A Primer, &lt;a href=&quot;https://hackmd.io/@tompocock/Hk2A7BD6U&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Constant-Size Commitments to Polynomials and Their Applications, &lt;a href=&quot;https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Understanding PLONK, &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="zk-SNARK" /><category term="Blockchain" /><category term="ZKP" /><category term="Groth16" /><summary type="html">Thanks to Zhang Ye, Peng Jingshu for review. V神曾经写过一篇非常好的介绍R1CS与QAP问题的文章。但是，对于不熟悉密码学的，或者说如何使用密码学的思想来解决问题的票友们来说，文章中的一些逻辑上的跨度还是大了一些。尤其是在R1CS转换成多项式的地方，初次接触的人可能会一脸懵逼，不明白为什么要这么做。下面我就从我的理解来谈一谈，从R1CS到QAP这一过程。 在Groth16的流程中，我们首先需要把计算问题拍平成电路的形式。在这一步骤中，我们会将原始的计算问题，解构成电路的形式(Circuit)。这个电路和原始的计算问题是等价。电路由若干的有输入有输出的算数电路门(Gate)组成。通常情况下，这些电路门都是由两个输入变量，一个输出变量组成。然后我们基于每一个电路门，来构造R1CS约束。 \[a * b = c\] 这里我们直接使用V神的博客中的例子。下面的三个矩阵是就是原问题对应的电路的R1CS的约束矩阵。 A [0, 1, 0, 0, 0, 0] [0, 0, 0, 1, 0, 0] [0, 1, 0, 0, 1, 0] [5, 0, 0, 0, 0, 1] B [0, 1, 0, 0, 0, 0] [0, 1, 0, 0, 0, 0] [1, 0, 0, 0, 0, 0] [1, 0, 0, 0, 0, 0] C [0, 0, 0, 1, 0, 0] [0, 0, 0, 0, 1, 0] [0, 0, 0, 0, 0, 1] [0, 0, 1, 0, 0, 0] 这三个矩阵都包含了四个行向量，代表了原始的计算被拍平成了在R1CS约束下的四个电路门。到了这一步，我们的原问题”我们知道原始计算的一个解“就转化成了，“我们知道一个解向量，使得它在每个电路约束下都成立”。我们用$S$来表示解向量，本例中$S$的值如下所示。 1 3 35 9 27 30 此时，如果我们想证明我们知道原始计算的一个解，那么就需要证明A，B，C矩阵中的每个行向量与解向量$S$的内积之后的值是符合R1CS约束的($A_i,B_i,C_i$表示矩阵中的行向量)： \[(A_i*S)* (B_i*S) - C_i*S = 0\] 在接下来的一步，我们需要将R1CS的约束转换成一个QAP问题。我觉得原文中没有提到的一点时，我们为什么要这么做的？这样的转换目的是什么？V神的原文只描述了这一步骤的目标是把向量的内积计算转化为多项式的形式，以及如何进行拉普拉斯插值求多项式。所以第一次读到这里的时候，我感觉一头雾水。 这一过程是理解包括Groth16在内的所有ZK-Proof System的重点。这里阐述一下我的理解。这样做的原因是，如果只使用R1CS的约束矩阵来验证，我们只能一个电路门，一个电路门的，使用列向量与解向量的内积来验证是否满足R1CS的约束。这样在方式在大规模电路下（几十万，上百万的电路门）显然是十分低效的。 那么接下来的自然思考方向就变成了，存不存在一种办法，可以让我们通过一次/个计算来验证所有约束的正确性？ 我们如果仔细观察上面的计算过程，可以发现解向量中 $S$中的 $S_1$元素一定与约束矩阵中$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$这四个元素相乘。因此，我们假设存在这样一个多项式 $A_1(x)$，它经过$(1,0), (2,0), (3,0), (4,5)$这四个点。这个多项式 $A_1(x)$的数学意义是：当x的值为1时，多项式的值为0，当$x=2$时，多项式的值为0，当$x=3$时，多项式的值为0，当$x=4$时，多项式的值为5。这样，我们通过引入额外的参数x，使得可以使用一个的多项式$A_1(x)$来描述[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]这四个值。 根据原文中提到的拉普拉斯插值法，我们可以求出关于[$A_{11}$，$A_{21}$，$A_{31}$，$A_{41}$]的多项式为： \[A_1(x) = 0.833*x^3 -5.0*x^2 +9.166*x -5.0\] 我们验证一下就可以发现，当x取1时，$A_1(x)$的值为0，等于原R1CS约束矩阵中的$A_{11}$的值。同样的，我们可以构造出其他列向量的多项式$A_i(x),B_i(x),C_i(x)$。 那么这样，我们就可以使用这几个多项式来描述，向量内积是否满足R1CS约束的过程。我们将解向量$S$带入，原等式的左边可以写成下面的形式: \[((1 * A_1(x))+(3 * A_2(x))+(35 * A_3(x)) + (9 * A_4(x)) +(27 * A_5(x))+(30 * A_6(x))) \\ *（(1 * B_1(x)+(3 * B_2(x))+(35 * B_3(x)) + (9 * B_4(x)) +(27 * B_5(x))+(30 * B_6(x))) \\ - （(1 * C_1(x)+(3 * C_2(x))+(35 * C_3(x)) + (9 * C_4(x)) +(27 * C_5(x))+(30 * C_6(x)))\] 当x取1时，上面的多项式就等于验证第一个门电路是否满足R1CS约束；当x取2时，上面的多项式就等于验证第二个门电路是否满足R1CS约束。以此类推。现在我们已经将实际的值转换成了多项式，根据x的取值的不同，来描述不同的R1CS约束。 那么，更进一步的来说，因为上面的式子中都是多项式，我们可以把等式左边展开成一个更简洁的多项式 $p(x)$: \[p(x) = (-5.166*x^3+38.5*x^2-73.333*x+43)*(0.666*x^3-5.0*x^2+10.333*x-3.0)-(2.833*x^3-24.5*x^2+10.333*x-41.0)\\ = -3.440556*x^6+51.471*x^5-294.720056*x^4+805.7885*x^3-1063.749889*x^2+592.652*x-88\] 同时我们需要让等式右边的值等于0。因此，我们就可以先构造一个多项式$t(x)=(x-1)(x-2)(x-3)(x-4)$。显然$t(x)$在x的取值为[1，2，3，4]值情况下都等于0。在本例中，显然$t(x)$是不等于$t(x)$（多项式的阶不同），所以我们引入另一个多项式$h(x)$，使得$p(x)=t(x)h(x)$。 这一步的操作中蕴含了一个数学引理: Schwartz–Zippel lemma。感兴趣的读者可以深入了解一下这个引理。 这样我们就实现了用一个多项式来描述所有的R1CS的约束了。我们可以设置x值取1，2，3，4，来验证对应的电路的R1CS约束是不是合法。在实际问题上，x的取值远不止范围1，2，3，4四个值。 现在的关于Prover是否知道原问题的解的证明转换成了，Prover是否知道一个基于原电路R1CS约束正确插值形成的多项式$p(x)$，使得$p(x)=t(x)h(x)$在x的域上都成立。 那么，顺着这个逻辑继续思考，Prover如何向其他人证明，他/她知道这个多项式$P(x)$的存在的呢？ 最简单的方法就是，Prover直接把$p(x)$这个多项式发给Verifier。但是在现实中，多项式$p(x)$的degree可能非常的高，传输$p(x)$成本很大，不符合简洁证明的要求。那么，另一个简单的想法可以是这样的。在公式$p(x)=t(x)h(x)$中，$t(x)$是公开的多项式，那么作为知道$p(x)$的Prover，我们可以快速的计算出$h(x)=\frac{p(x)}{t(x)}$。那么，我们只要提供某个$x=r$对应的$h(r)$,$p(r)$的值给验证者。那么显然，验证者通过计算$t(r)*h(r)$的值，与Prover提供的$p(r)$的值进行比较验证。那么作为Prover，我们不需要公开$p(x)$的细节，就可以向Verifier证明我们知道多项式$p(x)$。 那么想象一下，Alice对Bob说，我知道一个计算的解。那么Bob可以要求Alice计算$x=r$时，$h(r)$和$t(r)$的值，并且验证$h(r)*z(r)$是否与$t(r)$的值是否相等来判断Alice说的是否正确。同时，在这个过程我们完美的隐藏掉了原来解向量$S$的存在。 通过，上面的过程，我们就完成了一个简单的零知识问题的转换。但是这个模型并不足够安全，比如Alice可以伪造合法的$h(r)$和$t(r)$的值，使得$t(r)=z(r)h(r)$成立。具体的来说，比如不管Bob请求任意r下的$h(r)$值，Alice总是返回$h(r),t(r) == 0$。用稍微正式的语言来描述这个现象就是：Alice知道了$r$的具体值之后，可以计算出另一组值$t(r’)$,$h(r’)$，使得$t(r’)=z(r)h(r’)$成立。因此在这种情况下，等式的左右两边仍然是相同的，但是不符合我们的目标。 因此，顺着这个逻辑思考，接下来的需要解决的问题就变成了，如何保证Prover不会伪造$h(r)$,$p(r)$的值呢？ 这一步就是文章中从QAP到PCP(Probabilistic Checkable Proofs)这一步. 目前这部分主要是通过KCA(Knowledge of Coefficient Test and Assumption)来实现的。Groth16中，我们需要对多项式(电路)建立Common Reference String(CRS)，来保证non-interactive。这也就是我们常常听到的Trusted Setup。Trusted Setup带了不少负面效果。一旦Trusted Setup时的信息发生了泄漏，整个的Proof System的安全性保证也就不存在了。同时在Groth16中，我们需要对每个多项式都进行Trusted Setup的。换句话说，我们需要对每个计算电路都要进行一次的Trusted Setup，这对于图灵完备的通用计算来说成本是非常高的。这也是为什么目前只有ZCash可以良好的运行ZK-SNARKs，而很少见到在General-Purpose Blockchain中使用ZK-SNARKs相关技术的原因之一。 为了解决这方面的问题，研究人员提出了BulletProofs。BulletProofs将Groth16中的多项式证明的部分升级成了基于Inner production-base Polynomial Commitment Scheme。在BulletProofs中，多项式的验证不再需要Trusted Setup，但是需要更大的Proof Size。 另一方面，研究人员提出了Plonk协议，这是另一种证明体系。在Plonk中的电路约束不再是R1CS的形式，并且引入了KZG(KATE Commitment)作为Polynomial Commitment Scheme。在Plonk体系中，只需要一次的Trusted Setup，就可以给多个多项式进行验证。目前，基于zk-rollup技术的Layer-2解决方案ZKSync就是基于Plonk协议开发的。 关于Plonk，PCS的技术在本篇中不做详解。感兴趣的读者可以搜索相关的关键词进行学习。 References Bulletproofs: Short Proofs for Confidential Transactions and More, [link] Schwartz–Zippel lemma, [link] Quadratic Arithmetic Programs: from Zero to Hero, [link] Kate Commitments: A Primer, [link] Constant-Size Commitments to Polynomials and Their Applications, [link] Understanding PLONK, [link]</summary></entry><entry><title type="html">诈骗与PUA</title><link href="http://www.hsyodyssey.com/daily/2022/03/15/pua.html" rel="alternate" type="text/html" title="诈骗与PUA" /><published>2022-03-15T10:00:00+08:00</published><updated>2022-03-15T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/daily/2022/03/15/pua</id><content type="html" xml:base="http://www.hsyodyssey.com/daily/2022/03/15/pua.html">&lt;p&gt;早上的时候，我接到了一通来自泉州的移动电话。对方声称自己是京东的客服，并快速的介绍了自己的工号。一口流利的普通话，加上我对京东这个公司的好感度，我并没有第一时间挂断他的电话。在对方准确的说出了我的名字以及学校之后，事情开始变得微妙起来。对方声称，因为两会的关系，上面要求未来京东不在对学生身份的用户提供金融服务，例如白条等，让我自行的在京东APP上关闭自己的学生认证，否则可能会出现征信上的问题。并好心的向我介绍了关闭的方法，在京东APP中搜索某个页面并关闭。之后就有礼貌的挂断了电话。我按照他的指示找到了他描述的页面，但是却不是他所描述的取消学生身份的页面，只是激活了一个学生身份的会员。&lt;/p&gt;

&lt;p&gt;其实事情发展到这里并没有什么特别异常的地方，我的第一感觉还是这是通来自京东的客服推销电话。结果到下午的时候，我接到了第二通电话。对方上了就是指责我并没有理会他同事的后续电话，按照他同事的要求取消我在京东上的学生认证，并警告我如果不及时处理，他们将会向我做出滞纳金的处罚。我当下感觉十分的气愤，并强烈的回敬说京东算个鸡吧，我作为你司长期股东加大客户，你凭什么收我的钱？对方大概是没有见到过我这么粗暴的“目标”，当下表示不是这个意思，只是为了帮我解决问题。但我余怒未消，感觉到作为京东大客户反遭背刺，臭骂对方一句，并扬言要自己打电话给官方投诉他，然后挂掉了电话。&lt;/p&gt;

&lt;p&gt;事情发展到这里，读者大概也已经猜到了，这是连续的电信诈骗电话。在挂掉电话后，我当下就打电话给了京东的官方客服，并向他询问我是不是遇到了诈骗。不得不说，真正的京东客服态度是真的好，非常和善的告诉我，他们不会对客户说出罚款之类的话，显然这就是电话诈骗。&lt;/p&gt;

&lt;p&gt;在这次事件中，我并没有什么损失，除了几分钟的气愤。但是，我也必须承认，这个骗子团伙确实骗到了我。其实在最开始的时候，我就问了他一个问题，为什么你们京东的客服电话是一个泉州的手机号码，而不是常见的官方电话，或者是宿迁的电话？但是在对方准确的叫出了我的名字，并给了一定的解释之后，我选择了相信。在第二通电话中，对方声称的上面要求的罚款，滞纳金，我还是相信了。单从骗人的角度来说，对面的骗子确实完成了既定目标，只不过我并没有顺着他设好的思维路径继续下去。&lt;/p&gt;

&lt;p&gt;我想诈骗和PUA一样，都是一种在精心设计好的框架下的精神控制。如果顺着对方的逻辑，受害者注定是逃不出对方的圈套的。仔细思考了一下，诈骗和PUA一样，首先都是要骗取受害人的信任，卸下防备。比如在上述的案例中，准确的说出我的名字和学校。第二步，充当善意的好人。在这一个步骤中，对方并不会对受害人索取什么，反而充当一种提供帮助的角色，不管是物质帮助，或者精神帮助。比如，在这次诈骗中，骗子的第一个电话的目的是为了帮我解决潜在的风险。第三步，对受害人开始有边界的威胁，这种威胁一定不是用力过猛的狠毒威胁，而是由边界的轻拿轻的放的威胁。比如利用受害人对公权力的敬畏，在我经历这个案例中，骗子就声称如果不解决这个问题，就会影响到我未来的征信记录。或者，利用人性的善意，比如新闻中的常客，杀猪盘，就是利用了人性中害怕失去的善良，仿佛如果你不打钱给对方，就会永远失去对方。&lt;/p&gt;

&lt;p&gt;PUA也好，诈骗也好，都是缺大德的下贱至极的行为。能做出这种事情的，也都是丧尽天良之人中的渣滓中的臭蛆。拉低人类这种生物的道德底线的烂人中的烂人。&lt;/p&gt;

&lt;p&gt;破除PUA与诈骗的方式主要方式就是要忠于自己。当其他人试图精神控制的时候，跳出他们的思维路径，认真思考，&lt;strong&gt;假如我不按照他说的那么做，又会这样呢？&lt;/strong&gt;&lt;/p&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Daily" /><category term="Daily" /><summary type="html">早上的时候，我接到了一通来自泉州的移动电话。对方声称自己是京东的客服，并快速的介绍了自己的工号。一口流利的普通话，加上我对京东这个公司的好感度，我并没有第一时间挂断他的电话。在对方准确的说出了我的名字以及学校之后，事情开始变得微妙起来。对方声称，因为两会的关系，上面要求未来京东不在对学生身份的用户提供金融服务，例如白条等，让我自行的在京东APP上关闭自己的学生认证，否则可能会出现征信上的问题。并好心的向我介绍了关闭的方法，在京东APP中搜索某个页面并关闭。之后就有礼貌的挂断了电话。我按照他的指示找到了他描述的页面，但是却不是他所描述的取消学生身份的页面，只是激活了一个学生身份的会员。 其实事情发展到这里并没有什么特别异常的地方，我的第一感觉还是这是通来自京东的客服推销电话。结果到下午的时候，我接到了第二通电话。对方上了就是指责我并没有理会他同事的后续电话，按照他同事的要求取消我在京东上的学生认证，并警告我如果不及时处理，他们将会向我做出滞纳金的处罚。我当下感觉十分的气愤，并强烈的回敬说京东算个鸡吧，我作为你司长期股东加大客户，你凭什么收我的钱？对方大概是没有见到过我这么粗暴的“目标”，当下表示不是这个意思，只是为了帮我解决问题。但我余怒未消，感觉到作为京东大客户反遭背刺，臭骂对方一句，并扬言要自己打电话给官方投诉他，然后挂掉了电话。 事情发展到这里，读者大概也已经猜到了，这是连续的电信诈骗电话。在挂掉电话后，我当下就打电话给了京东的官方客服，并向他询问我是不是遇到了诈骗。不得不说，真正的京东客服态度是真的好，非常和善的告诉我，他们不会对客户说出罚款之类的话，显然这就是电话诈骗。 在这次事件中，我并没有什么损失，除了几分钟的气愤。但是，我也必须承认，这个骗子团伙确实骗到了我。其实在最开始的时候，我就问了他一个问题，为什么你们京东的客服电话是一个泉州的手机号码，而不是常见的官方电话，或者是宿迁的电话？但是在对方准确的叫出了我的名字，并给了一定的解释之后，我选择了相信。在第二通电话中，对方声称的上面要求的罚款，滞纳金，我还是相信了。单从骗人的角度来说，对面的骗子确实完成了既定目标，只不过我并没有顺着他设好的思维路径继续下去。 我想诈骗和PUA一样，都是一种在精心设计好的框架下的精神控制。如果顺着对方的逻辑，受害者注定是逃不出对方的圈套的。仔细思考了一下，诈骗和PUA一样，首先都是要骗取受害人的信任，卸下防备。比如在上述的案例中，准确的说出我的名字和学校。第二步，充当善意的好人。在这一个步骤中，对方并不会对受害人索取什么，反而充当一种提供帮助的角色，不管是物质帮助，或者精神帮助。比如，在这次诈骗中，骗子的第一个电话的目的是为了帮我解决潜在的风险。第三步，对受害人开始有边界的威胁，这种威胁一定不是用力过猛的狠毒威胁，而是由边界的轻拿轻的放的威胁。比如利用受害人对公权力的敬畏，在我经历这个案例中，骗子就声称如果不解决这个问题，就会影响到我未来的征信记录。或者，利用人性的善意，比如新闻中的常客，杀猪盘，就是利用了人性中害怕失去的善良，仿佛如果你不打钱给对方，就会永远失去对方。 PUA也好，诈骗也好，都是缺大德的下贱至极的行为。能做出这种事情的，也都是丧尽天良之人中的渣滓中的臭蛆。拉低人类这种生物的道德底线的烂人中的烂人。 破除PUA与诈骗的方式主要方式就是要忠于自己。当其他人试图精神控制的时候，跳出他们的思维路径，认真思考，假如我不按照他说的那么做，又会这样呢？</summary></entry><entry><title type="html">Rollup/zk-Rollup以及zkVM/zkEVM</title><link href="http://www.hsyodyssey.com/blockchain/2022/02/02/rollup_and_ZKVM.html" rel="alternate" type="text/html" title="Rollup/zk-Rollup以及zkVM/zkEVM" /><published>2022-02-02T10:00:00+08:00</published><updated>2022-02-02T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/02/02/rollup_and_ZKVM</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/02/02/rollup_and_ZKVM.html">&lt;p&gt;自从&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;EIP-1559&lt;/a&gt;生效后，由于币价的升高，和基础Gas Price的约束，Ethereum Mainnet上的单笔交易费用已经高到了离谱的程度。在上个月的一次实验中，我尝试了一把在Layer-1上调用一次古早的合约，大概花了100美刀左右的交易费。就像社区内经常听到的抱怨声那样，Ethereum  Mainnet已经成为了普通用户用不起的贵族链。&lt;/p&gt;

&lt;p&gt;显然，目前&lt;strong&gt;天价的交易费&lt;/strong&gt;以及&lt;strong&gt;有限的Throughput&lt;/strong&gt;已经成为了限制Ethereum继续发展的两大难题。幸运的是，&lt;strong&gt;rollup&lt;/strong&gt;技术的发展给社区展现了一种似乎可以一招解决两大难题的绝世武学。&lt;/p&gt;

&lt;p&gt;简单的来说，顾名思义，rollup，就是把一堆的transaction rollup到一个新的transaction。然后，通过某种神奇的技术，使得Ethereum Mainnet只需要验证这个新生成的transaction，就可以保证被Rollup之前的若干的Transaction的确定性，正确性，完整性。举个简单的例子，我们想象一个学校内交学费的场景。过去，每个学生(i.e. Account)都需要通过学校交费系统(i.e. Ethereum Mainnet)单独的将自己的学费转账(Transfer)给学校教务处。假如，现在计算机系有1000个学生，那么系统就要处理1000笔转账的交易(Transaction)。现在，系里新来一位叫做&lt;em&gt;Rollup&lt;/em&gt;的教授。他在学生中很有号召力。基于他的个人魅力(神奇的魔法)，&lt;strong&gt;私下里&lt;/strong&gt;让所有的的学生把钱通过&lt;strong&gt;某种方式&lt;/strong&gt;先转给他。当&lt;em&gt;Prof.Rollup&lt;/em&gt;收集到系里所有学生的学费之后，然后他通过构造一个transaction把所有的学费交给教务处。这个例子大概就是一个Rollup场景的简单抽象。我们把学校的交费系统看作为Ethereum Mainnet 或者说是Layer-1，那么私下里收集学生的学费就是所谓的&lt;strong&gt;Layer-2&lt;/strong&gt;进行的了。通常，我们把Layer-1上的交易称为on-chain transaction，把在Layer-2进行上的交易称为off-chain transaction。&lt;/p&gt;

&lt;p&gt;Rollup的好处是显而易见的，假如每次把&lt;strong&gt;N&lt;/strong&gt;个transaction rollup成一个，那么对于Mainnet来说，处理一条交易，实际效果等同于处理了之前系统中的&lt;strong&gt;N&lt;/strong&gt;个交易。同时，系统实际吞吐量的Upper Bound也实际上上市到了&lt;strong&gt;N*MAX_TPS&lt;/strong&gt;的水平。同时，对于用户来说，同样一条交易Mainnet Transaction Fee实际上是被&lt;strong&gt;N&lt;/strong&gt;个用户同时负担的。那么理论上，用户需要的实际交易费用也只有之前的&lt;strong&gt;1/N+c&lt;/strong&gt;。这里的&lt;strong&gt;c&lt;/strong&gt;代表rollup服务提供商收取的交易费，这个值是远远小于layer-1上交易所需要的交易费用的。&lt;/p&gt;

&lt;p&gt;Rollup看上去完美的解决了Ethereum面临的两大难题，通过分层的方式给Ethereum进行了扩容。但是，在实现layer-2 rollup时，还是有很多的细节有待商榷。比如:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;怎么保证&lt;em&gt;Prof.Rollup&lt;/em&gt;一定会把学费交给教务处呢？ (Layer-2 交易的安全性)&lt;/li&gt;
  &lt;li&gt;怎么保证&lt;em&gt;Prof.Rollup&lt;/em&gt;会把全部的学费都交给教务处呢？(Layer-2 交易的完整性)&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Prof.Rollup&lt;/em&gt;什么时候才会把学费打给教务处呢？(Layer-2 到Layer-1 跨链交易的时效性问题)&lt;/li&gt;
  &lt;li&gt;等等..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;就像华山派的剑宗和气宗分家一样，目前，在如何实现Rollup上，主要分为了两大流派，分别是&lt;strong&gt;Optimism-Rollup&lt;/strong&gt;，和&lt;strong&gt;ZK-Rollup&lt;/strong&gt;。两种路线各有所长，又各有不足。&lt;/p&gt;

&lt;h2 id=&quot;optimism-rollup&quot;&gt;Optimism-Rollup&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Optimism
    &lt;ul&gt;
      &lt;li&gt;原Plasma团队的作品，乐观模式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Arbitrum
    &lt;ul&gt;
      &lt;li&gt;乐观模式，Layer-2完全兼容EVM，通过设置挑战时间来保证跨链交易，目前是one week。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;zk-rollup&quot;&gt;ZK-Rollup&lt;/h2&gt;

&lt;p&gt;ZK-Rollup核心是利用了Zero-Knowledge Proof的技术来实现rollup。ZKP里面的细节比较多，在这里我们不展开描述。其中最重要的核心点是ZK-Rollup主要利用了ZK-SNARKs中的可验证性的正确性保障，以及Verification Time相对较快的特性，来保证layer-1上的Miner可以很快的验证大量交易的准确性。&lt;/p&gt;

&lt;p&gt;但是正因为ZKP的一些特性，使得ZK-Rollup相比于Optimism-Rollup，在开发上的并没有进行的那么顺利。&lt;/p&gt;

&lt;p&gt;拿一个应用广泛的ZK-SNARKs协议Groth16举例来说，其计算的基础来自于:&lt;em&gt;将一个计算电路(Circuit)，转化为R1CS的形式&lt;/em&gt;，继而转化为QAP问题，最终将问题的Witness生成零知识的Proof。如果我们想生成一个Problem/Computation/Function的ZK-SNARKs的Witness/Proof，那么首先我们需要要把这个问题转化为一个Circuit的形式。或者说用Circuit的语言，用R1CS的形式来描述原计算问题。对于简单的计算问题来说，比如加减计算，解方程组，将问题转化为电路的形式并不是特别的困难。但是对于Ethereum上各种支持图灵完备的智能合约的function来说这个问题就变得非常的棘手。主要因为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;转化生成的电路是静态的，虽然电路中有可以复用的部分(Garget)，但是每个Problem/Computation/Function都要构造新的电路。&lt;/li&gt;
  &lt;li&gt;对于通用计算问题，构造出来的电路需要的gate数量可能是惊人的高。这意味着ZK-Rollup可能需要非常长的时间来生成Proof。&lt;/li&gt;
  &lt;li&gt;对于目前EVM架构下的某些计算问题，生成其电路是非常困难的。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;附1&lt;/em&gt; 对于Groth16，每个新的电路，都需要一次Setup，成本非常高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两个问题属于General的ZK-SNARKs应用都会遇到的问题，目前已经有一些的研究人员/公司正在尝试解决这个问题。比如AleoHQ的创始人Howard Wu提出的&lt;a href=&quot;https://www.usenix.org/conference/usenixsecurity18/presentation/wu&quot;&gt;DIZK&lt;/a&gt;通过分布式的Cluster来并发计算Proof，以及Scroll的创始人&lt;a href=&quot;https://twitter.com/yezhang1998&quot;&gt;Zhang Ye&lt;/a&gt;，提出的&lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/pipezk-accelerating-zero-knowledge-proof-with-a-pipelined-architecture/&quot;&gt;PipeZK&lt;/a&gt;通过ASIC来加速ZK计算。&lt;/p&gt;

&lt;p&gt;对于第三个问题，属于Ethereum中的专有的问题，也是目前zk-Rollup实现中最难，最需要攻克的问题。我们知道在Ethereum中，一条调用合约Function的Transaction的执行是基于/通过EVM的来执行的。EVM会将Transaction中的函数调用，基于合约代码，转换成opcodes的形式，保存在Stack中逐条执行。这个过程类似于编译过程中的IR代码生成，或者高级语言到汇编语言的过程。在执行这些opcodes时，本质上是在执行geth中对应的库函数，部分细节可以参考之前的&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2021/07/25/ethereum_txn.html&quot;&gt;blog&lt;/a&gt;。那么如果我们想把一个Transaction的合约调用转换成一个电路的话，本质上我们就要基于这个函数调用过程中执行过的opcodes来生成电路。目前的问题是，EVM在设计的时候并没有考虑到将来会被ZK-SNARKs化这一问题。所以，我们不得不面对现实，即EVM中的140个opcode中有些是难以构造电路的。同时Ehereum中大量使用的Keccek256哈希算法，和RLP编码都给构造电路带来了巨大的挑战。&lt;/p&gt;

&lt;p&gt;结果就是，在目前的ZK-Rollup的解决方案中，大部分&lt;strong&gt;仅支持基础的转账操作&lt;/strong&gt;，而&lt;strong&gt;不能支持&lt;/strong&gt;通用的图灵完备的计算。也就是说，目前的ZK-Rollup的解决方案都是不完整的，不能完整的发挥Ethereum图灵完备合约的特性，Layer-2又回到了仅支持Token转账的时代。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，使得Layer-2能支持像现在的Layer-1一样的功能，目前的技术主要在朝向两个方向发展，1. 构建ZK-SNARKs兼容的zkEVM，2.提出新的VM来兼容ZK-SNARKs，并想办法与Ethereum兼容。&lt;/p&gt;

&lt;h3 id=&quot;构建兼容evm的zkevm&quot;&gt;构建兼容EVM的zkEVM&lt;/h3&gt;

&lt;p&gt;这种方案好处在于，开发人员可以继续使用Solidity来构建智能合约。如何构造电路，完全交给底层的ZK-EVM来完成。ZK-EVM和现有的EVM是完全兼容的，现有的Ethereum Contract都可以直接移植到Layer-2上来使用。这种方案对现有的以太坊生态圈非常的友好，社区的合约开发人员在开发时，不需要学习什么额外的新知识，零门槛上手。&lt;/p&gt;

&lt;p&gt;这种方案的难点在于如何把现有的EVM, OPcode抽象成电路。目前正在研究这个路线的有下面两个团队，Scroll和Polygon Hermez。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scroll
    &lt;ul&gt;
      &lt;li&gt;通用zkEVM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://docs.hermez.io/#start-here-for-hermez-10-documentation&quot;&gt;Polygon Hermez&lt;/a&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;Hermez 1.0: Support Ethereum Token transfer.&lt;/li&gt;
          &lt;li&gt;Hermez 2.0: Recreating all the EVM opcodes (Seem they have the same goal with Scroll).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;提出新的vm编程语言&quot;&gt;提出新的VM/编程语言&lt;/h3&gt;

&lt;p&gt;这种方案完全甩开了EVM的包袱，重新设计对ZK友好的VM以及对应的Programming Language。由于没有了包袱，所以这种方案开发起来比较快，目前进展最快的应该是StareWare团队开发的Cairo语言。&lt;/p&gt;

&lt;p&gt;但是基于这种解决方案Zk-Rollup，不能在Layer-2上直接使用Layer-1上已经编写好的Solidity合约。需要合约开发人员重新学习一门新的语言来重新编写合约。或者会将Solidity转译成另一种语言，但是可能有些语法无法兼容。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;StareWare&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;专用语言: &lt;a href=&quot;https://cairo-lang.org/docs/&quot;&gt;Cairo&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;StarkNet uses the Cairo programing language both for infrastructure and for writing StarkNet contracts.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;专用硬件加速Proof生成&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Zksync&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;专用合约编程语言: &lt;a href=&quot;https://github.com/matter-labs/zinc&quot;&gt;Zinc&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;语法很像Rust&lt;/li&gt;
              &lt;li&gt;没有写自己编译器，使用的LLVM作为编译的前端和后端。&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;SyncVM&lt;/li&gt;
          &lt;li&gt;专用硬件加速Proof生成(FPGA)&lt;/li&gt;
          &lt;li&gt;Proof System: &lt;a href=&quot;https://eprint.iacr.org/2019/953&quot;&gt;PLONK&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Con’t
        &lt;ul&gt;
          &lt;li&gt;并不支持所有EVM opcodes&lt;/li&gt;
          &lt;li&gt;支持部分的L1上的Solidity的合约直接使用，但是如果合约中涉及到SHA256 and Keccak256会被编译器直接修改会其他电路友好的哈希函数。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;一些思考&quot;&gt;一些思考&lt;/h3&gt;

&lt;p&gt;从我个人的角度来说，提出新的VM/编程语言的方案不能算非常友好的。首先以太坊社区在Solidity生态建设方面已经做的非常的完善，有大量的已经审计过的合约可供开发人员参考，有大量的生产工具可供使用。对于智能合约来说，由于其代码部分不可修改的特性，合约安全是至关重要的。重新构造一个新的编程语言环境下的合约社区是非常困难的。第二，现在需要学习一门新语言的成本太高了，尤其是学习相比C++/Java/Python更加小众的智能合约开发语言。新的编程语言，为了不和现有的开发语言完全一致而设计的新的语法，语法糖，很容易让开发人员头大。在社区还不够成熟之前，很难吸引到足够多有能力的开发人员。&lt;/p&gt;

&lt;p&gt;所以我更看好类似Scroll/Polygon Hermez这种Layer-2项目的发展。&lt;/p&gt;

&lt;h3 id=&quot;其他zk-related-project&quot;&gt;其他ZK-Related Project&lt;/h3&gt;

&lt;p&gt;在阅读资料时发现的一个项目AleoHQ，看上去是一个原生支持ZKP的图灵完备的新的公链项目，由Berkeley的团队开发。Founder Howard Wu实力很强，是最早的Libsnarks的开发者之一。具体的细节我还在了解之中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/AleoHQ&quot;&gt;AleoHQ&lt;/a&gt;&lt;/strong&gt;, Developed by Howard Wu (UC Berkeley)
    &lt;ul&gt;
      &lt;li&gt;General
        &lt;ul&gt;
          &lt;li&gt;Aleo is the first decentralized, open-source platform to enable both private and programmable applications.&lt;/li&gt;
          &lt;li&gt;Strong privacy guarantees.&lt;/li&gt;
          &lt;li&gt;专用语言: &lt;a href=&quot;https://github.com/AleoHQ/leo&quot;&gt;Leo&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;Leo converts a developer’s high-level code into zero knowledge circuits.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;snarkOS:
            &lt;ul&gt;
              &lt;li&gt;Aleo runs on a decentralized operating system for private applications called snarkOS. (&lt;em&gt;HAN:Seems like zkGeth?&lt;/em&gt;)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Core Part: ZEXE (Zero Knowledge EXEcution)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;related-papers&quot;&gt;Related Papers&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Zexe: Enabling Decentralized Private Computation, &lt;a href=&quot;https://eprint.iacr.org/2018/962.pdf&quot;&gt;[Paper link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;DIZK: A Distributed Zero Knowledge Proof System, &lt;a href=&quot;https://www.usenix.org/conference/usenixsecurity18/presentation/wu&quot;&gt;[Paper link]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;EIP-1559: Fee market change for ETH 1.0 chain, &lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;gnark zk-SNARK library (go), &lt;a href=&quot;https://github.com/ConsenSys/gnark&quot;&gt;[Codebase]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;A specification for a ZK-EVM, &lt;a href=&quot;https://ethresear.ch/t/a-zk-evm-specification/11549&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;zkEVM, Zhang Ye, &lt;a href=&quot;https://hackmd.io/@yezhang/S1_KMMbGt&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="ZKP" /><category term="Layer-2" /><category term="Rollup" /><category term="zk-Rollup" /><summary type="html">自从EIP-1559生效后，由于币价的升高，和基础Gas Price的约束，Ethereum Mainnet上的单笔交易费用已经高到了离谱的程度。在上个月的一次实验中，我尝试了一把在Layer-1上调用一次古早的合约，大概花了100美刀左右的交易费。就像社区内经常听到的抱怨声那样，Ethereum Mainnet已经成为了普通用户用不起的贵族链。 显然，目前天价的交易费以及有限的Throughput已经成为了限制Ethereum继续发展的两大难题。幸运的是，rollup技术的发展给社区展现了一种似乎可以一招解决两大难题的绝世武学。 简单的来说，顾名思义，rollup，就是把一堆的transaction rollup到一个新的transaction。然后，通过某种神奇的技术，使得Ethereum Mainnet只需要验证这个新生成的transaction，就可以保证被Rollup之前的若干的Transaction的确定性，正确性，完整性。举个简单的例子，我们想象一个学校内交学费的场景。过去，每个学生(i.e. Account)都需要通过学校交费系统(i.e. Ethereum Mainnet)单独的将自己的学费转账(Transfer)给学校教务处。假如，现在计算机系有1000个学生，那么系统就要处理1000笔转账的交易(Transaction)。现在，系里新来一位叫做Rollup的教授。他在学生中很有号召力。基于他的个人魅力(神奇的魔法)，私下里让所有的的学生把钱通过某种方式先转给他。当Prof.Rollup收集到系里所有学生的学费之后，然后他通过构造一个transaction把所有的学费交给教务处。这个例子大概就是一个Rollup场景的简单抽象。我们把学校的交费系统看作为Ethereum Mainnet 或者说是Layer-1，那么私下里收集学生的学费就是所谓的Layer-2进行的了。通常，我们把Layer-1上的交易称为on-chain transaction，把在Layer-2进行上的交易称为off-chain transaction。 Rollup的好处是显而易见的，假如每次把N个transaction rollup成一个，那么对于Mainnet来说，处理一条交易，实际效果等同于处理了之前系统中的N个交易。同时，系统实际吞吐量的Upper Bound也实际上上市到了N*MAX_TPS的水平。同时，对于用户来说，同样一条交易Mainnet Transaction Fee实际上是被N个用户同时负担的。那么理论上，用户需要的实际交易费用也只有之前的1/N+c。这里的c代表rollup服务提供商收取的交易费，这个值是远远小于layer-1上交易所需要的交易费用的。 Rollup看上去完美的解决了Ethereum面临的两大难题，通过分层的方式给Ethereum进行了扩容。但是，在实现layer-2 rollup时，还是有很多的细节有待商榷。比如: 怎么保证Prof.Rollup一定会把学费交给教务处呢？ (Layer-2 交易的安全性) 怎么保证Prof.Rollup会把全部的学费都交给教务处呢？(Layer-2 交易的完整性) Prof.Rollup什么时候才会把学费打给教务处呢？(Layer-2 到Layer-1 跨链交易的时效性问题) 等等.. 就像华山派的剑宗和气宗分家一样，目前，在如何实现Rollup上，主要分为了两大流派，分别是Optimism-Rollup，和ZK-Rollup。两种路线各有所长，又各有不足。 Optimism-Rollup Optimism 原Plasma团队的作品，乐观模式。 Arbitrum 乐观模式，Layer-2完全兼容EVM，通过设置挑战时间来保证跨链交易，目前是one week。 ZK-Rollup ZK-Rollup核心是利用了Zero-Knowledge Proof的技术来实现rollup。ZKP里面的细节比较多，在这里我们不展开描述。其中最重要的核心点是ZK-Rollup主要利用了ZK-SNARKs中的可验证性的正确性保障，以及Verification Time相对较快的特性，来保证layer-1上的Miner可以很快的验证大量交易的准确性。 但是正因为ZKP的一些特性，使得ZK-Rollup相比于Optimism-Rollup，在开发上的并没有进行的那么顺利。 拿一个应用广泛的ZK-SNARKs协议Groth16举例来说，其计算的基础来自于:将一个计算电路(Circuit)，转化为R1CS的形式，继而转化为QAP问题，最终将问题的Witness生成零知识的Proof。如果我们想生成一个Problem/Computation/Function的ZK-SNARKs的Witness/Proof，那么首先我们需要要把这个问题转化为一个Circuit的形式。或者说用Circuit的语言，用R1CS的形式来描述原计算问题。对于简单的计算问题来说，比如加减计算，解方程组，将问题转化为电路的形式并不是特别的困难。但是对于Ethereum上各种支持图灵完备的智能合约的function来说这个问题就变得非常的棘手。主要因为： 转化生成的电路是静态的，虽然电路中有可以复用的部分(Garget)，但是每个Problem/Computation/Function都要构造新的电路。 对于通用计算问题，构造出来的电路需要的gate数量可能是惊人的高。这意味着ZK-Rollup可能需要非常长的时间来生成Proof。 对于目前EVM架构下的某些计算问题，生成其电路是非常困难的。 附1 对于Groth16，每个新的电路，都需要一次Setup，成本非常高。 前两个问题属于General的ZK-SNARKs应用都会遇到的问题，目前已经有一些的研究人员/公司正在尝试解决这个问题。比如AleoHQ的创始人Howard Wu提出的DIZK通过分布式的Cluster来并发计算Proof，以及Scroll的创始人Zhang Ye，提出的PipeZK通过ASIC来加速ZK计算。 对于第三个问题，属于Ethereum中的专有的问题，也是目前zk-Rollup实现中最难，最需要攻克的问题。我们知道在Ethereum中，一条调用合约Function的Transaction的执行是基于/通过EVM的来执行的。EVM会将Transaction中的函数调用，基于合约代码，转换成opcodes的形式，保存在Stack中逐条执行。这个过程类似于编译过程中的IR代码生成，或者高级语言到汇编语言的过程。在执行这些opcodes时，本质上是在执行geth中对应的库函数，部分细节可以参考之前的blog。那么如果我们想把一个Transaction的合约调用转换成一个电路的话，本质上我们就要基于这个函数调用过程中执行过的opcodes来生成电路。目前的问题是，EVM在设计的时候并没有考虑到将来会被ZK-SNARKs化这一问题。所以，我们不得不面对现实，即EVM中的140个opcode中有些是难以构造电路的。同时Ehereum中大量使用的Keccek256哈希算法，和RLP编码都给构造电路带来了巨大的挑战。 结果就是，在目前的ZK-Rollup的解决方案中，大部分仅支持基础的转账操作，而不能支持通用的图灵完备的计算。也就是说，目前的ZK-Rollup的解决方案都是不完整的，不能完整的发挥Ethereum图灵完备合约的特性，Layer-2又回到了仅支持Token转账的时代。 为了解决这个问题，使得Layer-2能支持像现在的Layer-1一样的功能，目前的技术主要在朝向两个方向发展，1. 构建ZK-SNARKs兼容的zkEVM，2.提出新的VM来兼容ZK-SNARKs，并想办法与Ethereum兼容。 构建兼容EVM的zkEVM 这种方案好处在于，开发人员可以继续使用Solidity来构建智能合约。如何构造电路，完全交给底层的ZK-EVM来完成。ZK-EVM和现有的EVM是完全兼容的，现有的Ethereum Contract都可以直接移植到Layer-2上来使用。这种方案对现有的以太坊生态圈非常的友好，社区的合约开发人员在开发时，不需要学习什么额外的新知识，零门槛上手。 这种方案的难点在于如何把现有的EVM, OPcode抽象成电路。目前正在研究这个路线的有下面两个团队，Scroll和Polygon Hermez。 Scroll 通用zkEVM Polygon Hermez General Hermez 1.0: Support Ethereum Token transfer. Hermez 2.0: Recreating all the EVM opcodes (Seem they have the same goal with Scroll). 提出新的VM/编程语言 这种方案完全甩开了EVM的包袱，重新设计对ZK友好的VM以及对应的Programming Language。由于没有了包袱，所以这种方案开发起来比较快，目前进展最快的应该是StareWare团队开发的Cairo语言。 但是基于这种解决方案Zk-Rollup，不能在Layer-2上直接使用Layer-1上已经编写好的Solidity合约。需要合约开发人员重新学习一门新的语言来重新编写合约。或者会将Solidity转译成另一种语言，但是可能有些语法无法兼容。 StareWare General 专用语言: Cairo StarkNet uses the Cairo programing language both for infrastructure and for writing StarkNet contracts. 专用硬件加速Proof生成 Zksync General 专用合约编程语言: Zinc 语法很像Rust 没有写自己编译器，使用的LLVM作为编译的前端和后端。 SyncVM 专用硬件加速Proof生成(FPGA) Proof System: PLONK Con’t 并不支持所有EVM opcodes 支持部分的L1上的Solidity的合约直接使用，但是如果合约中涉及到SHA256 and Keccak256会被编译器直接修改会其他电路友好的哈希函数。 一些思考 从我个人的角度来说，提出新的VM/编程语言的方案不能算非常友好的。首先以太坊社区在Solidity生态建设方面已经做的非常的完善，有大量的已经审计过的合约可供开发人员参考，有大量的生产工具可供使用。对于智能合约来说，由于其代码部分不可修改的特性，合约安全是至关重要的。重新构造一个新的编程语言环境下的合约社区是非常困难的。第二，现在需要学习一门新语言的成本太高了，尤其是学习相比C++/Java/Python更加小众的智能合约开发语言。新的编程语言，为了不和现有的开发语言完全一致而设计的新的语法，语法糖，很容易让开发人员头大。在社区还不够成熟之前，很难吸引到足够多有能力的开发人员。 所以我更看好类似Scroll/Polygon Hermez这种Layer-2项目的发展。 其他ZK-Related Project 在阅读资料时发现的一个项目AleoHQ，看上去是一个原生支持ZKP的图灵完备的新的公链项目，由Berkeley的团队开发。Founder Howard Wu实力很强，是最早的Libsnarks的开发者之一。具体的细节我还在了解之中。 AleoHQ, Developed by Howard Wu (UC Berkeley) General Aleo is the first decentralized, open-source platform to enable both private and programmable applications. Strong privacy guarantees. 专用语言: Leo Leo converts a developer’s high-level code into zero knowledge circuits. snarkOS: Aleo runs on a decentralized operating system for private applications called snarkOS. (HAN:Seems like zkGeth?) Core Part: ZEXE (Zero Knowledge EXEcution) Related Papers Zexe: Enabling Decentralized Private Computation, [Paper link] DIZK: A Distributed Zero Knowledge Proof System, [Paper link] Reference EIP-1559: Fee market change for ETH 1.0 chain, [link] gnark zk-SNARK library (go), [Codebase] A specification for a ZK-EVM, [link] zkEVM, Zhang Ye, [link]</summary></entry><entry><title type="html">理解以太坊Go-Ethereum 源码剖析(02): 一个Ethereum Transaction的生老病死</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn.html" rel="alternate" type="text/html" title="理解以太坊Go-Ethereum 源码剖析(02): 一个Ethereum Transaction的生老病死" /><published>2022-01-03T10:00:00+08:00</published><updated>2022-01-03T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn.html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html&quot;&gt;Account章节&lt;/a&gt;的开头，我们提到了，Ethereum的运行依赖于基于交易的状态机模型(Transaction-based State Machine)。本章我们就来探索一下，Ethereum中的另一个基本数据单元Transaction。在本文中，我们提到的交易指的是在Ethereum Layer-1层面上构造的交易，以太坊生态中的Layer-2中的交易不在我们的讨论中。&lt;/p&gt;

&lt;p&gt;Transaction是Ethereum执行数据操作的媒介。它主要起到下面的几个作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在Layer-1网络上的Account之间进行Native Token的转账。&lt;/li&gt;
  &lt;li&gt;创建新的Contract。&lt;/li&gt;
  &lt;li&gt;调用Contract中会修改目标Contract中持久化数据或者间接修改其他Account/Contract数据的函数。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里我们对Transaction功能性的细节再进行额外的补充说明。首先，Transaction只能创建Contract账户，而不能用于创建外部账户(EOA)。其次，关于Transaction的第三个作用我们使用了很长的定语进行说明，这里是为了强调，如果调用的Contract函数只进行了查询的操作，是不需要构造依赖Transaction的。总结下来，所有参与Account/Contract数据修改的操作都需要通过Transaction来进行。第三，广义上的Transaction只能由外部账户(EOA)构建。Contract是没有办法显式构造Layer-1层面的交易的。在某些合约函数的执行过程中，Contract在可以通过构造internal transaction来与其他的合约进行交互，但是这种Internal transaction与我们提到的Layer-1层面的交易有所不同，我们会在之后的章节介绍。&lt;/p&gt;

&lt;h2 id=&quot;legacytx--accesslisttx--dynamicfeetx&quot;&gt;LegacyTx &amp;amp; AccessListTX &amp;amp; DynamicFeeTx&lt;/h2&gt;

&lt;p&gt;下面我们根据源代码中的Transaction的定义来了解一下Transaction的数据结构。Transaction结构体的定义位于&lt;em&gt;core/types/transaction.go&lt;/em&gt;中。Transaction的结构体如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxData&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Consensus contents of a transaction&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Time first seen locally (spam avoidance)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// caches&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从代码定义中我们可以看到，Transaction的结构体是非常简单的结构，它只包含了五个变量分别是, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TxData&lt;/code&gt;类型的inner，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Time&lt;/code&gt;类型的time，以及三个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic.Value&lt;/code&gt;类型的hash，size，以及from。这里我们需要重点关注一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inner&lt;/code&gt;这个变量。目前与Transaction直接相关的数据大部分都保存在了这个变量总。&lt;/p&gt;

&lt;p&gt;目前，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TxData&lt;/code&gt;类型是一个接口，它的定义如下面的代码所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxData&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// returns the type ID&lt;/span&gt;
 &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TxData&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// creates a deep copy and initializes all fields&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;chainID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;accessList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasPrice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasTipCap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasFeeCap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;nonce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;rawSignatureValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;setSignatureValues&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里注意，在目前版本的geth中(1.10.*)，根据&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-2718&quot;&gt;EIP-2718&lt;/a&gt;的设计，原来的TxData现在被声明成了一个interface，而不是定义了具体的结构。这样的设计好处在于，后续版本的更新中可以对Transaction类型进行更加灵活的修改。目前，在Ethereum中定义了三种类型的Transaction来实现TxData这个接口。按照时间上的定义顺序来说，这三种类型的Transaction分别是，LegacyT，AccessListTx，TxDynamicFeeTx。LegacyTx顾名思义，是原始的Ethereum的Transaction设计，目前市面上大部分早年关于Ethereum Transaction结构的文档实际上都是在描述LegacyTx的结构。而AccessListTX是基于EIP-2930(Berlin分叉)的Transaction。DynamicFeeTx是&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;EIP-1559&lt;/a&gt;(伦敦分叉)生效之后的默认的Transaction。&lt;/p&gt;

&lt;p&gt;(PS:目前Ethereum的黄皮书只更新到了Berlin分叉的内容，还没有添加London分叉的更新, 2022.3.10)&lt;/p&gt;

&lt;h3 id=&quot;legacytx&quot;&gt;LegacyTx&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LegacyTx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// nonce of sender account&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasPrice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei per gas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// gas limit&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;To&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`rlp:&quot;nil&quot;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// nil means contract creation&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei amount&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// contract invocation input data&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// signature values&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;accesslisttx&quot;&gt;AccessListTX&lt;/h3&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessListTx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ChainID&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// destination chain ID&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// nonce of sender account&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasPrice&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei per gas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// gas limit&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;To&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`rlp:&quot;nil&quot;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// nil means contract creation&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// wei amount&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// contract invocation input data&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// EIP-2930 access list&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// signature values&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dynamicfeetx&quot;&gt;DynamicFeeTx&lt;/h3&gt;

&lt;p&gt;如果我们观察DynamicFeeTx就会发现，DynamicFeeTx的定义其实就是在LegacyTx/AccessListTX的定义的基础上额外的增加了GasTipCap与GasFeeCap这两个字段。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DynamicFeeTx&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ChainID&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;      &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasTipCap&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// a.k.a. maxPriorityFeePerGas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;GasFeeCap&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// a.k.a. maxFeePerGas&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;To&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`rlp:&quot;nil&quot;`&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// nil means contract creation&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AccessList&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Signature values&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`json:&quot;v&quot; gencodec:&quot;required&quot;`&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`json:&quot;r&quot; gencodec:&quot;required&quot;`&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;`json:&quot;s&quot; gencodec:&quot;required&quot;`&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;transaction修改合约中的值的&quot;&gt;Transaction修改合约中的值的&lt;/h2&gt;

&lt;p&gt;一个Transaction的执行，可以更新一个或多个Account的State的。Miner负责将一个或多个Transaction被打包到一个block中，并按照顺序执行他们。顺序执行的结构会被finalise成一个新的World State，并最终被保存到World State Trie中。这个过程成为World State的状态转移。&lt;/p&gt;

&lt;p&gt;在Ethereum中，当Miner开始构造新的区块的时候，首先会启动&lt;em&gt;miner/worker.go&lt;/em&gt;的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mainLoop()&lt;/code&gt;函数。具体的函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mainLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 设置接受该区块中挖矿奖励的账户地址&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RUnlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transactions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Txs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 这里看到，通过NewTransactionsByPriceAndNonce获取一部分的Tx并打包&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;txset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTransactionsByPriceAndNonce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseFee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tcount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tcount&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//提交打包任务&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commitTransactions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;        
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Mining新区块前，Worker首先需要决定，那些Transaction会被打包到新的Block中。这里选取Transaction其实经历了两个步骤。首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;txs&lt;/code&gt;变量保存了从Transaction Pool中拿去到的合法的，以及准备好被打包的交易。这里举一个例子，来说明什么是&lt;strong&gt;准备好被打包的交易&lt;/strong&gt;，比如Alice先后发了新三个交易到网络中，对应的Nonce分别是100和101，102。假如Miner只收到了100和102号交易。那么对于此刻的Transaction Pool来说Nonce 100的交易就是&lt;strong&gt;准备好被打包的交易&lt;/strong&gt;，交易Nonce 是102需要等待Nonce 101的交易被确认之后才能提交。&lt;/p&gt;

&lt;p&gt;在Worker会从Transaction Pool中拿出若干的transaction, 赋值给&lt;em&gt;txs&lt;/em&gt;之后, 然后调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NewTransactionsByPriceAndNonce&lt;/code&gt;函数按照Gas Price和Nonce对&lt;em&gt;txs&lt;/em&gt;进行排序，并将结果赋值给&lt;em&gt;txset&lt;/em&gt;。在拿到&lt;em&gt;txset&lt;/em&gt;之后，mainLoop函数会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransactions&lt;/code&gt;函数，正式进入Mining新区块的流程。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransactions&lt;/code&gt;函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commitTransactions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TransactionsByPriceAndNonce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interrupt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// 首先给Block设置最大可以使用的Gas的上限&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gasLimit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasLimit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasLimit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 函数的主体是一个For循环&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.....&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// params.TxGas表示了transaction 需要的最少的Gas的数量&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// w.current.gasPool.Gas()可以获取当前block剩余可以用的Gas的Quota，如果剩余的Gas足以开启一个新的Tx，那么循环结束&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxGas&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Trace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Not enough gas for further transactions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;have&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;want&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;txs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 提交单条Transaction 进行验证&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commitTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransactions&lt;/code&gt;函数的主体是一个for循环，每次获取结构体切片头部的txs.Peek()的transaction，并作为参数调用函数miner/worker.go的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransaction()&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commitTransaction()&lt;/code&gt;函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;worker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commitTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 在每次commitTransaction执行前都要记录当前StateDB的Snapshot,一旦交易执行失败则基于这个Snapshot进行回滚。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// TODO StateDB如何进行快照(Snapshot)和回滚的&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;snap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Snapshot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 调用执行Transaction的函数&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApplyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coinbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasUsed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetVMConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Blockchain系统中的Transaction和DBMS中的Transaction一样，要么完成要么失败。所以在调用执行Transaction的函数前，首先记录了一下当前world state的Snapshot，用于交易失败时回滚操作。之后调用core/state_processor.go/ApplyTransaction()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApplyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChainContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cfg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 将Transaction 转化为Message的形式&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MakeSigner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseFee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Create a new context to be used in the EVM environment&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;blockContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewEVMBlockContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vmenv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewEVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blockContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cfg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 调用执行Contract的函数&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmenv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 ApplyTransaction()函数中首先Transaction会被转换成Message的形式。在执行每一个Transaction的时候，都会生成一个新的EVM来执行。之后调用core/state_processor.go/applyTransaction()函数来执行Message。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChainContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockHash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Apply the transaction to the current state (included in the env).&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApplyMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/state_transition.go/ApplyMessage()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApplyMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewStateTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TransitionDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/state_transition.go/TransitionDb()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransitionDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmerr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/vm/evm.go/Call()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caller&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ContractRef&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gas&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftOverGas&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Execute the contract&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interpreter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后调用core/vm/interpreter.go/Run()函数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Run loops and evaluates the contract&apos;s code with the given input data and returns&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// the return byte-slice and an error if one occurred.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVMInterpreter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cost&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constantGas&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// For tracing&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// UseGas 函数：当前剩余的gas quota减去input 参数。&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 剩余的gas 小于input直接返回false&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 否则当前的gas quota减去input并返回true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UseGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;constantGas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ErrOutOfGas&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// execute the operation&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在更细粒度的对每个opcode循环调用core/vm/jump_table.go中的execute函数。这里值得一提的是，获取Contract中每条Operate的方式，是从Contact中的code数组中按照第n个拿取。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// GetOp returns the n&apos;th element in the contract&apos;s byte array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetOp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpCode&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OpCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetByte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// GetByte returns the n&apos;th byte in the contract&apos;s byte array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetByte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;OPCODE的具体实现代码位于core/vm/instructor.go文件中。比如，对Contract中持久化数据修改的OPSSTORE指令的实现位于opStore()函数中。而opStore的函数的具体操作又是调用了StateDB中的SetState函数，将Go-ethereum中的几个主要的模块串联了起来。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opSstore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interpreter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVMInterpreter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ScopeContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;//根据指令跟地址来修改StateDB中某一存储位置的值。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;interpreter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bytes32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bytes32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;//core/state/stateDB&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetOrNewStateObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样就完成了，一个新区块的形成过程中，Transaction如何修改StateDB的Workflow。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;commitTransactions -» commitTransaction -» ApplyTransaction -» applyTransaction -»  ApplyMessage -» TransactionDB -» Call  -» Run -» opSstore -» StateDB -» StateObject -» Key-Value-Trie&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- ![Transaction Execution Flow](../figs/02/tx_execu_flow.png) --&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.codenong.com/cs105936343/&quot;&gt;https://www.codenong.com/cs105936343/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yangzhe.me/2019/08/12/ethereum-evm/&quot;&gt;https://yangzhe.me/2019/08/12/ethereum-evm/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">概述 在Account章节的开头，我们提到了，Ethereum的运行依赖于基于交易的状态机模型(Transaction-based State Machine)。本章我们就来探索一下，Ethereum中的另一个基本数据单元Transaction。在本文中，我们提到的交易指的是在Ethereum Layer-1层面上构造的交易，以太坊生态中的Layer-2中的交易不在我们的讨论中。 Transaction是Ethereum执行数据操作的媒介。它主要起到下面的几个作用: 在Layer-1网络上的Account之间进行Native Token的转账。 创建新的Contract。 调用Contract中会修改目标Contract中持久化数据或者间接修改其他Account/Contract数据的函数。 这里我们对Transaction功能性的细节再进行额外的补充说明。首先，Transaction只能创建Contract账户，而不能用于创建外部账户(EOA)。其次，关于Transaction的第三个作用我们使用了很长的定语进行说明，这里是为了强调，如果调用的Contract函数只进行了查询的操作，是不需要构造依赖Transaction的。总结下来，所有参与Account/Contract数据修改的操作都需要通过Transaction来进行。第三，广义上的Transaction只能由外部账户(EOA)构建。Contract是没有办法显式构造Layer-1层面的交易的。在某些合约函数的执行过程中，Contract在可以通过构造internal transaction来与其他的合约进行交互，但是这种Internal transaction与我们提到的Layer-1层面的交易有所不同，我们会在之后的章节介绍。 LegacyTx &amp;amp; AccessListTX &amp;amp; DynamicFeeTx 下面我们根据源代码中的Transaction的定义来了解一下Transaction的数据结构。Transaction结构体的定义位于core/types/transaction.go中。Transaction的结构体如下所示。 type Transaction struct { inner TxData // Consensus contents of a transaction time time.Time // Time first seen locally (spam avoidance) // caches hash atomic.Value size atomic.Value from atomic.Value } 从代码定义中我们可以看到，Transaction的结构体是非常简单的结构，它只包含了五个变量分别是, TxData类型的inner，Time类型的time，以及三个atomic.Value类型的hash，size，以及from。这里我们需要重点关注一下inner这个变量。目前与Transaction直接相关的数据大部分都保存在了这个变量总。 目前，TxData类型是一个接口，它的定义如下面的代码所示。 type TxData interface { txType() byte // returns the type ID copy() TxData // creates a deep copy and initializes all fields chainID() *big.Int accessList() AccessList data() []byte gas() uint64 gasPrice() *big.Int gasTipCap() *big.Int gasFeeCap() *big.Int value() *big.Int nonce() uint64 to() *common.Address rawSignatureValues() (v, r, s *big.Int) setSignatureValues(chainID, v, r, s *big.Int) } 这里注意，在目前版本的geth中(1.10.*)，根据EIP-2718的设计，原来的TxData现在被声明成了一个interface，而不是定义了具体的结构。这样的设计好处在于，后续版本的更新中可以对Transaction类型进行更加灵活的修改。目前，在Ethereum中定义了三种类型的Transaction来实现TxData这个接口。按照时间上的定义顺序来说，这三种类型的Transaction分别是，LegacyT，AccessListTx，TxDynamicFeeTx。LegacyTx顾名思义，是原始的Ethereum的Transaction设计，目前市面上大部分早年关于Ethereum Transaction结构的文档实际上都是在描述LegacyTx的结构。而AccessListTX是基于EIP-2930(Berlin分叉)的Transaction。DynamicFeeTx是EIP-1559(伦敦分叉)生效之后的默认的Transaction。 (PS:目前Ethereum的黄皮书只更新到了Berlin分叉的内容，还没有添加London分叉的更新, 2022.3.10) LegacyTx type LegacyTx struct { Nonce uint64 // nonce of sender account GasPrice *big.Int // wei per gas Gas uint64 // gas limit To *common.Address `rlp:&quot;nil&quot;` // nil means contract creation Value *big.Int // wei amount Data []byte // contract invocation input data V, R, S *big.Int // signature values } AccessListTX type AccessListTx struct { ChainID *big.Int // destination chain ID Nonce uint64 // nonce of sender account GasPrice *big.Int // wei per gas Gas uint64 // gas limit To *common.Address `rlp:&quot;nil&quot;` // nil means contract creation Value *big.Int // wei amount Data []byte // contract invocation input data AccessList AccessList // EIP-2930 access list V, R, S *big.Int // signature values } DynamicFeeTx 如果我们观察DynamicFeeTx就会发现，DynamicFeeTx的定义其实就是在LegacyTx/AccessListTX的定义的基础上额外的增加了GasTipCap与GasFeeCap这两个字段。 type DynamicFeeTx struct { ChainID *big.Int Nonce uint64 GasTipCap *big.Int // a.k.a. maxPriorityFeePerGas GasFeeCap *big.Int // a.k.a. maxFeePerGas Gas uint64 To *common.Address `rlp:&quot;nil&quot;` // nil means contract creation Value *big.Int Data []byte AccessList AccessList // Signature values V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;` R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;` S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;` } Transaction修改合约中的值的 一个Transaction的执行，可以更新一个或多个Account的State的。Miner负责将一个或多个Transaction被打包到一个block中，并按照顺序执行他们。顺序执行的结构会被finalise成一个新的World State，并最终被保存到World State Trie中。这个过程成为World State的状态转移。 在Ethereum中，当Miner开始构造新的区块的时候，首先会启动miner/worker.go的 mainLoop()函数。具体的函数如下所示。 func (w *worker) mainLoop() { .... // 设置接受该区块中挖矿奖励的账户地址 coinbase := w.coinbase w.mu.RUnlock() txs := make(map[common.Address]types.Transactions) for _, tx := range ev.Txs { acc, _ := types.Sender(w.current.signer, tx) txs[acc] = append(txs[acc], tx) } // 这里看到，通过NewTransactionsByPriceAndNonce获取一部分的Tx并打包 txset := types.NewTransactionsByPriceAndNonce(w.current.signer, txs, w.current.header.BaseFee) tcount := w.current.tcount //提交打包任务 w.commitTransactions(txset, coinbase, nil) .... } 在Mining新区块前，Worker首先需要决定，那些Transaction会被打包到新的Block中。这里选取Transaction其实经历了两个步骤。首先，txs变量保存了从Transaction Pool中拿去到的合法的，以及准备好被打包的交易。这里举一个例子，来说明什么是准备好被打包的交易，比如Alice先后发了新三个交易到网络中，对应的Nonce分别是100和101，102。假如Miner只收到了100和102号交易。那么对于此刻的Transaction Pool来说Nonce 100的交易就是准备好被打包的交易，交易Nonce 是102需要等待Nonce 101的交易被确认之后才能提交。 在Worker会从Transaction Pool中拿出若干的transaction, 赋值给txs之后, 然后调用NewTransactionsByPriceAndNonce函数按照Gas Price和Nonce对txs进行排序，并将结果赋值给txset。在拿到txset之后，mainLoop函数会调用commitTransactions函数，正式进入Mining新区块的流程。commitTransactions函数如下所示。 func (w *worker) commitTransactions(txs *types.TransactionsByPriceAndNonce, coinbase common.Address, interrupt *int32) bool { .... // 首先给Block设置最大可以使用的Gas的上限 gasLimit := w.current.header.GasLimit if w.current.gasPool == nil { w.current.gasPool = new(core.GasPool).AddGas(gasLimit) // 函数的主体是一个For循环 for{ ..... // params.TxGas表示了transaction 需要的最少的Gas的数量 // w.current.gasPool.Gas()可以获取当前block剩余可以用的Gas的Quota，如果剩余的Gas足以开启一个新的Tx，那么循环结束 if w.current.gasPool.Gas() &amp;lt; params.TxGas { log.Trace(&quot;Not enough gas for further transactions&quot;, &quot;have&quot;, w.current.gasPool, &quot;want&quot;, params.TxGas)break } .... tx := txs.Peek() if tx == nil { break } .... // 提交单条Transaction 进行验证 logs, err := w.commitTransaction(tx, coinbase) .... } } commitTransactions函数的主体是一个for循环，每次获取结构体切片头部的txs.Peek()的transaction，并作为参数调用函数miner/worker.go的commitTransaction()。commitTransaction()函数如下所示。 func (w *worker) commitTransaction(tx *types.Transaction, coinbase common.Address) ([]*types.Log, error){ // 在每次commitTransaction执行前都要记录当前StateDB的Snapshot,一旦交易执行失败则基于这个Snapshot进行回滚。 // TODO StateDB如何进行快照(Snapshot)和回滚的 snap := w.current.state.Snapshot() // 调用执行Transaction的函数 receipt, err := core.ApplyTransaction(w.chainConfig, w.chain, &amp;amp;coinbase, w.current.gasPool, w.current.state, w.current.header, tx, &amp;amp;w.current.header.GasUsed, *w.chain.GetVMConfig()) .... } Blockchain系统中的Transaction和DBMS中的Transaction一样，要么完成要么失败。所以在调用执行Transaction的函数前，首先记录了一下当前world state的Snapshot，用于交易失败时回滚操作。之后调用core/state_processor.go/ApplyTransaction()函数。 func ApplyTransaction(config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, header *types.Header, tx *types.Transaction, usedGas *uint64, cfg vm.Config) (*types.Receipt, error) { // 将Transaction 转化为Message的形式 msg, err := tx.AsMessage(types.MakeSigner(config, header.Number), header.BaseFee) if err != nil { return nil, err } // Create a new context to be used in the EVM environment blockContext := NewEVMBlockContext(header, bc, author) vmenv := vm.NewEVM(blockContext, vm.TxContext{}, statedb, config, cfg) // 调用执行Contract的函数 return applyTransaction(msg, config, bc, author, gp, statedb, header.Number, header.Hash(), tx, usedGas, vmenv) } 在 ApplyTransaction()函数中首先Transaction会被转换成Message的形式。在执行每一个Transaction的时候，都会生成一个新的EVM来执行。之后调用core/state_processor.go/applyTransaction()函数来执行Message。 func applyTransaction(msg types.Message, config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, blockNumber *big.Int, blockHash common.Hash, tx *types.Transaction, usedGas *uint64, evm *vm.EVM) (*types.Receipt, error) { .... // Apply the transaction to the current state (included in the env). result, err := ApplyMessage(evm, msg, gp) .... } 之后调用core/state_transition.go/ApplyMessage()函数。 func ApplyMessage(evm *vm.EVM, msg Message, gp *GasPool) (*ExecutionResult, error) { return NewStateTransition(evm, msg, gp).TransitionDb() } 之后调用core/state_transition.go/TransitionDb()函数。 func (st *StateTransition) TransitionDb() (*ExecutionResult, error) { .... ret, st.gas, vmerr = st.evm.Call(sender, st.to(), st.data, st.gas, st.value) .... } 之后调用core/vm/evm.go/Call()函数。 func (evm *EVM) Call(caller ContractRef, addr common.Address, input []byte, gas uint64, value *big.Int) (ret []byte, leftOverGas uint64, err error) { .... // Execute the contract ret, err = evm.interpreter.Run(contract, input, false) .... } 之后调用core/vm/interpreter.go/Run()函数。 // Run loops and evaluates the contract&apos;s code with the given input data and returns // the return byte-slice and an error if one occurred. func (in *EVMInterpreter) Run(contract *Contract, input []byte, readOnly bool) (ret []byte, err error) { .... cost = operation.constantGas // For tracing // UseGas 函数：当前剩余的gas quota减去input 参数。 // 剩余的gas 小于input直接返回false // 否则当前的gas quota减去input并返回true if !contract.UseGas(operation.constantGas) { return nil, ErrOutOfGas } .... // execute the operation res, err = operation.execute(&amp;amp;pc, in, callContext) .... } 在更细粒度的对每个opcode循环调用core/vm/jump_table.go中的execute函数。这里值得一提的是，获取Contract中每条Operate的方式，是从Contact中的code数组中按照第n个拿取。 // GetOp returns the n&apos;th element in the contract&apos;s byte array func (c *Contract) GetOp(n uint64) OpCode { return OpCode(c.GetByte(n)) } // GetByte returns the n&apos;th byte in the contract&apos;s byte array func (c *Contract) GetByte(n uint64) byte { if n &amp;lt; uint64(len(c.Code)) { return c.Code[n] } return 0 } OPCODE的具体实现代码位于core/vm/instructor.go文件中。比如，对Contract中持久化数据修改的OPSSTORE指令的实现位于opStore()函数中。而opStore的函数的具体操作又是调用了StateDB中的SetState函数，将Go-ethereum中的几个主要的模块串联了起来。 func opSstore(pc *uint64, interpreter *EVMInterpreter, scope *ScopeContext) ([]byte, error) { loc := scope.Stack.pop() val := scope.Stack.pop() //根据指令跟地址来修改StateDB中某一存储位置的值。 interpreter.evm.StateDB.SetState(scope.Contract.Address(),loc.Bytes32(), val.Bytes32()) return nil, nil } //core/state/stateDB func (s *StateDB) SetState(addr common.Address, key, value common.Hash) { stateObject := s.GetOrNewStateObject(addr) if stateObject != nil { stateObject.SetState(s.db, key, value) } } 这样就完成了，一个新区块的形成过程中，Transaction如何修改StateDB的Workflow。 commitTransactions -» commitTransaction -» ApplyTransaction -» applyTransaction -» ApplyMessage -» TransactionDB -» Call -» Run -» opSstore -» StateDB -» StateObject -» Key-Value-Trie Reference https://www.codenong.com/cs105936343/ https://yangzhe.me/2019/08/12/ethereum-evm/</summary></entry><entry><title type="html">理解以太坊Go-Ethereum 源码剖析(01): 账户与合约(Account and Contract)</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html" rel="alternate" type="text/html" title="理解以太坊Go-Ethereum 源码剖析(01): 账户与合约(Account and Contract)" /><published>2022-01-02T11:00:00+08:00</published><updated>2022-01-02T11:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;我们常常听到这么一个说法，“Ethereum和Bitcoin最大的不同之一是，Ethereum是基于Account模型的Blockchain系统，而Bitcoin是基于UTXO模型的”。那么，这个另辟蹊径的Account模型究竟不同在何处呢？在本文中我们来探索一下以太坊中的基本数据单元(Metadata)之一的Account。&lt;/p&gt;

&lt;p&gt;我们知道，Ethereum的运行依赖于基于交易的状态机模型(Transaction-based State Machine)。其中，状态(State)指的是数据变量在&lt;em&gt;某一时刻&lt;/em&gt;下的信息。承载State的数据变量，称之为StateObject。当StateObject的数据或信息发生了变化时，我们称为&lt;em&gt;状态转移&lt;/em&gt;。在Ethereum的运行模型中，StateObject所包含的数据会因为Transaction的执行引发的数据更新/删除/创建而发生变化，从而造成状态转移，StateObject的状态会从当前的State转移到另一个State。&lt;/p&gt;

&lt;p&gt;在Ethereum中，StateObject的具体实现就是Account。因此，我们提到的State具体指的就是Account在某个时刻的包含的数据的值。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Account –&amp;gt; StateObject&lt;/li&gt;
  &lt;li&gt;State   –&amp;gt; The value/data of the Account&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总的来说, Account (账户)是参与链上交易(Transaction)的基本角色，是Ethereum状态机模型中的基本单位，承担了链上交易的发起者以及接收者的角色。目前，在以太坊中，有两种类型的Account，分别是外部账户(EOA)以及合约账户(Contract)。&lt;/p&gt;

&lt;h3 id=&quot;eoa&quot;&gt;EOA&lt;/h3&gt;

&lt;p&gt;外部账户(EOA)是由用户直接控制的账户，负责签名并发起交易(Transaction)。用户通过Account的私钥来保证对账户数据的控制权。&lt;/p&gt;

&lt;p&gt;合约账户(Contract)，简称为合约，是由外部账户通过Transaction创建。合约账户，保存了&lt;strong&gt;不可篡改的图灵完备的代码段&lt;/strong&gt;，以及保存一些&lt;strong&gt;持久化的数据&lt;/strong&gt;。这些代码段使用专用语言书写(Like: Solidity)，并通常提供一些对外部访问API接口函数。这些API接口可以通过Transaction，或者通过本地/第三方提供的RPC服务来调用。这种模式构成了目前的DApp生态圈的基础。&lt;/p&gt;

&lt;p&gt;通常，合约中的函数用于计算以及查询或修改合约中的持久化数据。我们经常看到这样的描述”&lt;strong&gt;一旦被记录到区块链上数据不可被修改&lt;/strong&gt;，或者&lt;strong&gt;不可篡改的智能合约&lt;/strong&gt;“。现在我们知道这种描述是不准确。针对一个链上的智能合约，不可修改/篡改的部分是合约中的代码段，或说是合约中的&lt;em&gt;函数逻辑&lt;/em&gt;/&lt;em&gt;代码逻辑是&lt;/em&gt;不可以被修改/篡改的。而链上合约中的持久化的数据是可以通过调用代码段中的函数进行数据操作的(CURD)，包括修改和删除，具体取决于合约函数中的代码逻辑。&lt;/p&gt;

&lt;p&gt;根据&lt;em&gt;合约中函数是否会修改合约中持久化的变量&lt;/em&gt;，合约中的函数可以分为两种，只读函数和写函数。
如果用户&lt;strong&gt;只&lt;/strong&gt;希望查询某些合约中的持久化数据，而不对数据进行修改的话，那么用户只需要调用相关的只读函数。调用只读函数不需要通过构造一个Transaction来查询数据。用户可以通过直接调用本地数据或者第三方提供的数据，来调用对应的函数。如果用户需要对合约中的数据进行更新，那么他就要构造一个Transaction来请求合约中相对应的鞋函数。注意，当用户通过构造Transaction的方式来调用合约中的函数时，每个Transaction只能调用一个合约中的一个API函数。&lt;/p&gt;

&lt;p&gt;对于如何编写合约，以及Ethereum如何解析Transaction并调用对应的合约中API的，我们会在后面的&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2021/07/25/ethereum_txn.html&quot;&gt;文章&lt;/a&gt;中详细的进行解析。&lt;/p&gt;

&lt;h2 id=&quot;stateobject-account-contract&quot;&gt;StateObject, Account, Contract&lt;/h2&gt;

&lt;p&gt;在实际代码中，这两种Account都是由&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;这一数据结构定义的。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;的相关代码位于&lt;em&gt;core/state/state_object.go&lt;/em&gt;文件中，隶属于&lt;em&gt;package state&lt;/em&gt;。我们摘录了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;的结构代码，如下所示。通过下面的代码，我们可以观察到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;是由小写字母开头。根据go语言的特性，我们可以知道这个结构主要用于package内部数据操作，并不对外暴露。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;addrHash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// hash of ethereum address of the account&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateAccount&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dbErr&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Write caches.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;trie&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trie&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// storage trie, which becomes non-nil on first access&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Code&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// contract bytecode, which gets set when code is loaded&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// 这里的Storage 是一个 map[common.Hash]common.Hash&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;originStorage&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Storage cache of original entries to dedup rewrites, reset for every transaction&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pendingStorage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Storage entries that need to be flushed to disk, at the end of an entire block&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dirtyStorage&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Storage entries that have been modified in the current transaction execution&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fakeStorage&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Fake storage which constructed by caller for debugging purpose.&lt;/span&gt;

    &lt;span class=&quot;c&quot;&gt;// Cache flags.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// When an object is marked suicided it will be delete from the trie&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// during the &quot;update&quot; phase of the state transition.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dirtyCode&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// true if the code was updated&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;suicided&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;deleted&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;address&quot;&gt;Address&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;这一结构体中，开头的两个成员变量为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address&lt;/code&gt;以及address的哈希值&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addrHash&lt;/code&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;address&lt;/code&gt;是common.Address类型，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addrHash&lt;/code&gt;是common.Hash类型，它们分别对应了一个20字节长度的byte数组和一个32字节长度的byte数组。关于这两种数据类型的定义如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Lengths of hashes and addresses in bytes.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// HashLength is the expected length of the hash&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// AddressLength is the expected length of the address&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;AddressLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Address represents the 20 byte address of an Ethereum account.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddressLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Hash represents the 32 byte Keccak256 hash of arbitrary data.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Ethereum中，每个Account都拥有独一无二的地址。Address作为每个Account的身份信息，类似于现实生活中的身份证，它与用户信息时刻绑定而且不能被修改。&lt;/p&gt;

&lt;h3 id=&quot;data-and-stateaccount&quot;&gt;data and StateAccount&lt;/h3&gt;

&lt;p&gt;继续向下探索，我们会遇到成员变量data，它是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;types.StateAccount&lt;/code&gt;类型的变量。在上面的分析中我们提到，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stateObject&lt;/code&gt;这种类型只对Package State这个内部使用。所以相应的，Package State也为外部Package API提供了与Account相关的数据类型”State Account”。在上面的代码中我们就可以看到，”State Account”对应了State Object中”data Account”成员变量。State Account的具体数据结构的被定义在”core/types/state_account.go”文件中(&lt;del&gt;在之前的版本中Account的代码位于core/account.go&lt;/del&gt;)，其定义如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Account is the Ethereum consensus representation of accounts.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// These objects are stored in the main account trie.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StateAccount&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Nonce&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Balance&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Root&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// merkle root of the storage trie&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;CodeHash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中的包含四个变量为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nonce 表示该账户发送的交易序号，随着账户发送的交易数量的增加而单调增加。每次发送一个交易，Nonce的值就会加1。&lt;/li&gt;
  &lt;li&gt;Balance 表示该账户的余额。这里的余额指的是链上的Global/Native Token Ether。&lt;/li&gt;
  &lt;li&gt;Root 表示当前账户的下Storage层的 Merkle Patricia Trie的Root。EOA账户这个部分为空值。&lt;/li&gt;
  &lt;li&gt;CodeHash是该账户的Contract代码的哈希值。EOA账户这个部分为空值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;db&quot;&gt;db&lt;/h3&gt;

&lt;p&gt;上述的几个成员变量基本覆盖了Account主工作流相关的全部成员变量。那么继续向下看，我们会遇到db和dbErr这两个成员变量。db这个变量保存了一个StateDB类型的指针。这是为了方便调用StateDB相关的API对Account所对应的stateObject进行操作。StateDB本质上是Ethereum用于管理stateObject信息的而抽象出来的内存数据库。所有的Account数据的更新，检索都会使用StateDB提供的API。关于StateDB的具体实现，功能，以及如何与更底层(leveldb)进行结合的，我们会在之后的文章中进行详细描述。&lt;/p&gt;

&lt;h3 id=&quot;cache&quot;&gt;Cache&lt;/h3&gt;

&lt;p&gt;对于剩下的成员变量，它们的主要用于内存Cache。trie用于保存Contract中的持久化存储的数据，code用于缓存contract中的代码段到内存中，它是一个byte数组。剩下的四个Storage字段主要在执行Transaction的时候缓存Contract合约修改的持久化数据，比如dirtyStorage就用于缓存在Block被Finalize之前，Transaction所修改的合约中的持久化存储数据。对于外部账户，由于没有代码字段，所以对应stateObject对象中的code字段，以及四个Storage类型的字段对应的变量的值都为空(originStorage, pendingStorage, dirtyStorage, fakeStorage)。&lt;/p&gt;

&lt;p&gt;从调用关系上看，这四个缓存变量的调用关系是originStorage –&amp;gt; dirtyStorage–&amp;gt; pendingStorage。关于Contract的Storage层的详细信息，我们会在后面部分进行详细的描述。&lt;/p&gt;

&lt;h2 id=&quot;深入account&quot;&gt;深入Account&lt;/h2&gt;

&lt;h3 id=&quot;private-key--public-kay--address&quot;&gt;Private Key &amp;amp; Public Kay &amp;amp; Address&lt;/h3&gt;

&lt;h4 id=&quot;账户安全的问题&quot;&gt;账户安全的问题&lt;/h4&gt;

&lt;p&gt;我们经常会在各种科技网站，自媒体上听到这样的说法，”用户在区块链系统中保存的Cryptocurrency/Token，除了用户自己，不存在一个中心化的第三方可以不经过用户的允许转走你的财富”。这个说法基本是正确的。目前，用户账户里的由链级别定义Crypto，或者称为原生货币(Native Token)，比如Ether，Bitcoin，BNB(Only in BSC)，是没办法被第三方在不被批准的情况下转走的。这是因为链级别上的所有数据的修改都要经过用户私钥(Private Key)签名的Transaction。只要用户保管好自己账户的私钥(Private Key)，保证其没有被第三方知晓，就没有人可以转走你链上的财富。&lt;/p&gt;

&lt;p&gt;我们说上述说法是基本正确，而不是完全正确的原因有两个。首先，用户的链上数据安全是基于当前Ethereum使用的密码学工具足够保证：不存在第三方可以在&lt;strong&gt;有限的时间&lt;/strong&gt;内在&lt;strong&gt;不知道用户私钥的前提&lt;/strong&gt;下获取到用户的私钥信息来伪造签名交易。当然这个安全保证前提是当今Ethereum使用的密码学工具的强度足够大，没有计算机可以在有限的时间内hack出用户的私钥信息。在量子计算机出现之前，目前Ethereum和其他Blockchain使用的密码学工具的强度都是足够安全的。这也是为什么很多新的区块链项目在研究抗量子计算机密码体系的原因。第二点原因是，当今很多的所谓的Crypto/Token并不是链级别的数据，而是在链上合约中存储的数据，比如ERC-20 Token和NFT对应的ERC-721的Token。由于这部分的Token都是基于合约代码生成和维护的，所以这部分Token的安全依赖于合约本身的安全。如果合约本身的代码是有问题的，存在后门或者漏洞，比如存在给第三方任意提取其他账户下Token的漏洞，那么即使用户的私钥信息没有泄漏，合约中的Token仍然可以被第三方获取到。由于合约的代码段在链上是不可修改的，合约代码的安全性是极其重要的。所以，有很多研究人员，技术团队在进行合约审计方面的工作，来保证上传的合约代码是安全的。此外随着Layer-2技术和一些跨链技术的发展，用户持有的“Token”，在很多情况下不是我们上面提到的安全的Naive Token，而是ERC-20甚至只是其他合约中的简单数值记录。这种类型的资产的安全性是低于layer-1上的Native Token的。用户在持有这类资产的时候需要小心。这里我们推荐阅读Jay Freeman所分析的关于一个热门Layer-2系统Optimism上的由于非Naive Token造成的&lt;a href=&quot;https://www.saurik.com/optimism.html&quot;&gt;任意提取漏洞&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面我们简单讲述，一个账户的私钥和地址是如何产生的。- 这部分的示例代码位于: &lt;a href=&quot;example/signature&quot;&gt;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/signature/main.go&lt;/a&gt;]中。&lt;/p&gt;

&lt;h4 id=&quot;account-generation&quot;&gt;Account Generation&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;首先我们通过随机得到一个长度64位account的私钥。这个私钥就是平时需要用户激活钱包时需要的记录，一旦这个私钥暴露了，钱包也将不再安全。
    &lt;ul&gt;
      &lt;li&gt;64个16进制位，256bit，32字节
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;var AlicePrivateKey = &quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在得到私钥后，我们使用用私钥来计算公钥和account的地址。基于私钥，我们使用ECDSA算法，选择spec256k1曲线进行计算。通过将私钥带入到所选择的椭圆曲线中，计算出点的坐标即是公钥。以太坊和比特币使用了同样的spec256k1曲线，在实际的代码中，我们也可以看到在crypto中，go-Ethereum直接调用了比特币的代码。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ecdsaSK, err := crypto.ToECDSA(privateKey)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;对私钥进行椭圆加密之后，我们可以得到64bytes的数，它是由两个32bytes的数构成，这两个数代表了spec256k1曲线上某个点的XY值。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ecdsaPK := ecdsaSK.PublicKey&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;以太坊的地址，是基于上述公钥(ecdsaSK.PublicKey)的 [Keccak-256算法] 之后的后20个字节，并且用0x开头。
    &lt;ul&gt;
      &lt;li&gt;Keccak-256是SHA-3（Secure Hash Algorithm 3）标准下的一种哈希算法
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addr := crypto.PubkeyToAddress(ecdsaSK.PublicKey)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;signature--verification&quot;&gt;Signature &amp;amp; Verification&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Hash（m,R）&lt;em&gt;X +R = S&lt;/em&gt; P&lt;/li&gt;
  &lt;li&gt;P是椭圆曲线函数的基点(base point) 可以理解为一个P是一个在曲线C上的一个order 为n的加法循环群的生成元. n为质数。&lt;/li&gt;
  &lt;li&gt;R = r * P (r 是个随机数，并不告知verifier)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以太坊签名校验的核心思想是:首先基于上面得到的ECDSA下的私钥ecdsaSK对数据msg进行签名(sign)得到msgSig.
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sig, err := crypto.Sign(msg[:], ecdsaSK)&lt;/code&gt;
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msgSig := decodeHex(hex.EncodeToString(sig))&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;然后基于msg和msgSig可以反推出来签名的公钥（用于生成账户地址的公钥ecdsaPK）。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;recoveredPub, err := crypto.Ecrecover(msg[:],msgSig)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过反推出来的公钥得到发送者的地址，并与当前txn的发送者在ECDSA下的pk进行对比。
  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;crypto.VerifySignature(testPk, msg[:], msgSig[:len(msgSig)-1])&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;这套体系的安全性保证在于，即使知道了公钥ecdsaPk/ecdsaSK.PublicKey也难以推测出 ecdsaSK以及生成他的privateKey。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ecdsa--spec256k1曲线&quot;&gt;ECDSA &amp;amp; spec256k1曲线&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Elliptic curve point multiplication
    &lt;ul&gt;
      &lt;li&gt;Point addition P + Q = R&lt;/li&gt;
      &lt;li&gt;Point doubling P + P = 2P&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;y^2 = x^3 +7&lt;/li&gt;
  &lt;li&gt;Based Point P是在椭圆曲线上的群的生成元&lt;/li&gt;
  &lt;li&gt;x次computation on Based Point得到X点，x为私钥，X为公钥。x由Account Private Key得出。&lt;/li&gt;
  &lt;li&gt;在ECC中的+号不是四则运算中的加法，而是定义椭圆曲线C上的新的二元运算(Point Multiplication)。他代表了过两点P和Q的直线与椭圆曲线C的交点R‘关于X轴对称的点R。因为C是关于X轴对称的所以关于X对称的点也都在椭圆曲线上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;深入contract&quot;&gt;深入Contract&lt;/h2&gt;

&lt;h3 id=&quot;contract-storage-合约存储&quot;&gt;Contract Storage (合约存储)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;#general Background&quot;&gt;在文章的开头&lt;/a&gt;我们提到，在外部账户对应的，stateObject结构体的实例中，有四个Storage类型的变量是空值。那显然的，这四个变量是为Contract类型的账户准备的。&lt;/p&gt;

&lt;p&gt;在”state_object.go”文件的开头部分(41行左右)，我们可以找到Storage类型的定义。具体如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到，&lt;em&gt;Storage&lt;/em&gt;是一个key和value都是common.Hash类型的map结构。common.Hash类型，则对应了一个长度为32bytes的byte类型数组。这个类型在go-ethereum中被大量使用，通常用于表示32字节长度的数据，比如Keccak256函数的哈希值。在之后的旅程中，我们也会经常看到它的身影，它的定义在common.type.go文件中。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// HashLength is the expected length of the hash&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Hash represents the 32 byte Keccak256 hash of arbitrary data.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HashLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从功能层面讲，外部账户(EOA)与合约账户(Contract)不同的点在于，外部账户并没有维护自己的代码(codeHash)以及额外的Storage层。相比与外部账户，合约账户额外保存了一个存储层(Storage)用于存储合约代码中持久化的变量的数据。在上文中我们提到，StateObject中的声明的四个Storage类型的变量，就是作为Contract Storage层的内存缓存。&lt;/p&gt;

&lt;p&gt;在Ethereum中，每个合约都维护了自己的&lt;em&gt;独立&lt;/em&gt;的Storage空间，我们称为Storage层。Storage层的基本组成单元称为槽 (Slot)，若干个Slot按照&lt;em&gt;Stack&lt;/em&gt;的方式集合在一起构造成了Storage 层。每个Slot的大小是256bits，也就是最多保存32 bytes的数据。作为基本的存储单元，Slot管理的方式与内存或者HDD中的基本单元的管理方式类似，通过地址索引的方式被上层函数访问。Slot的地址索引的长度同样是32 bytes(256 bits)，寻址空间从 0x0000000000000000000000000000000000000000000000000000000000000000 到 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。因此，每个Contract的Storage层最多可以保存$2^{256} - 1$个Slot。也就说在理论状态下，一个Contract可以最多保存$(2^{256} - 1)$ bytes的数据，这是个相当大的数字。Contract同样使用MPT来管理Storage 层的Slot。值得注意的是，Storage层的数据并不会被打包进入Block中。唯一与Chain内数据相关的是，Storage Trie的根数据被保存在StateAccount结构体中的Root变量中(它是一个32bytes长的byte数组)。当某个Contract的Storage层的数据发生变化时，根据骨牌效应，向上传导到World State Root的值发生变化，从而影响到Chain数据。目前，Storage层的数据读取和修改是在执行相关Transaction的时候，通过EVM调用两个专用的指令&lt;em&gt;OpSload&lt;/em&gt;和&lt;em&gt;OpSstore&lt;/em&gt;触发。&lt;/p&gt;

&lt;p&gt;我们知道目前Ethereum中的大部分合约都通过Solidity语言编写。Solidity做为强类型的图灵完备的语言，支持多种类型的变量。总的来说，根据变量的长度性质，Ethereum中的持久化的变量可以分为定长的变量和不定长度的变量两种。定长的变量有常见的单变量类型，比如 uint256。不定长的变量包括了由若干单变量组成的Array，以及KV形式的Map类型。&lt;/p&gt;

&lt;p&gt;根据上面的介绍，我们了解到对Contract Storage层的访问是通过Slot的地址来进行的。请读者先思考下面的几个问题:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;如何给定一个包含若干持久化存储变量的Solidity的合约，EVM是怎么给其包含的变量分配存储空间的呢？&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;怎么保证Contract Storage的一致性读写的？(怎么保证每个合约的验证者和执行者都能获取到相同的数据？)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们将通过下面的一些实例来展示，在Ethereum中，Contract是如何保存持久化变量的，以及保证所有的参与者都能一致性读写的Contract中的数据的。&lt;/p&gt;

&lt;h3 id=&quot;contract-storage-example-one&quot;&gt;Contract Storage Example One&lt;/h3&gt;

&lt;p&gt;我们使用一个简单的合约来展示Contract Storage层的逻辑，合约代码如下所示。在本例中，我们使用了一个叫做”Storage”合约，其中定义了了三个持久化uint256类型的变量分别是number, number1, 以及number2。同时，我们定义一个stores函数给这个三个变量进行赋值。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们使用&lt;a href=&quot;https://remix.ethereum.org/&quot;&gt;Remix&lt;/a&gt;来在本地部署这个合约，并构造一个调用stores(1)函数的Transaction，同时使用Remix debugger来Storage层的变化。在Transaction生效之后，合约中三个变量的值将被分别赋给1，2，3。此时，我们观察Storage层会发现，存储层增加了三个Storage Object。这三个Storage Object对应了三个Slot。所以在本例中，合约增加了三个Slots来存储数据。我们可以发现每个Storage Object由三个字段组成，分别是一个32 bytes的key字段和32 bytess的value字段，以及外层的一个32 bytes 的字段。这三个字段在下面的例子中都表现为64位的16进制数(32 Bytes)。&lt;/p&gt;

&lt;p&gt;下面我们来逐个解释一下这个三个值的实际意义。首先我们观察内部的Key-Value对，可以发现下面三个Storage Object中key的值其实是从0开始的递增整数，分别是0，1，2。它代表了当前Slot的地址索引值，或者说该Slot在Storage层对应的绝对位置(Position)。比如，key的值为0时，它代表整个Storage层中的第1个Slot，或者说在1号位置的Slot，当key等于1时代表Storage层中的第2个Slot，以此类推。每个Storage Object中的value变量，存储了合约中三个变量的值(1,2,3)。而Storage Object外层的值由等于Storage Object的key的值的sha3的哈希值。比如，下面例子中的第一个Storage Object的外层索引值”0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563” 是通过keccak256(0)计算出的值，代表了第一个Slot position的Sha3的哈希，而”0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6” 对应了是keccak(1)的值。我们在&lt;a href=&quot;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/account/main.go&quot;&gt;示例代码&lt;/a&gt;中展示了如何计算的过程。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;读者可能以及发现了，在这个Storage Object中，外层的索引值其实与Key值的关系是一一对应的，或者说这两个键值本质上都是关于Slot位置的唯一索引。这里我们简单讲述一下这两个值在使用上的区别。Key值代表了Slot在Storage层的Position，这个值用于会作为stateObject.go/getState()以及setState()函数的参数，用于定位Slot。如果我们继续深入上面的两个函数，我们就会发现，当内存中不存在该Slot的缓存时，geth就会尝试从更底层的数据库中来获取这个Slot的值。而Storage在更底层的数据，是由Secure Trie来维护的，Secure Trie中的Key值都是需要Hash的。所以在Secure Trie层我们查询/修改需要的键值就是外层的hash值。具体的关于Secure Trie的描述可以参考&lt;a href=&quot;10_tire_statedb.md&quot;&gt;Trie&lt;/a&gt;这一章节。总结下来，在上层函数(stateObject)调用中使用的键值是Slot的Position，在下层的函数(Trie)调用中使用的键值是Slot的Position的哈希值。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SecureTrie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TryGet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// Secure Trie中查询的例子&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 这里的key还是Slot的Position&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;// 但是在更下层的Call更下层的函数的时候使用了这个Key的hash值作为查询使用的键值。&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trie&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TryGet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hashKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;account-storage-example-two&quot;&gt;Account Storage Example Two&lt;/h3&gt;

&lt;p&gt;下面我们来看另外的一个例子。在这个例子中，我们调整一下合约中变量的声明顺序，从(number，number1，number2)调整为(number 2, number 1, number)。合约代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同样我们还是构造Transaction来调用合约中的stores函数。此时我们可以在Storage 层观察到不一样的结果。我们发现number2这个变量的值被存储在了第一个Slot中（Key:”0x0000000000000000000000000000000000000000000000000000000000000000”），而number这个变量的值北存储在了第三个Slot中 (Key:”0x0000000000000000000000000000000000000000000000000000000000000002”)。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个例子可以说明，在Ethereum中，变量对应的存储层的Slot，是&lt;em&gt;按照其在在合约中的声明顺序&lt;/em&gt;，从第一个Slot（position：0）开始分配的。&lt;/p&gt;

&lt;h3 id=&quot;account-storage-example-three&quot;&gt;Account Storage Example Three&lt;/h3&gt;

&lt;p&gt;我们再考虑另一种情况：声明的三个变量，但只对其中的两个变量进行赋值。具体的来说，我们按照number，number1，和number2的顺序声明三个uint256变量。但是，在函数stores中只对number1和number2进行赋值操作。合约代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基于上述合约，我们构造transaction 并调用stores函数，输入参数1，将number1和number2的值修改为2，和3。在transaction执行完成后，我们可以观察到Storage层Slot的结果如下所示。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以观察到，stores函数调用的结果只对在合约的Storage层中位置在1和2位置的两个Slot进行了赋值。值得注意的是，在本例中，对于Slot的赋值是从1号位置Slot的开始，而不是0号Slot。这说明对于固定长度的变量，其值的所占用的Slot的位置在Contract初始化开始的时候就已经分配的。即使变量只是被声明还没有真正的赋值，保存其值所需要的Slot也已经被EVM分配完毕。而不是在第一次进行变量赋值的时候，进行再对变量所需要的的Slot进行分配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../assets/figs/01/remix.png&quot; alt=&quot;Remix Debugger&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;account-storage-example-four&quot;&gt;Account Storage Example Four&lt;/h3&gt;

&lt;p&gt;在Solidity中，有一类特殊的变量类型&lt;strong&gt;Address&lt;/strong&gt;，通常用于表示账户的地址信息。例如在ERC-20合约中，用户拥有的token信息是被存储在一个(address-&amp;gt;uint)的map结构中。在这个map中，key就是Address类型的，它表示了用户实际的address。目前Address的大小为160bits(20bytes)，并不足以填满一整个Slot。因此当Address作为value单独存储在的时候，它并不会排他的独占用一个Slot。我们使用下面的例子来说明。&lt;/p&gt;

&lt;p&gt;在下面的示例中，我们声明了三个变量，分别是number(uint256)，addr(address)，以及isTrue(bool)。我们知道，在以太坊中Address类型变量的长度是20 bytes，所以一个Address类型的变量是没办法填满整个的Slot(32 bytes)的。同时，布尔类型在以太坊中只需要一个bit(0 or 1)的空间。因此，我们构造transaction并调用函数storeaddr来给这三个变量赋值，函数的input参数是一个uint256的值，一个address类型的值，分别为{1, “0xb6186d3a3D32232BB21E87A33a4E176853a49d12”}。&lt;/p&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;


    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isTrue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// number1 = num + 1;
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// number2 = num + 2;
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;storeaddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;isTure&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Transaction的运行后Storage层的结果如下面的Json所示。我们可以观察到，在本例中Contract声明了三个变量，但是在Storage层只调用了两个Slot。第一个Slot用于保存了uint256的值，而在第二个Slot中(Key:0x0000000000000000000000000000000000000000000000000000000000000001)保存了addr和isTrue的值。这里需要注意，虽然这种将两个小于32 bytes长的变量合并到一个Slot的做法节省了物理空间，但是也同样带来读写放大的问题。因为在Geth中，读操作最小的读的单位都是按照32bytes来进行的。在本例中，即使我们只需要读取isTrue或者addr这两个变量的值，在具体的函数调用中，我们仍然需要将对应的Slot先读取到内存中。同样的，如果我们想修改这两个变量的值，同样需要对整个的Slot进行重写。这无疑增加了额外的开销。所以在Ethereum使用32 bytes的变量，在某些情况下消耗的Gas反而比更小长度类型的变量要小(例如 unit8)。这也是为什么Ethereum官方也建议使用长度为32 bytes变量的原因。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x000000000000000000000001b6186d3a3d32232bb21e87a33a4e176853a49d12&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;account-storage-example-five&quot;&gt;Account Storage Example Five&lt;/h3&gt;

&lt;p&gt;对于变长数组和Map结构的变量存储分配则相对的复杂。虽然Map本身就是key-value的结构，但是在Storage 层并不直接使用map中key的值或者key的值的sha3 哈希值来作为Storage分配的Slot的索引值。目前，Geth首先会使用map中元素的key的值和当前Map变量声明位置对应的slot的值进行拼接，再使用拼接后的值的keccak256哈希值作为Slot的位置索引(Position)。我们在下面的例子中展示了Geth是如何处理map这种变长的数据结构的。在下面的合约中，我们声明了一个定长的uint256类型的对象number，和一个[string=&amp;gt;uint256]类型的Map对象。&lt;/p&gt;

&lt;!-- Todo: 变长数据结构的存储情况。 --&gt;

&lt;div class=&quot;language-solidity highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// SPDX-License-Identifier: GPL-3.0
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;pragma&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solidity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * @title Storage
 * @dev Store &amp;amp; retrieve value in a variable
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Storage&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_balance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hsy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;balances&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lei&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们构造Transaction来调用了set_balance函数，在Transaction执行之后的Storage层的结果如下面的Json所示。我们发现，对于定长的变量number占据了第一个Slot的空间(Position:0x0000000000000000000000000000000000000000000000000000000000000000)。但是对于Map类型变量balances，它包含的两个数据并没有按照变量定义的物理顺序来定义Slot。此外，我们观察到存储这两个值的Slot的key，也并不是这两个字在mapping中key的直接hash。正如我们在上段中提到的那样，Geth会使用Map中元素的的key值与当前Map被分配的slot的位置进行拼接，之后对拼接之后对值进行使用keccak256函数求得哈希值，来最终得到map中元素最终的存储位置。比如在本例中，按照变量定义的顺序，balances这个Map变量会被分配到第二个Slot，对应的Slot Position是1。因此，balances中的kv对分配到的slot的位置就是，keccak(key, 1)，这里是一个特殊的拼接操作。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0xa601d8e9cd2719ca27765dc16042655548d1ac3600a53ffc06b4a06a12b7c65c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0xbaded3bf529b04b554de2e4ee0f5702613335896b4041c50a5555b2d5e279f91&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;0x53ac6681d92653b13055d2e265b672e2db2b2a19407afb633928597f144edbb0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x56a8a0d158d59e2fd9317c46c65b1e902ed92f726ecfe82c06c33c015e8e6682&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了验证上面的说法，我们使用go语言编写了一段代码，来调用相关的库来验证一下上面的结论。对于 balances[“hsy”]，它被分配的Slot的位置可以由下面的代码求得。读者可以阅读/使用&lt;a href=&quot;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/account/main.go&quot;&gt;示例代码&lt;/a&gt;进行尝试。这里的k1是一个整形实数，代表了Slot的在storage层的位置(Position)。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;k1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solsha3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SoliditySHA3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hsy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;solsha3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Uint256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Test the Solidity Map storage Key1:         0x%x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freecodecamp.org/news/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c/&quot;&gt;https://www.freecodecamp.org/news/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">概述 我们常常听到这么一个说法，“Ethereum和Bitcoin最大的不同之一是，Ethereum是基于Account模型的Blockchain系统，而Bitcoin是基于UTXO模型的”。那么，这个另辟蹊径的Account模型究竟不同在何处呢？在本文中我们来探索一下以太坊中的基本数据单元(Metadata)之一的Account。 我们知道，Ethereum的运行依赖于基于交易的状态机模型(Transaction-based State Machine)。其中，状态(State)指的是数据变量在某一时刻下的信息。承载State的数据变量，称之为StateObject。当StateObject的数据或信息发生了变化时，我们称为状态转移。在Ethereum的运行模型中，StateObject所包含的数据会因为Transaction的执行引发的数据更新/删除/创建而发生变化，从而造成状态转移，StateObject的状态会从当前的State转移到另一个State。 在Ethereum中，StateObject的具体实现就是Account。因此，我们提到的State具体指的就是Account在某个时刻的包含的数据的值。 Account –&amp;gt; StateObject State –&amp;gt; The value/data of the Account 总的来说, Account (账户)是参与链上交易(Transaction)的基本角色，是Ethereum状态机模型中的基本单位，承担了链上交易的发起者以及接收者的角色。目前，在以太坊中，有两种类型的Account，分别是外部账户(EOA)以及合约账户(Contract)。 EOA 外部账户(EOA)是由用户直接控制的账户，负责签名并发起交易(Transaction)。用户通过Account的私钥来保证对账户数据的控制权。 合约账户(Contract)，简称为合约，是由外部账户通过Transaction创建。合约账户，保存了不可篡改的图灵完备的代码段，以及保存一些持久化的数据。这些代码段使用专用语言书写(Like: Solidity)，并通常提供一些对外部访问API接口函数。这些API接口可以通过Transaction，或者通过本地/第三方提供的RPC服务来调用。这种模式构成了目前的DApp生态圈的基础。 通常，合约中的函数用于计算以及查询或修改合约中的持久化数据。我们经常看到这样的描述”一旦被记录到区块链上数据不可被修改，或者不可篡改的智能合约“。现在我们知道这种描述是不准确。针对一个链上的智能合约，不可修改/篡改的部分是合约中的代码段，或说是合约中的函数逻辑/代码逻辑是不可以被修改/篡改的。而链上合约中的持久化的数据是可以通过调用代码段中的函数进行数据操作的(CURD)，包括修改和删除，具体取决于合约函数中的代码逻辑。 根据合约中函数是否会修改合约中持久化的变量，合约中的函数可以分为两种，只读函数和写函数。 如果用户只希望查询某些合约中的持久化数据，而不对数据进行修改的话，那么用户只需要调用相关的只读函数。调用只读函数不需要通过构造一个Transaction来查询数据。用户可以通过直接调用本地数据或者第三方提供的数据，来调用对应的函数。如果用户需要对合约中的数据进行更新，那么他就要构造一个Transaction来请求合约中相对应的鞋函数。注意，当用户通过构造Transaction的方式来调用合约中的函数时，每个Transaction只能调用一个合约中的一个API函数。 对于如何编写合约，以及Ethereum如何解析Transaction并调用对应的合约中API的，我们会在后面的文章中详细的进行解析。 StateObject, Account, Contract 在实际代码中，这两种Account都是由stateObject这一数据结构定义的。stateObject的相关代码位于core/state/state_object.go文件中，隶属于package state。我们摘录了stateObject的结构代码，如下所示。通过下面的代码，我们可以观察到，stateObject是由小写字母开头。根据go语言的特性，我们可以知道这个结构主要用于package内部数据操作，并不对外暴露。 type stateObject struct { address common.Address addrHash common.Hash // hash of ethereum address of the account data types.StateAccount db *StateDB dbErr error // Write caches. trie Trie // storage trie, which becomes non-nil on first access code Code // contract bytecode, which gets set when code is loaded // 这里的Storage 是一个 map[common.Hash]common.Hash originStorage Storage // Storage cache of original entries to dedup rewrites, reset for every transaction pendingStorage Storage // Storage entries that need to be flushed to disk, at the end of an entire block dirtyStorage Storage // Storage entries that have been modified in the current transaction execution fakeStorage Storage // Fake storage which constructed by caller for debugging purpose. // Cache flags. // When an object is marked suicided it will be delete from the trie // during the &quot;update&quot; phase of the state transition. dirtyCode bool // true if the code was updated suicided bool deleted bool } Address 在stateObject这一结构体中，开头的两个成员变量为address以及address的哈希值addrHash。address是common.Address类型，addrHash是common.Hash类型，它们分别对应了一个20字节长度的byte数组和一个32字节长度的byte数组。关于这两种数据类型的定义如下所示。 // Lengths of hashes and addresses in bytes. const ( // HashLength is the expected length of the hash HashLength = 32 // AddressLength is the expected length of the address AddressLength = 20 ) // Address represents the 20 byte address of an Ethereum account. type Address [AddressLength]byte // Hash represents the 32 byte Keccak256 hash of arbitrary data. type Hash [HashLength]byte 在Ethereum中，每个Account都拥有独一无二的地址。Address作为每个Account的身份信息，类似于现实生活中的身份证，它与用户信息时刻绑定而且不能被修改。 data and StateAccount 继续向下探索，我们会遇到成员变量data，它是一个types.StateAccount类型的变量。在上面的分析中我们提到，stateObject这种类型只对Package State这个内部使用。所以相应的，Package State也为外部Package API提供了与Account相关的数据类型”State Account”。在上面的代码中我们就可以看到，”State Account”对应了State Object中”data Account”成员变量。State Account的具体数据结构的被定义在”core/types/state_account.go”文件中(在之前的版本中Account的代码位于core/account.go)，其定义如下所示。 // Account is the Ethereum consensus representation of accounts. // These objects are stored in the main account trie. type StateAccount struct { Nonce uint64 Balance *big.Int Root common.Hash // merkle root of the storage trie CodeHash []byte } 其中的包含四个变量为: Nonce 表示该账户发送的交易序号，随着账户发送的交易数量的增加而单调增加。每次发送一个交易，Nonce的值就会加1。 Balance 表示该账户的余额。这里的余额指的是链上的Global/Native Token Ether。 Root 表示当前账户的下Storage层的 Merkle Patricia Trie的Root。EOA账户这个部分为空值。 CodeHash是该账户的Contract代码的哈希值。EOA账户这个部分为空值。 db 上述的几个成员变量基本覆盖了Account主工作流相关的全部成员变量。那么继续向下看，我们会遇到db和dbErr这两个成员变量。db这个变量保存了一个StateDB类型的指针。这是为了方便调用StateDB相关的API对Account所对应的stateObject进行操作。StateDB本质上是Ethereum用于管理stateObject信息的而抽象出来的内存数据库。所有的Account数据的更新，检索都会使用StateDB提供的API。关于StateDB的具体实现，功能，以及如何与更底层(leveldb)进行结合的，我们会在之后的文章中进行详细描述。 Cache 对于剩下的成员变量，它们的主要用于内存Cache。trie用于保存Contract中的持久化存储的数据，code用于缓存contract中的代码段到内存中，它是一个byte数组。剩下的四个Storage字段主要在执行Transaction的时候缓存Contract合约修改的持久化数据，比如dirtyStorage就用于缓存在Block被Finalize之前，Transaction所修改的合约中的持久化存储数据。对于外部账户，由于没有代码字段，所以对应stateObject对象中的code字段，以及四个Storage类型的字段对应的变量的值都为空(originStorage, pendingStorage, dirtyStorage, fakeStorage)。 从调用关系上看，这四个缓存变量的调用关系是originStorage –&amp;gt; dirtyStorage–&amp;gt; pendingStorage。关于Contract的Storage层的详细信息，我们会在后面部分进行详细的描述。 深入Account Private Key &amp;amp; Public Kay &amp;amp; Address 账户安全的问题 我们经常会在各种科技网站，自媒体上听到这样的说法，”用户在区块链系统中保存的Cryptocurrency/Token，除了用户自己，不存在一个中心化的第三方可以不经过用户的允许转走你的财富”。这个说法基本是正确的。目前，用户账户里的由链级别定义Crypto，或者称为原生货币(Native Token)，比如Ether，Bitcoin，BNB(Only in BSC)，是没办法被第三方在不被批准的情况下转走的。这是因为链级别上的所有数据的修改都要经过用户私钥(Private Key)签名的Transaction。只要用户保管好自己账户的私钥(Private Key)，保证其没有被第三方知晓，就没有人可以转走你链上的财富。 我们说上述说法是基本正确，而不是完全正确的原因有两个。首先，用户的链上数据安全是基于当前Ethereum使用的密码学工具足够保证：不存在第三方可以在有限的时间内在不知道用户私钥的前提下获取到用户的私钥信息来伪造签名交易。当然这个安全保证前提是当今Ethereum使用的密码学工具的强度足够大，没有计算机可以在有限的时间内hack出用户的私钥信息。在量子计算机出现之前，目前Ethereum和其他Blockchain使用的密码学工具的强度都是足够安全的。这也是为什么很多新的区块链项目在研究抗量子计算机密码体系的原因。第二点原因是，当今很多的所谓的Crypto/Token并不是链级别的数据，而是在链上合约中存储的数据，比如ERC-20 Token和NFT对应的ERC-721的Token。由于这部分的Token都是基于合约代码生成和维护的，所以这部分Token的安全依赖于合约本身的安全。如果合约本身的代码是有问题的，存在后门或者漏洞，比如存在给第三方任意提取其他账户下Token的漏洞，那么即使用户的私钥信息没有泄漏，合约中的Token仍然可以被第三方获取到。由于合约的代码段在链上是不可修改的，合约代码的安全性是极其重要的。所以，有很多研究人员，技术团队在进行合约审计方面的工作，来保证上传的合约代码是安全的。此外随着Layer-2技术和一些跨链技术的发展，用户持有的“Token”，在很多情况下不是我们上面提到的安全的Naive Token，而是ERC-20甚至只是其他合约中的简单数值记录。这种类型的资产的安全性是低于layer-1上的Native Token的。用户在持有这类资产的时候需要小心。这里我们推荐阅读Jay Freeman所分析的关于一个热门Layer-2系统Optimism上的由于非Naive Token造成的任意提取漏洞。 下面我们简单讲述，一个账户的私钥和地址是如何产生的。- 这部分的示例代码位于: https://github.com/hsyodyssey/Understanding-Ethereum-Go-version/blob/main/example/signature/main.go]中。 Account Generation 首先我们通过随机得到一个长度64位account的私钥。这个私钥就是平时需要用户激活钱包时需要的记录，一旦这个私钥暴露了，钱包也将不再安全。 64个16进制位，256bit，32字节 var AlicePrivateKey = &quot;289c2857d4598e37fb9647507e47a309d6133539bf21a8b9cb6df88fd5232032&quot; 在得到私钥后，我们使用用私钥来计算公钥和account的地址。基于私钥，我们使用ECDSA算法，选择spec256k1曲线进行计算。通过将私钥带入到所选择的椭圆曲线中，计算出点的坐标即是公钥。以太坊和比特币使用了同样的spec256k1曲线，在实际的代码中，我们也可以看到在crypto中，go-Ethereum直接调用了比特币的代码。 ecdsaSK, err := crypto.ToECDSA(privateKey) 对私钥进行椭圆加密之后，我们可以得到64bytes的数，它是由两个32bytes的数构成，这两个数代表了spec256k1曲线上某个点的XY值。 ecdsaPK := ecdsaSK.PublicKey 以太坊的地址，是基于上述公钥(ecdsaSK.PublicKey)的 [Keccak-256算法] 之后的后20个字节，并且用0x开头。 Keccak-256是SHA-3（Secure Hash Algorithm 3）标准下的一种哈希算法 addr := crypto.PubkeyToAddress(ecdsaSK.PublicKey) Signature &amp;amp; Verification Hash（m,R）X +R = S P P是椭圆曲线函数的基点(base point) 可以理解为一个P是一个在曲线C上的一个order 为n的加法循环群的生成元. n为质数。 R = r * P (r 是个随机数，并不告知verifier) 以太坊签名校验的核心思想是:首先基于上面得到的ECDSA下的私钥ecdsaSK对数据msg进行签名(sign)得到msgSig. sig, err := crypto.Sign(msg[:], ecdsaSK) msgSig := decodeHex(hex.EncodeToString(sig)) 然后基于msg和msgSig可以反推出来签名的公钥（用于生成账户地址的公钥ecdsaPK）。 recoveredPub, err := crypto.Ecrecover(msg[:],msgSig) 通过反推出来的公钥得到发送者的地址，并与当前txn的发送者在ECDSA下的pk进行对比。 crypto.VerifySignature(testPk, msg[:], msgSig[:len(msgSig)-1]) 这套体系的安全性保证在于，即使知道了公钥ecdsaPk/ecdsaSK.PublicKey也难以推测出 ecdsaSK以及生成他的privateKey。 ECDSA &amp;amp; spec256k1曲线 Elliptic curve point multiplication Point addition P + Q = R Point doubling P + P = 2P y^2 = x^3 +7 Based Point P是在椭圆曲线上的群的生成元 x次computation on Based Point得到X点，x为私钥，X为公钥。x由Account Private Key得出。 在ECC中的+号不是四则运算中的加法，而是定义椭圆曲线C上的新的二元运算(Point Multiplication)。他代表了过两点P和Q的直线与椭圆曲线C的交点R‘关于X轴对称的点R。因为C是关于X轴对称的所以关于X对称的点也都在椭圆曲线上。 深入Contract Contract Storage (合约存储) 在文章的开头我们提到，在外部账户对应的，stateObject结构体的实例中，有四个Storage类型的变量是空值。那显然的，这四个变量是为Contract类型的账户准备的。 在”state_object.go”文件的开头部分(41行左右)，我们可以找到Storage类型的定义。具体如下所示。 type Storage map[common.Hash]common.Hash 我们可以看到，Storage是一个key和value都是common.Hash类型的map结构。common.Hash类型，则对应了一个长度为32bytes的byte类型数组。这个类型在go-ethereum中被大量使用，通常用于表示32字节长度的数据，比如Keccak256函数的哈希值。在之后的旅程中，我们也会经常看到它的身影，它的定义在common.type.go文件中。 // HashLength is the expected length of the hash HashLength = 32 // Hash represents the 32 byte Keccak256 hash of arbitrary data. type Hash [HashLength]byte 从功能层面讲，外部账户(EOA)与合约账户(Contract)不同的点在于，外部账户并没有维护自己的代码(codeHash)以及额外的Storage层。相比与外部账户，合约账户额外保存了一个存储层(Storage)用于存储合约代码中持久化的变量的数据。在上文中我们提到，StateObject中的声明的四个Storage类型的变量，就是作为Contract Storage层的内存缓存。 在Ethereum中，每个合约都维护了自己的独立的Storage空间，我们称为Storage层。Storage层的基本组成单元称为槽 (Slot)，若干个Slot按照Stack的方式集合在一起构造成了Storage 层。每个Slot的大小是256bits，也就是最多保存32 bytes的数据。作为基本的存储单元，Slot管理的方式与内存或者HDD中的基本单元的管理方式类似，通过地址索引的方式被上层函数访问。Slot的地址索引的长度同样是32 bytes(256 bits)，寻址空间从 0x0000000000000000000000000000000000000000000000000000000000000000 到 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。因此，每个Contract的Storage层最多可以保存$2^{256} - 1$个Slot。也就说在理论状态下，一个Contract可以最多保存$(2^{256} - 1)$ bytes的数据，这是个相当大的数字。Contract同样使用MPT来管理Storage 层的Slot。值得注意的是，Storage层的数据并不会被打包进入Block中。唯一与Chain内数据相关的是，Storage Trie的根数据被保存在StateAccount结构体中的Root变量中(它是一个32bytes长的byte数组)。当某个Contract的Storage层的数据发生变化时，根据骨牌效应，向上传导到World State Root的值发生变化，从而影响到Chain数据。目前，Storage层的数据读取和修改是在执行相关Transaction的时候，通过EVM调用两个专用的指令OpSload和OpSstore触发。 我们知道目前Ethereum中的大部分合约都通过Solidity语言编写。Solidity做为强类型的图灵完备的语言，支持多种类型的变量。总的来说，根据变量的长度性质，Ethereum中的持久化的变量可以分为定长的变量和不定长度的变量两种。定长的变量有常见的单变量类型，比如 uint256。不定长的变量包括了由若干单变量组成的Array，以及KV形式的Map类型。 根据上面的介绍，我们了解到对Contract Storage层的访问是通过Slot的地址来进行的。请读者先思考下面的几个问题: 如何给定一个包含若干持久化存储变量的Solidity的合约，EVM是怎么给其包含的变量分配存储空间的呢？ 怎么保证Contract Storage的一致性读写的？(怎么保证每个合约的验证者和执行者都能获取到相同的数据？) 我们将通过下面的一些实例来展示，在Ethereum中，Contract是如何保存持久化变量的，以及保证所有的参与者都能一致性读写的Contract中的数据的。 Contract Storage Example One 我们使用一个简单的合约来展示Contract Storage层的逻辑，合约代码如下所示。在本例中，我们使用了一个叫做”Storage”合约，其中定义了了三个持久化uint256类型的变量分别是number, number1, 以及number2。同时，我们定义一个stores函数给这个三个变量进行赋值。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; uint256 number1; uint256 number2; function stores(uint256 num) public { number = num; number1 = num + 1; number2 = num + 2; } function get_number() public view returns (uint256){ return number; } function get_number1() public view returns (uint256){ return number1; } function get_number2() public view returns (uint256){ return number2; } } 我们使用Remix来在本地部署这个合约，并构造一个调用stores(1)函数的Transaction，同时使用Remix debugger来Storage层的变化。在Transaction生效之后，合约中三个变量的值将被分别赋给1，2，3。此时，我们观察Storage层会发现，存储层增加了三个Storage Object。这三个Storage Object对应了三个Slot。所以在本例中，合约增加了三个Slots来存储数据。我们可以发现每个Storage Object由三个字段组成，分别是一个32 bytes的key字段和32 bytess的value字段，以及外层的一个32 bytes 的字段。这三个字段在下面的例子中都表现为64位的16进制数(32 Bytes)。 下面我们来逐个解释一下这个三个值的实际意义。首先我们观察内部的Key-Value对，可以发现下面三个Storage Object中key的值其实是从0开始的递增整数，分别是0，1，2。它代表了当前Slot的地址索引值，或者说该Slot在Storage层对应的绝对位置(Position)。比如，key的值为0时，它代表整个Storage层中的第1个Slot，或者说在1号位置的Slot，当key等于1时代表Storage层中的第2个Slot，以此类推。每个Storage Object中的value变量，存储了合约中三个变量的值(1,2,3)。而Storage Object外层的值由等于Storage Object的key的值的sha3的哈希值。比如，下面例子中的第一个Storage Object的外层索引值”0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563” 是通过keccak256(0)计算出的值，代表了第一个Slot position的Sha3的哈希，而”0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6” 对应了是keccak(1)的值。我们在示例代码中展示了如何计算的过程。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; }, &quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot; } } 读者可能以及发现了，在这个Storage Object中，外层的索引值其实与Key值的关系是一一对应的，或者说这两个键值本质上都是关于Slot位置的唯一索引。这里我们简单讲述一下这两个值在使用上的区别。Key值代表了Slot在Storage层的Position，这个值用于会作为stateObject.go/getState()以及setState()函数的参数，用于定位Slot。如果我们继续深入上面的两个函数，我们就会发现，当内存中不存在该Slot的缓存时，geth就会尝试从更底层的数据库中来获取这个Slot的值。而Storage在更底层的数据，是由Secure Trie来维护的，Secure Trie中的Key值都是需要Hash的。所以在Secure Trie层我们查询/修改需要的键值就是外层的hash值。具体的关于Secure Trie的描述可以参考Trie这一章节。总结下来，在上层函数(stateObject)调用中使用的键值是Slot的Position，在下层的函数(Trie)调用中使用的键值是Slot的Position的哈希值。 func (t *SecureTrie) TryGet(key []byte) ([]byte, error) { // Secure Trie中查询的例子 // 这里的key还是Slot的Position // 但是在更下层的Call更下层的函数的时候使用了这个Key的hash值作为查询使用的键值。 return t.trie.TryGet(t.hashKey(key)) } Account Storage Example Two 下面我们来看另外的一个例子。在这个例子中，我们调整一下合约中变量的声明顺序，从(number，number1，number2)调整为(number 2, number 1, number)。合约代码如下所示。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number2; uint256 number; uint256 number; function stores(uint256 num) public { number = num; number1 = num + 1; number2 = num + 2; } function get_number() public view returns (uint256){ return number; } function get_number1() public view returns (uint256){ return number1; } function get_number2() public view returns (uint256){ return number2; } } 同样我们还是构造Transaction来调用合约中的stores函数。此时我们可以在Storage 层观察到不一样的结果。我们发现number2这个变量的值被存储在了第一个Slot中（Key:”0x0000000000000000000000000000000000000000000000000000000000000000”），而number这个变量的值北存储在了第三个Slot中 (Key:”0x0000000000000000000000000000000000000000000000000000000000000002”)。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot; }, &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; }, &quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; } } 这个例子可以说明，在Ethereum中，变量对应的存储层的Slot，是按照其在在合约中的声明顺序，从第一个Slot（position：0）开始分配的。 Account Storage Example Three 我们再考虑另一种情况：声明的三个变量，但只对其中的两个变量进行赋值。具体的来说，我们按照number，number1，和number2的顺序声明三个uint256变量。但是，在函数stores中只对number1和number2进行赋值操作。合约代码如下所示。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; uint256 number1; uint256 number2; function stores(uint256 num) public { number1 = num + 1; number2 = num + 2; } function get_number() public view returns (uint256){ return number; } function get_number1() public view returns (uint256){ return number1; } function get_number2() public view returns (uint256){ return number2; } } 基于上述合约，我们构造transaction 并调用stores函数，输入参数1，将number1和number2的值修改为2，和3。在transaction执行完成后，我们可以观察到Storage层Slot的结果如下所示。 { &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; }, &quot;0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000003&quot; } } 我们可以观察到，stores函数调用的结果只对在合约的Storage层中位置在1和2位置的两个Slot进行了赋值。值得注意的是，在本例中，对于Slot的赋值是从1号位置Slot的开始，而不是0号Slot。这说明对于固定长度的变量，其值的所占用的Slot的位置在Contract初始化开始的时候就已经分配的。即使变量只是被声明还没有真正的赋值，保存其值所需要的Slot也已经被EVM分配完毕。而不是在第一次进行变量赋值的时候，进行再对变量所需要的的Slot进行分配。 Account Storage Example Four 在Solidity中，有一类特殊的变量类型Address，通常用于表示账户的地址信息。例如在ERC-20合约中，用户拥有的token信息是被存储在一个(address-&amp;gt;uint)的map结构中。在这个map中，key就是Address类型的，它表示了用户实际的address。目前Address的大小为160bits(20bytes)，并不足以填满一整个Slot。因此当Address作为value单独存储在的时候，它并不会排他的独占用一个Slot。我们使用下面的例子来说明。 在下面的示例中，我们声明了三个变量，分别是number(uint256)，addr(address)，以及isTrue(bool)。我们知道，在以太坊中Address类型变量的长度是20 bytes，所以一个Address类型的变量是没办法填满整个的Slot(32 bytes)的。同时，布尔类型在以太坊中只需要一个bit(0 or 1)的空间。因此，我们构造transaction并调用函数storeaddr来给这三个变量赋值，函数的input参数是一个uint256的值，一个address类型的值，分别为{1, “0xb6186d3a3D32232BB21E87A33a4E176853a49d12”}。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; address addr; bool isTrue; function stores(uint256 num) public { // number1 = num + 1; // number2 = num + 2; } function storeaddr(uint256 num, address a) public { number = num; addr = a; isTure = true; } function get_number() public view returns (uint256){ return number; } } Transaction的运行后Storage层的结果如下面的Json所示。我们可以观察到，在本例中Contract声明了三个变量，但是在Storage层只调用了两个Slot。第一个Slot用于保存了uint256的值，而在第二个Slot中(Key:0x0000000000000000000000000000000000000000000000000000000000000001)保存了addr和isTrue的值。这里需要注意，虽然这种将两个小于32 bytes长的变量合并到一个Slot的做法节省了物理空间，但是也同样带来读写放大的问题。因为在Geth中，读操作最小的读的单位都是按照32bytes来进行的。在本例中，即使我们只需要读取isTrue或者addr这两个变量的值，在具体的函数调用中，我们仍然需要将对应的Slot先读取到内存中。同样的，如果我们想修改这两个变量的值，同样需要对整个的Slot进行重写。这无疑增加了额外的开销。所以在Ethereum使用32 bytes的变量，在某些情况下消耗的Gas反而比更小长度类型的变量要小(例如 unit8)。这也是为什么Ethereum官方也建议使用长度为32 bytes变量的原因。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot;, &quot;value&quot;: &quot;0x000000000000000000000001b6186d3a3d32232bb21e87a33a4e176853a49d12&quot; } } Account Storage Example Five 对于变长数组和Map结构的变量存储分配则相对的复杂。虽然Map本身就是key-value的结构，但是在Storage 层并不直接使用map中key的值或者key的值的sha3 哈希值来作为Storage分配的Slot的索引值。目前，Geth首先会使用map中元素的key的值和当前Map变量声明位置对应的slot的值进行拼接，再使用拼接后的值的keccak256哈希值作为Slot的位置索引(Position)。我们在下面的例子中展示了Geth是如何处理map这种变长的数据结构的。在下面的合约中，我们声明了一个定长的uint256类型的对象number，和一个[string=&amp;gt;uint256]类型的Map对象。 // SPDX-License-Identifier: GPL-3.0 pragma solidity &amp;gt;=0.7.0 &amp;lt;0.9.0; /** * @title Storage * @dev Store &amp;amp; retrieve value in a variable */ contract Storage { uint256 number; mapping(string =&amp;gt; uint256) balances; function set_balance(uint256 num) public { number = num; balances[&quot;hsy&quot;] = num; balances[&quot;lei&quot;] = num + 1; } function get_number() public view returns (uint256){ return number; } } 我们构造Transaction来调用了set_balance函数，在Transaction执行之后的Storage层的结果如下面的Json所示。我们发现，对于定长的变量number占据了第一个Slot的空间(Position:0x0000000000000000000000000000000000000000000000000000000000000000)。但是对于Map类型变量balances，它包含的两个数据并没有按照变量定义的物理顺序来定义Slot。此外，我们观察到存储这两个值的Slot的key，也并不是这两个字在mapping中key的直接hash。正如我们在上段中提到的那样，Geth会使用Map中元素的的key值与当前Map被分配的slot的位置进行拼接，之后对拼接之后对值进行使用keccak256函数求得哈希值，来最终得到map中元素最终的存储位置。比如在本例中，按照变量定义的顺序，balances这个Map变量会被分配到第二个Slot，对应的Slot Position是1。因此，balances中的kv对分配到的slot的位置就是，keccak(key, 1)，这里是一个特殊的拼接操作。 { &quot;0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563&quot;: { &quot;key&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0xa601d8e9cd2719ca27765dc16042655548d1ac3600a53ffc06b4a06a12b7c65c&quot;: { &quot;key&quot;: &quot;0xbaded3bf529b04b554de2e4ee0f5702613335896b4041c50a5555b2d5e279f91&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000001&quot; }, &quot;0x53ac6681d92653b13055d2e265b672e2db2b2a19407afb633928597f144edbb0&quot;: { &quot;key&quot;: &quot;0x56a8a0d158d59e2fd9317c46c65b1e902ed92f726ecfe82c06c33c015e8e6682&quot;, &quot;value&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000002&quot; } } 为了验证上面的说法，我们使用go语言编写了一段代码，来调用相关的库来验证一下上面的结论。对于 balances[“hsy”]，它被分配的Slot的位置可以由下面的代码求得。读者可以阅读/使用示例代码进行尝试。这里的k1是一个整形实数，代表了Slot的在storage层的位置(Position)。 k1 := solsha3.SoliditySHA3([]byte(&quot;hsy&quot;), solsha3.Uint256(big.NewInt(int64(1)))) fmt.Printf(&quot;Test the Solidity Map storage Key1: 0x%x\n&quot;, k1) Reference https://www.freecodecamp.org/news/how-to-generate-your-very-own-bitcoin-private-key-7ad0f4936e6c/</summary></entry><entry><title type="html">理解以太坊Go-Ethereum 源码剖析(00): 万物的起点: Geth Start !</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/02/geth.html" rel="alternate" type="text/html" title="理解以太坊Go-Ethereum 源码剖析(00): 万物的起点: Geth Start !" /><published>2022-01-02T10:00:00+08:00</published><updated>2022-01-02T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/02/geth</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/02/geth.html">&lt;h2 id=&quot;什么是geth&quot;&gt;什么是Geth？&lt;/h2&gt;

&lt;p&gt;Geth是基于Go语言开发以太坊的客户端，它实现了Ethereum协议(黄皮书)中所有需要的实现的功能模块，包括状态管理，挖矿，P2P网络通信，密码学，数据库，EVM解释器等。我们可以通过启动Geth来运行一个Ethereum的节点。Go-ethereum是包含了Geth在内的一个代码库，它包含了Geth，以及编译Geth所需要的其他代码。在本系列中，我们会深入Go-ethereum代码库，从High-level的API接口出发，沿着Ethereum主Workflow，从而理解Ethereum具体实现的细节。&lt;/p&gt;

&lt;h3 id=&quot;go-ethereum-codebase-结构&quot;&gt;Go-ethereum Codebase 结构&lt;/h3&gt;

&lt;p&gt;为了更好的从整体工作流的角度来理解Ethereum，根据主要的业务功能，我们将go-ethereum划分成如下几个模块来分析。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Geth Client模块&lt;/li&gt;
  &lt;li&gt;Core数据结构模块&lt;/li&gt;
  &lt;li&gt;State Management模块
    &lt;ul&gt;
      &lt;li&gt;StateDB 模块&lt;/li&gt;
      &lt;li&gt;Trie 模块&lt;/li&gt;
      &lt;li&gt;State Optimization (Pruning)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mining模块&lt;/li&gt;
  &lt;li&gt;EVM 模块&lt;/li&gt;
  &lt;li&gt;P2P 网络模块
    &lt;ul&gt;
      &lt;li&gt;节点数据同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前，go-ethereum项目的主要目录结构如下所示:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd/ ethereum相关的Command-line程序。该目录下的每个子目录都包含一个可运行的main.go。
   |── clef/ Ethereum官方推出的Account管理程序.
   |── geth/ Geth的本体。
core/   以太坊核心模块，包括核心数据结构，statedb，EVM等算法实现
   |── rawdb/ db相关函数的高层封装(在ethdb和更底层的leveldb之上的封装)
   |── state/
       ├──statedb.go  StateDB结构用于存储所有的与Merkle trie相关的存储, 包括一些循环state结构  
   |── types/  包括Block在内的以太坊核心数据结构
      |── block.go  以太坊block
      |── bloom9.go  一个Bloom Filter的实现
      |── transaction.go 以太坊transaction的数据结构与实现
      |── transaction_signing.go 用于对transaction进行签名的函数的实现
      |── receipt.go  以太坊收据的实现，用于说明以太坊交易的结果
   |── vm/
   |── genesis.go     创世区块相关的函数，在每个geth初始化的都需要调用这个模块
   |── tx_pool.go     Ethereum Transaction Pool的实现
consensus/
   |── consensus.go   共识相关的参数设定，包括Block Reward的数量
console/
   |── bridge.go
   |── console.go  Geth Web3 控制台的入口
ethdb/    Ethereum 本地存储的相关实现, 包括leveldb的调用
   |── leveldb/   Go-Ethereum使用的与Bitcoin Core version一样的Leveldb作为本机存储用的数据库
miner/
   |── miner.go   矿工模块的实现。
   |── worker.go  真正的block generation的实现实现，包括打包transaction，计算合法的Block
p2p/     Ethereum 的P2P模块
   |── params    Ethereum 的一些参数的配置，例如: bootnode的enode地址
   |── bootnodes.go  bootnode的enode地址 like: aws的一些节点，azure的一些节点，Ethereum Foundation的节点和 Rinkeby测试网的节点
rlp/     RLP的Encode与Decode的相关
rpc/     Ethereum RPC客户端的实现
les/     Ethereum light client的实现
trie/    Ethereum 中至关重要的数据结构 Merkle Patrica Trie(MPT)的实现
   |── committer.go    Trie向Memory Database提交数据的工具函数。
   |── database.go     Memory Database，是Trie数据和Disk Database提交的中间层。同时还实现了Trie剪枝的功能。**非常重要**
   |── node.go         MPT中的节点的定义以及相关的函数。
   |── secure_trie.go  基于Trie的封装的Trie结构。与trie中的函数功能相同，不过secure_trie中的key是经过hashKey()函数hash过的，无法通过路径获得原始的key值
   |── stack_trie.go   Block中使用的Transaction/Receipt Trie的实现
   |── trie.go         MPT具体功能的函数实现
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;geth-start&quot;&gt;Geth Start&lt;/h2&gt;

&lt;h3 id=&quot;前奏-geth-console&quot;&gt;前奏: Geth Console&lt;/h3&gt;

&lt;p&gt;当我们想要部署一个Ethereum节点的时候，最直接的方式就是下载官方提供的发行版的geth程序。Geth是一个基于CLI的应用，启动Geth和调用Geth的功能性API需要使用对应的指令来操作。Geth提供了一个相对友好的console来方便用户调用各种指令。当我第一次阅读Ethereum的文档的时候，我曾经有过这样的疑问，为什么Geth是由Go语言编写的，但是在官方文档中的Web3的API却是基于Javascript的调用？&lt;/p&gt;

&lt;p&gt;这是因为Geth内置了一个Javascript的解释器:å&lt;em&gt;Goja&lt;/em&gt; (interpreter)，来作为用户与Geth交互的CLI Console。我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console/console.go&lt;/code&gt;中找到它的定义。&lt;/p&gt;

&lt;!-- /*Goja is an implementation of ECMAScript 5.1 in Pure GO*/ --&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Console is a JavaScript interpreted runtime environment. It is a fully fledged&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// JavaScript console attached to a running node via an external or in-process RPC&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// client.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// RPC client to execute Ethereum requests through&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;jsre&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;jsre&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSRE&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;// JavaScript runtime environment running the interpreter&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// Input prompt prefix string&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;prompter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserPrompter&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Input prompter to allow interactive user feedback&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;histPath&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// Absolute path to the console scrollback history&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;history&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// Scroll history maintained by the console&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printer&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;// Output writer to serialize any display strings to&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;

&lt;p&gt;了解Ethereum，我们首先要了解Ethereum客户端Geth是怎么运行的。&lt;/p&gt;

&lt;p&gt;&lt;!-- `geth console 2` --&gt;&lt;/p&gt;

&lt;p&gt;Geth的启动点位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd/geth/main.go/main()&lt;/code&gt;函数处，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数非常的简短，其主要功能就是启动一个解析 command line命令的工具: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gopkg.in/urfave/cli.v1&lt;/code&gt;。我们会发现在cli app初始化的时候会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app.Action = geth&lt;/code&gt;，来调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数就是用于启动Ethereum节点的顶层函数，其代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Errorf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;invalid command: %q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;makeFullNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;startNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;backend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数，我们可以看到有三个比较重要的函数调用，分别是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeFullNode()&lt;/code&gt;，以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startNode()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare()&lt;/code&gt; 函数的实现就在当前的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.go&lt;/code&gt;文件中。它主要用于设置一些节点初始化需要的配置。比如，我们在节点启动时看到的这句话: &lt;em&gt;Starting Geth on Ethereum mainnet…&lt;/em&gt; 就是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;函数中被打印出来的。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeFullNode()&lt;/code&gt;函数的实现位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmd/geth/config.go&lt;/code&gt;文件中。它会将Geth启动时的命令的上下文加载到配置中，并生成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt;这两个实例。其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;是一个Node类型的实例，它是通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeFullNode()&lt;/code&gt;函数调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeConfigNode()&lt;/code&gt;函数来生成。Node是Geth生命周期中最顶级的实例，它的开启和关闭与Geth的启动和关闭直接对应。关于Node类型的定义位于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node/node.go&lt;/code&gt;文件中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend&lt;/code&gt;实例是指的是具体Ethereum Client的功能性实例。它是一个Ethereum类型的实例，负责提供更为具体的以太坊的功能性Service，比如管理Blockchain，共识算法等具体模块。它根据上下文的配置信息在调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.RegisterEthService()&lt;/code&gt;函数生成。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.RegisterEthService()&lt;/code&gt;函数中，首先会根据当前的config来判断需要生成的Ethereum backend的类型，是light node backend还是full node backend。我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eth/backend/new()&lt;/code&gt;函数和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;les/client.go/new()&lt;/code&gt;中找到这两种Ethereum backend的实例是如何初始化的。Ethereum backend的实例定义了一些更底层的配置，比如chainid，链使用的共识算法的类型等。这两种后端服务的一个典型的区别是light node backend不能启动Mining服务。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.RegisterEthService()&lt;/code&gt;函数的最后，调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nodes.RegisterAPIs()&lt;/code&gt;函数，将刚刚生成的backend实例注册到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;实例中。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;eth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ethereum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;eventMux&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EventMux&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;accountManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AccountManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;ethconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateConsensusEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethashConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Notify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Noverify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;closeBloomHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;networkID&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NetworkId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;gasPrice&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPrice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;etherbase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Etherbase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bloomRequests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bloombits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Retrieval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;bloomIndexer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;      &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewBloomIndexer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BloomBitsBlocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BloomConfirms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p2pServer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;shutdownTracker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;shutdowncheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewShutdownTracker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startNode()&lt;/code&gt;函数的作用是正式的启动一个Ethereum Node。它通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utils.StartNode()&lt;/code&gt;函数来触发&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.Start()&lt;/code&gt;函数来启动&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt;实例（Node）。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.Start()&lt;/code&gt;函数中，会遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.lifecycles&lt;/code&gt;中注册的后端实例，并在启动它们。此外，在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startNode()&lt;/code&gt;函数中，还是调用了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlockAccounts()&lt;/code&gt;函数，并将解锁的钱包注册到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;中，以及通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.Attach()&lt;/code&gt;函数创建了与local Geth交互的RPClient模块。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;geth()&lt;/code&gt;函数的最后，函数通过执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack.Wait()&lt;/code&gt;，使得主线程进入了监听状态，其他的功能模块的服务被分散到其他的子协程中进行维护。&lt;/p&gt;

&lt;h3 id=&quot;node&quot;&gt;Node&lt;/h3&gt;

&lt;p&gt;正如我们前面提到的，Node类型在Geth的生命周期性中属于顶级实例，它负责作为与外部通信的外部接口，比如管理rpc server，http server，Web Socket，以及P2P Server外部接口。同时，Node中维护了节点运行所需要的后端的实例和服务(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lifecycles  []Lifecycle&lt;/code&gt;)。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Node is a container on which services can be registered.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;eventmux&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMux&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;accman&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accounts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Manager&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;           &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;keyDir&lt;/span&gt;        &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// key store directory&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;keyDirTemp&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// If true, key directory will be removed by Stop&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;dirLock&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;fileutil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Releaser&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// prevents concurrent use of instance directory&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;          &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;// Channel to wait for termination notifications&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;// Currently running P2P networking layer&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;startStopLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// Start/Stop are protected by an additional lock&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;         &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;// Tracks state of node lifecycle&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;lifecycles&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lifecycle&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// All registered backends, services, and auxiliary services that have a lifecycle&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;rpcAPIs&lt;/span&gt;       &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;API&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// List of APIs currently provided by the node&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ws&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;httpAuth&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;wsAuth&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpServer&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;//&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ipc&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ipcServer&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Stores information about the ipc http server&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;inprocHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// In-process RPC request handler to process the API requests&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;databases&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closeTrackingDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// All open databases&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;ethereum-api-backend&quot;&gt;Ethereum API Backend&lt;/h3&gt;

&lt;p&gt;我们可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eth/backend.go&lt;/code&gt;中找到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum&lt;/code&gt;这个结构体的定义。这个结构体包含的成员变量以及接收的方法实现了一个Ethereum full node所需要的全部功能和数据结构。我们可以在下面的代码定义中看到，Ethereum结构体中包含了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TxPool&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Blockchain&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;consensus.Engine&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;miner&lt;/code&gt;等最核心的几个数据结构作为成员变量，我们会在后面的章节中详细的讲述这些核心数据结构的主要功能，以及它们的实现的方法。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Ethereum implements the Ethereum full node service.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ethereum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Handlers&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txPool&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxPool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;blockchain&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockChain&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ethDialCandidates&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;enode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;snapDialCandidates&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;enode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Merger&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// DB interfaces&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;chainDb&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ethdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Block chain database&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;eventMux&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMux&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;consensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Engine&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;accountManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accounts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Manager&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;bloomRequests&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bloombits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Retrieval&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Channel receiving bloom data retrieval requests&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;bloomIndexer&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainIndexer&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;// Bloom indexer operating during block imports&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;closeBloomHandler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;APIBackend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EthAPIBackend&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;miner&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Miner&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;gasPrice&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;etherbase&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;networkID&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;netRPCService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ethapi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PublicNetAPI&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;p2pServer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Server&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RWMutex&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Protects the variadic fields (e.g. gas price and etherbase)&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;shutdownTracker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shutdowncheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShutdownTracker&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Tracks if and when the node has shutdown ungracefully&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;节点启动和停止Mining的就是通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.StartMining()&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.StopMining()&lt;/code&gt;实现的。设置Mining的收益账户是通过调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.SetEtherbase()&lt;/code&gt;实现的。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// StartMining starts the miner with the given number of CPU threads. If mining&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// is already running, this method adjust the number of threads allowed to use&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// and updates the minimum price required by the transaction pool.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ethereum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StartMining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// If the miner was not running, initialize it&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsMining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
      &lt;span class=&quot;c&quot;&gt;// Start Mining&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;miner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们额外关注一下&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;这个成员变量。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;的定义在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eth/handler.go&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;我们从从宏观角度来看，一个节点的主工作流需要: 1.从网络中获取/同步Transaction和Block的数据 2. 将网络中获取到Block添加到Blockchain中。而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;handler&lt;/code&gt;就维护了backend中同步/请求数据的实例，比如&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;downloader.Downloader&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetcher.TxFetcher&lt;/code&gt;。关于这些成员变量的具体实现，我们会在后续的文章中详细介绍。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;networkID&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;forkFilter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forkid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Fork ID filter, constant across the lifetime of the node&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;snapSync&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Flag whether snap sync is enabled (gets disabled if we already have blocks)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;acceptTxs&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Flag whether we&apos;re considered synchronised (enables transaction processing)&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;checkpointNumber&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// Block number for the sync progress validator to cross reference&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;checkpointHash&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Block hash for the sync progress validator to cross reference&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ethdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txpool&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;txPool&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockChain&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;maxPeers&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Downloader&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;blockFetcher&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockFetcher&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txFetcher&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TxFetcher&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;peers&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peerSet&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;merger&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consensus&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Merger&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;eventMux&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMux&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txsCh&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;core&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewTxsEvent&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;txsSub&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Subscription&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;minedBlockSub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TypeMuxSubscription&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;peerRequiredBlocks&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// channels for fetcher, syncer, txsyncLoop&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;quitSync&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;chainSync&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chainSyncer&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;peerWG&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，我们就介绍了Geth及其所需要的基本模块是如何启动的。我们在接下来将视角转入到各个模块中，从更细粒度的角度深入Ethereum的实现。&lt;/p&gt;

&lt;h3 id=&quot;appendix&quot;&gt;Appendix&lt;/h3&gt;

&lt;p&gt;这里补充一个Go语言的语法知识: &lt;strong&gt;类型断言&lt;/strong&gt;。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ethereum.StartMining()&lt;/code&gt;函数中，出现了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if c, ok := s.engine.(*clique.Clique); ok&lt;/code&gt;的写法。这中写法是Golang中的语法糖，称为类型断言。具体的语法是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value, ok := element.(T)&lt;/code&gt;，它的含义是如果&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;element&lt;/code&gt;是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt;类型的话，那么ok等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;element&lt;/code&gt;的值。在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if c, ok := s.engine.(*clique.Clique); ok&lt;/code&gt;语句中，就是在判断&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s.engine&lt;/code&gt;的是否为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*clique.Clique&lt;/code&gt;类型。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clique&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clique&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clique&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beacon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Beacon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnerEngine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clique&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Clique&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cli&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">什么是Geth？ Geth是基于Go语言开发以太坊的客户端，它实现了Ethereum协议(黄皮书)中所有需要的实现的功能模块，包括状态管理，挖矿，P2P网络通信，密码学，数据库，EVM解释器等。我们可以通过启动Geth来运行一个Ethereum的节点。Go-ethereum是包含了Geth在内的一个代码库，它包含了Geth，以及编译Geth所需要的其他代码。在本系列中，我们会深入Go-ethereum代码库，从High-level的API接口出发，沿着Ethereum主Workflow，从而理解Ethereum具体实现的细节。 Go-ethereum Codebase 结构 为了更好的从整体工作流的角度来理解Ethereum，根据主要的业务功能，我们将go-ethereum划分成如下几个模块来分析。 Geth Client模块 Core数据结构模块 State Management模块 StateDB 模块 Trie 模块 State Optimization (Pruning) Mining模块 EVM 模块 P2P 网络模块 节点数据同步 … 目前，go-ethereum项目的主要目录结构如下所示: cmd/ ethereum相关的Command-line程序。该目录下的每个子目录都包含一个可运行的main.go。 |── clef/ Ethereum官方推出的Account管理程序. |── geth/ Geth的本体。 core/ 以太坊核心模块，包括核心数据结构，statedb，EVM等算法实现 |── rawdb/ db相关函数的高层封装(在ethdb和更底层的leveldb之上的封装) |── state/ ├──statedb.go StateDB结构用于存储所有的与Merkle trie相关的存储, 包括一些循环state结构 |── types/ 包括Block在内的以太坊核心数据结构 |── block.go 以太坊block |── bloom9.go 一个Bloom Filter的实现 |── transaction.go 以太坊transaction的数据结构与实现 |── transaction_signing.go 用于对transaction进行签名的函数的实现 |── receipt.go 以太坊收据的实现，用于说明以太坊交易的结果 |── vm/ |── genesis.go 创世区块相关的函数，在每个geth初始化的都需要调用这个模块 |── tx_pool.go Ethereum Transaction Pool的实现 consensus/ |── consensus.go 共识相关的参数设定，包括Block Reward的数量 console/ |── bridge.go |── console.go Geth Web3 控制台的入口 ethdb/ Ethereum 本地存储的相关实现, 包括leveldb的调用 |── leveldb/ Go-Ethereum使用的与Bitcoin Core version一样的Leveldb作为本机存储用的数据库 miner/ |── miner.go 矿工模块的实现。 |── worker.go 真正的block generation的实现实现，包括打包transaction，计算合法的Block p2p/ Ethereum 的P2P模块 |── params Ethereum 的一些参数的配置，例如: bootnode的enode地址 |── bootnodes.go bootnode的enode地址 like: aws的一些节点，azure的一些节点，Ethereum Foundation的节点和 Rinkeby测试网的节点 rlp/ RLP的Encode与Decode的相关 rpc/ Ethereum RPC客户端的实现 les/ Ethereum light client的实现 trie/ Ethereum 中至关重要的数据结构 Merkle Patrica Trie(MPT)的实现 |── committer.go Trie向Memory Database提交数据的工具函数。 |── database.go Memory Database，是Trie数据和Disk Database提交的中间层。同时还实现了Trie剪枝的功能。**非常重要** |── node.go MPT中的节点的定义以及相关的函数。 |── secure_trie.go 基于Trie的封装的Trie结构。与trie中的函数功能相同，不过secure_trie中的key是经过hashKey()函数hash过的，无法通过路径获得原始的key值 |── stack_trie.go Block中使用的Transaction/Receipt Trie的实现 |── trie.go MPT具体功能的函数实现 Geth Start 前奏: Geth Console 当我们想要部署一个Ethereum节点的时候，最直接的方式就是下载官方提供的发行版的geth程序。Geth是一个基于CLI的应用，启动Geth和调用Geth的功能性API需要使用对应的指令来操作。Geth提供了一个相对友好的console来方便用户调用各种指令。当我第一次阅读Ethereum的文档的时候，我曾经有过这样的疑问，为什么Geth是由Go语言编写的，但是在官方文档中的Web3的API却是基于Javascript的调用？ 这是因为Geth内置了一个Javascript的解释器:åGoja (interpreter)，来作为用户与Geth交互的CLI Console。我们可以在console/console.go中找到它的定义。 // Console is a JavaScript interpreted runtime environment. It is a fully fledged // JavaScript console attached to a running node via an external or in-process RPC // client. type Console struct { client *rpc.Client // RPC client to execute Ethereum requests through jsre *jsre.JSRE // JavaScript runtime environment running the interpreter prompt string // Input prompt prefix string prompter prompt.UserPrompter // Input prompter to allow interactive user feedback histPath string // Absolute path to the console scrollback history history []string // Scroll history maintained by the console printer io.Writer // Output writer to serialize any display strings to } 启动 了解Ethereum，我们首先要了解Ethereum客户端Geth是怎么运行的。 Geth的启动点位于cmd/geth/main.go/main()函数处，如下所示。 func main() { if err := app.Run(os.Args); err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(1) } } 我们可以看到main()函数非常的简短，其主要功能就是启动一个解析 command line命令的工具: gopkg.in/urfave/cli.v1。我们会发现在cli app初始化的时候会调用app.Action = geth，来调用geth()函数。geth()函数就是用于启动Ethereum节点的顶层函数，其代码如下所示。 func geth(ctx *cli.Context) error { if args := ctx.Args(); len(args) &amp;gt; 0 { return fmt.Errorf(&quot;invalid command: %q&quot;, args[0]) } prepare(ctx) stack, backend := makeFullNode(ctx) defer stack.Close() startNode(ctx, stack, backend, false) stack.Wait() return nil } 在geth()函数，我们可以看到有三个比较重要的函数调用，分别是：prepare()，makeFullNode()，以及startNode()。 prepare() 函数的实现就在当前的main.go文件中。它主要用于设置一些节点初始化需要的配置。比如，我们在节点启动时看到的这句话: Starting Geth on Ethereum mainnet… 就是在prepare()函数中被打印出来的。 makeFullNode()函数的实现位于cmd/geth/config.go文件中。它会将Geth启动时的命令的上下文加载到配置中，并生成stack和backend这两个实例。其中stack是一个Node类型的实例，它是通过makeFullNode()函数调用makeConfigNode()函数来生成。Node是Geth生命周期中最顶级的实例，它的开启和关闭与Geth的启动和关闭直接对应。关于Node类型的定义位于node/node.go文件中。 backend实例是指的是具体Ethereum Client的功能性实例。它是一个Ethereum类型的实例，负责提供更为具体的以太坊的功能性Service，比如管理Blockchain，共识算法等具体模块。它根据上下文的配置信息在调用utils.RegisterEthService()函数生成。在utils.RegisterEthService()函数中，首先会根据当前的config来判断需要生成的Ethereum backend的类型，是light node backend还是full node backend。我们可以在eth/backend/new()函数和les/client.go/new()中找到这两种Ethereum backend的实例是如何初始化的。Ethereum backend的实例定义了一些更底层的配置，比如chainid，链使用的共识算法的类型等。这两种后端服务的一个典型的区别是light node backend不能启动Mining服务。在utils.RegisterEthService()函数的最后，调用了Nodes.RegisterAPIs()函数，将刚刚生成的backend实例注册到stack实例中。 eth := &amp;amp;Ethereum{ config: config, merger: merger, chainDb: chainDb, eventMux: stack.EventMux(), accountManager: stack.AccountManager(), engine: ethconfig.CreateConsensusEngine(stack, chainConfig, &amp;amp;ethashConfig, config.Miner.Notify, config.Miner.Noverify, chainDb), closeBloomHandler: make(chan struct{}), networkID: config.NetworkId, gasPrice: config.Miner.GasPrice, etherbase: config.Miner.Etherbase, bloomRequests: make(chan chan *bloombits.Retrieval), bloomIndexer: core.NewBloomIndexer(chainDb, params.BloomBitsBlocks, params.BloomConfirms), p2pServer: stack.Server(), shutdownTracker: shutdowncheck.NewShutdownTracker(chainDb), } startNode()函数的作用是正式的启动一个Ethereum Node。它通过调用utils.StartNode()函数来触发Node.Start()函数来启动Stack实例（Node）。在Node.Start()函数中，会遍历Node.lifecycles中注册的后端实例，并在启动它们。此外，在startNode()函数中，还是调用了unlockAccounts()函数，并将解锁的钱包注册到stack中，以及通过stack.Attach()函数创建了与local Geth交互的RPClient模块。 在geth()函数的最后，函数通过执行stack.Wait()，使得主线程进入了监听状态，其他的功能模块的服务被分散到其他的子协程中进行维护。 Node 正如我们前面提到的，Node类型在Geth的生命周期性中属于顶级实例，它负责作为与外部通信的外部接口，比如管理rpc server，http server，Web Socket，以及P2P Server外部接口。同时，Node中维护了节点运行所需要的后端的实例和服务(lifecycles []Lifecycle)。 // Node is a container on which services can be registered. type Node struct { eventmux *event.TypeMux config *Config accman *accounts.Manager log log.Logger keyDir string // key store directory keyDirTemp bool // If true, key directory will be removed by Stop dirLock fileutil.Releaser // prevents concurrent use of instance directory stop chan struct{} // Channel to wait for termination notifications server *p2p.Server // Currently running P2P networking layer startStopLock sync.Mutex // Start/Stop are protected by an additional lock state int // Tracks state of node lifecycle lock sync.Mutex lifecycles []Lifecycle // All registered backends, services, and auxiliary services that have a lifecycle rpcAPIs []rpc.API // List of APIs currently provided by the node http *httpServer // ws *httpServer // httpAuth *httpServer // wsAuth *httpServer // ipc *ipcServer // Stores information about the ipc http server inprocHandler *rpc.Server // In-process RPC request handler to process the API requests databases map[*closeTrackingDB]struct{} // All open databases } Ethereum API Backend 我们可以在eth/backend.go中找到Ethereum这个结构体的定义。这个结构体包含的成员变量以及接收的方法实现了一个Ethereum full node所需要的全部功能和数据结构。我们可以在下面的代码定义中看到，Ethereum结构体中包含了TxPool，Blockchain，consensus.Engine，miner等最核心的几个数据结构作为成员变量，我们会在后面的章节中详细的讲述这些核心数据结构的主要功能，以及它们的实现的方法。 // Ethereum implements the Ethereum full node service. type Ethereum struct { config *ethconfig.Config // Handlers txPool *core.TxPool blockchain *core.BlockChain handler *handler ethDialCandidates enode.Iterator snapDialCandidates enode.Iterator merger *consensus.Merger // DB interfaces chainDb ethdb.Database // Block chain database eventMux *event.TypeMux engine consensus.Engine accountManager *accounts.Manager bloomRequests chan chan *bloombits.Retrieval // Channel receiving bloom data retrieval requests bloomIndexer *core.ChainIndexer // Bloom indexer operating during block imports closeBloomHandler chan struct{} APIBackend *EthAPIBackend miner *miner.Miner gasPrice *big.Int etherbase common.Address networkID uint64 netRPCService *ethapi.PublicNetAPI p2pServer *p2p.Server lock sync.RWMutex // Protects the variadic fields (e.g. gas price and etherbase) shutdownTracker *shutdowncheck.ShutdownTracker // Tracks if and when the node has shutdown ungracefully } 节点启动和停止Mining的就是通过调用Ethereum.StartMining()和Ethereum.StopMining()实现的。设置Mining的收益账户是通过调用Ethereum.SetEtherbase()实现的。 // StartMining starts the miner with the given number of CPU threads. If mining // is already running, this method adjust the number of threads allowed to use // and updates the minimum price required by the transaction pool. func (s *Ethereum) StartMining(threads int) error { ... // If the miner was not running, initialize it if !s.IsMining() { ... // Start Mining go s.miner.Start(eb) } return nil } 这里我们额外关注一下handler这个成员变量。handler的定义在eth/handler.go中。 我们从从宏观角度来看，一个节点的主工作流需要: 1.从网络中获取/同步Transaction和Block的数据 2. 将网络中获取到Block添加到Blockchain中。而handler就维护了backend中同步/请求数据的实例，比如downloader.Downloader，fetcher.TxFetcher。关于这些成员变量的具体实现，我们会在后续的文章中详细介绍。 type handler struct { networkID uint64 forkFilter forkid.Filter // Fork ID filter, constant across the lifetime of the node snapSync uint32 // Flag whether snap sync is enabled (gets disabled if we already have blocks) acceptTxs uint32 // Flag whether we&apos;re considered synchronised (enables transaction processing) checkpointNumber uint64 // Block number for the sync progress validator to cross reference checkpointHash common.Hash // Block hash for the sync progress validator to cross reference database ethdb.Database txpool txPool chain *core.BlockChain maxPeers int downloader *downloader.Downloader blockFetcher *fetcher.BlockFetcher txFetcher *fetcher.TxFetcher peers *peerSet merger *consensus.Merger eventMux *event.TypeMux txsCh chan core.NewTxsEvent txsSub event.Subscription minedBlockSub *event.TypeMuxSubscription peerRequiredBlocks map[uint64]common.Hash // channels for fetcher, syncer, txsyncLoop quitSync chan struct{} chainSync *chainSyncer wg sync.WaitGroup peerWG sync.WaitGroup } 这样，我们就介绍了Geth及其所需要的基本模块是如何启动的。我们在接下来将视角转入到各个模块中，从更细粒度的角度深入Ethereum的实现。 Appendix 这里补充一个Go语言的语法知识: 类型断言。在Ethereum.StartMining()函数中，出现了if c, ok := s.engine.(*clique.Clique); ok的写法。这中写法是Golang中的语法糖，称为类型断言。具体的语法是value, ok := element.(T)，它的含义是如果element是T类型的话，那么ok等于True, value等于element的值。在if c, ok := s.engine.(*clique.Clique); ok语句中，就是在判断s.engine的是否为*clique.Clique类型。 var cli *clique.Clique if c, ok := s.engine.(*clique.Clique); ok { cli = c } else if cl, ok := s.engine.(*beacon.Beacon); ok { if c, ok := cl.InnerEngine().(*clique.Clique); ok { cli = c } }</summary></entry><entry><title type="html">Understanding Ethereum: Starting with go-ethereum Source Code｜理解以太坊: Go-Ethereum 源码剖析</title><link href="http://www.hsyodyssey.com/blockchain/2022/01/01/understand-ethereum.html" rel="alternate" type="text/html" title="Understanding Ethereum: Starting with go-ethereum Source Code｜理解以太坊: Go-Ethereum 源码剖析" /><published>2022-01-01T10:00:00+08:00</published><updated>2022-01-01T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2022/01/01/understand-ethereum</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2022/01/01/understand-ethereum.html">&lt;h2 id=&quot;preface&quot;&gt;Preface&lt;/h2&gt;

&lt;h3 id=&quot;background&quot;&gt;Background&lt;/h3&gt;

&lt;p&gt;距中本聪发表比特币白皮书至今已经过了十几年的时光。Blockchain这一理念，从最开始作为支持Bitcoin的分布式账本系统出发，在这十几年的演化中不断发展，从专注于加密货币到如今的逐渐通用化，逐渐成为了集成了包括&lt;em&gt;数据库&lt;/em&gt;，&lt;em&gt;分布式系统&lt;/em&gt;，&lt;em&gt;点对点网络&lt;/em&gt;，&lt;em&gt;编译原理&lt;/em&gt;，&lt;em&gt;静态软件分析&lt;/em&gt;，&lt;em&gt;众包&lt;/em&gt;，&lt;em&gt;密码学&lt;/em&gt;，&lt;em&gt;经济学&lt;/em&gt;，&lt;em&gt;货币金融学&lt;/em&gt;，&lt;em&gt;社会学&lt;/em&gt;在内的等多个学科知识的一个全新技术领域。至今仍然是时下&lt;strong&gt;最热度最高&lt;/strong&gt;，&lt;strong&gt;最能引起社会讨论&lt;/strong&gt;的技术话题之一，逐渐从小众的去中心化社区逐渐走向了主流社会的舞台。&lt;/p&gt;

&lt;p&gt;目前，市面上绝大多数的热门Blockchain系统都已经开源，并继续以开源的形式在社区的维护下持续开发中。这就为我们提供了一种的极好的学习Blockchain技术的方式: 通过结合文档，结合源代码的方式基于State-of-the-arts的Blockchain Systems出发开始学习。&lt;/p&gt;

&lt;p&gt;一个热门的技术总是会有大量的文档，资料，经过不同视角的作者记录下来。不管是探究以加密货币导向（Crypto-based）的Bitcoin, 还是了解致力于实现通用Web3.0框架（General-Purpose）的Ethereum，有丰厚的文档从high-level的角度来讲述它们的基础概念，以及设计的思想。比如，技术社区有非常多的资料来讲述什么是梅克尔树 (Merkle Hash Tree)，什么是梅克尔帕特里夏树 (Merkle Patricia Tree)，什么是有向无环图 (Directed acyclic Graph); BFT (Byzantine Fault Tolerance)和 PoW (Proof-Of-Work) 共识算法算法的区别; 以及介绍Blockchain系统为什么可以抵抗双花攻击 (Double-Spending)，或者为什么Ethereum会遇到 DAO Attack (Decentralized autonomous organization) 等具体问题。&lt;/p&gt;

&lt;p&gt;但是，只了解关键组件的实现细节，或者高度抽象的系统工作流，并不代表着可以让读者从真正搞清楚Blockchain的工作原理，反而很容易让读者在一些关键细节上一头雾水，似懂非懂。比如，当我们谈到Blockchain系统中Transaction的生命周期，我们在文档中经常会读到，Miner节点批量地从自己维护的Transaction pool中选择一些Transaction并打包成一个新的Block中。那么究竟miner是怎么从网络中获取到Transaction？又是继续什么样的选择策略从Transaction pool中选取Transaction？最终按照怎么的order把transaction打包进区块链中的呢？如何打包成功的Block是怎么交互给其他节点呢？我尝试去搜索了一下，发现鲜有文章从&lt;em&gt;整体&lt;/em&gt;的系统工作流的角度出发，对以细粒度的视角对区块链系统中的具体的实现&lt;em&gt;细节&lt;/em&gt;进行解析。与数据库系统(Database Management System)相似，Blockchain系统同样是一个包含网络层，业务逻辑层，任务解析层，存储层的复杂数据管理系统。对它研究同样需要从系统的实现细节出发，从宏观到微观的了解每个执行逻辑的工作流，才能彻底理解和掌握这门技术的秘密。&lt;/p&gt;

&lt;p&gt;笔者坚信，随着网络基础架构的不断完善，将带来的显著的带宽上升和通信延迟下降。同时随着存储技术以及算法的不断发展，未来系统的运行效率将会不断逼近硬件极限。在未来的是五到十年内，云端服务/去中心化系统的效率以及覆盖场景一定还会有很大的提升。未来技术世界一定是两极分化的。一极是以大云计算公司（i.e, Google，MS，Oracle，Snowflake，and Alibaba）为代表的中心化服务商。另一极就是以Blockchain技术作为核心的去中心化的世界。在这个世界中，Ethereum及其生态系统是当之无愧的领头羊。Ethereum 不仅在作为Public Chain的自身取得了巨大的成功，构建了强大的生态系统，并且吸引一大批世界上最优秀的工程师，研究人员的持续的发力，不断的将新思想，新理念，新技术引入到Ethereum中，持续的引领Blockchain技术发展。而且Go-Ethereum作为其优秀的开源实现，已经被广泛的订制，来适应不同的私有/联盟场景(e.g., Quorum, Binance Smart Chain)。因此，要想真正掌握好区块链系统的原理，达到可以设计开发区块链系统的水平，研究好Ethereum的原理以及其设计思想是非常有必要。&lt;/p&gt;

&lt;p&gt;本系列文章，作为我在博士期间学习/研究的记录，将会从Blockchain中具体业务的工作的视角出发，在源码的层面细粒度的解析以太坊系统中各个模块的实现的细节，以及背后的蕴含的技术和设计思想。同时，在阅读源代码中发现的问题也可以会提交Pr来贡献社区。本系列基于的代码库是Go-ethereum version 1.10.*。Go-ethereum是以太坊协议的Go语言实现版本，目前由以太坊基金会维护。目前除了Go-ethereum之外，Ethereum还有C++, Python，Java, Rust等基于其他语言实现的版本。相比于其他的社区版实现，go-ethereum的用户数量最多，开发人员最多，版本更新最频繁，issues的发现和处理都较快，运行也更更加的稳定。其他语言的Ethereum实现版本因为用户与开发人员的数量相对较少，更新频率相对较低，隐藏问题出现的可能性更高。因此我们选择从Go-ethereum代码库作为我们的主要学习资料，来理解Ethereum系统与网络的设计实现。&lt;/p&gt;

&lt;h3 id=&quot;为什么要阅读区块链系统的源代码&quot;&gt;为什么要阅读区块链系统的源代码&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;文档资料相对较少，且&lt;strong&gt;内容浅尝辄止&lt;/strong&gt;，&lt;strong&gt;相互独立&lt;/strong&gt;。比如，&lt;em&gt;很多的科普文章都提到，在打包新的Block的时候，miner负责把a batch of transactions从transaction pool中打包到新的block中&lt;/em&gt;。那么我们希望读者思考如下的几个问题：
    &lt;ul&gt;
      &lt;li&gt;Miner是基于什么样策略从Transaction Pool中选择Transaction呢？&lt;/li&gt;
      &lt;li&gt;被选择的Transactions又是以怎样的顺序(Order)被打包到区块中的呢？&lt;/li&gt;
      &lt;li&gt;在执行Transaction的EVM是怎么计算gas used，从而限定Block中Transaction的数量的呢?&lt;/li&gt;
      &lt;li&gt;剩余的gas又是怎么返还给Transaction Proposer的呢？&lt;/li&gt;
      &lt;li&gt;EVM是怎么解释Contract的Message Call并执行的呢？&lt;/li&gt;
      &lt;li&gt;在执行Transaction中是哪个模块，又是怎样去修改Contract中的持久化变量呢？&lt;/li&gt;
      &lt;li&gt;Smart Contract中的持久化变量又是以什么样的形式存储的呢？&lt;/li&gt;
      &lt;li&gt;当新的Block加入到Blockchain中时，World State又是何时怎样更新的呢？&lt;/li&gt;
      &lt;li&gt;哪些数据常驻内存，哪些数据又需要保存在Disk中呢？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;目前的Blockchain系统并没有像数据库系统(DBMS)那样统一实现的方法论，每个不同的系统中都集成了大量的细节。从源码的角度出发可以了解到很多容易被忽视的细节。简单的说，一个完整的区块链系统至少包含以下的模块:
    &lt;ul&gt;
      &lt;li&gt;密码学模块: 加解密，签名，安全hash，Mining&lt;/li&gt;
      &lt;li&gt;网络模块: P2P节点通信&lt;/li&gt;
      &lt;li&gt;分布式共识模块: PoW, BFT&lt;/li&gt;
      &lt;li&gt;智能合约解释器模块: Solidity编译语言，EVM解释器&lt;/li&gt;
      &lt;li&gt;数据存储模块: 数据库，数据存储，Index，LevelDB&lt;/li&gt;
      &lt;li&gt;Log日志模块&lt;/li&gt;
      &lt;li&gt;etc.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在具体实现中，由于设计理念，以及go语言的特性(没有继承派生关系)，go-ethereum中的模块之间相互调用关系相对复杂。因此，只有通过阅读源码的方式才能更好理解不同模块之间的调用关系，以及业务的workflow的执行流程/细节。&lt;/p&gt;

&lt;h3 id=&quot;blockchain-system-bcs-vs-database-management-system-dbms&quot;&gt;Blockchain System (BCS) VS Database Management System (DBMS)&lt;/h3&gt;

&lt;p&gt;Blockchain 系统在设计层面借鉴了很多数据库系统中的设计逻辑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Blockchain系统同样也从Transaction作为基本的操作载核，包含一个Parser模块，Transaction Executor模块，和一个Storage 管理模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;contents暂定&quot;&gt;Contents(暂定)&lt;/h2&gt;

&lt;h3 id=&quot;part-one---general-source-code-analysis-basic-components&quot;&gt;PART ONE - General Source Code Analysis: Basic Components&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2022/01/02/geth.html&quot;&gt;00_万物的起点: Geth Start&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2022/01/02/ethereum-account.html&quot;&gt;01_State-based 模型 &amp;amp; Account&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hsyodyssey.com/blockchain/2022/01/03/ethereum_txn.html&quot;&gt;02_Transaction: 一个Transaction的生老病死&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[03_从Block到Blockchain: 区块链数据结构的构建]&lt;/li&gt;
  &lt;li&gt;[04_一个新节点是怎么加入网络并同步区块的]&lt;/li&gt;
  &lt;li&gt;[05_一个网吧老板是怎么用闲置的电脑进行挖矿的]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-two---general-source-code-analysis-services&quot;&gt;PART TWO - General Source Code Analysis: Services&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[10_StateDB的实例是如何构建的]&lt;/li&gt;
  &lt;li&gt;[11_Blockchain的数据是如何持久化的]&lt;/li&gt;
  &lt;li&gt;[12_Signer: 如何证明Transaction是合法的]&lt;/li&gt;
  &lt;li&gt;[13_节点的调用 RPC and IPC]&lt;/li&gt;
  &lt;li&gt;[14_深入EVM: 设计与实现]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-three---advanced-topics&quot;&gt;PART THREE - Advanced Topics&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[20_结合BFT Consensus 解决拜占庭将军问题]&lt;/li&gt;
  &lt;li&gt;[21_从Plasma到Rollup]&lt;/li&gt;
  &lt;li&gt;[22_Authenticated data structures Brief]&lt;/li&gt;
  &lt;li&gt;[23_Bloom Filter]&lt;/li&gt;
  &lt;li&gt;[24_图灵机和停机问题]&lt;/li&gt;
  &lt;li&gt;[25_Log-structured merge-tree in Ethereum]&lt;/li&gt;
  &lt;li&gt;[26_Concurrency in Ethereum Transaction]&lt;/li&gt;
  &lt;li&gt;[27_Zero-knowledge Proof]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-four---ethereum-in-practice&quot;&gt;PART FOUR - Ethereum in Practice&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[30_使用geth构建一个私有网络]&lt;/li&gt;
  &lt;li&gt;[31_如何编写Solidity语言]&lt;/li&gt;
  &lt;li&gt;[32_使用预言机(Oracle)构建随机化的DApp]&lt;/li&gt;
  &lt;li&gt;[33_Query On Ethereum Data]&lt;/li&gt;
  &lt;li&gt;[34_layer2 in Practice]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-five---appendix&quot;&gt;PART FIVE - APPENDIX&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[40_FQA]&lt;/li&gt;
  &lt;li&gt;[41_Ethereum System Tunning]&lt;/li&gt;
  &lt;li&gt;[42_go-ethereum的开发思想]&lt;/li&gt;
  &lt;li&gt;[43_Metrics in Ethereum]&lt;/li&gt;
  &lt;li&gt;[44_Golang with Ethereum]&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;how-to-measure-the-level-of-understanding-of-a-system&quot;&gt;How to measure the level of understanding of a system？&lt;/h2&gt;

&lt;p&gt;如何衡量对一个系统的理解程度?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Level 4: 掌握（Mastering）
    &lt;ul&gt;
      &lt;li&gt;在完全理解的基础上，可以设计并编写一个新的系统&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Level 3: 完全理解（Complete Understanding）
    &lt;ul&gt;
      &lt;li&gt;在理解的基础上，完全掌握系统的各项实现的细节，并能做出优化&lt;/li&gt;
      &lt;li&gt;可以对现有的系统定制化到不同的应用场景&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Level 2: 理解（Understanding）
    &lt;ul&gt;
      &lt;li&gt;熟练使用系统提供的API&lt;/li&gt;
      &lt;li&gt;了解系统模块的调用关系&lt;/li&gt;
      &lt;li&gt;能对系统的部分模块进行简单修改/重构&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Level 1:了解（Brief understanding）
    &lt;ul&gt;
      &lt;li&gt;了解系统设计的目标，了解系统的应用场景&lt;/li&gt;
      &lt;li&gt;可以使用系统的部分的API&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们希望读者在阅读完本作之后，对Ethereum的理解能够达到 Level 2 - Level 3的水平。&lt;/p&gt;

&lt;h2 id=&quot;some-details&quot;&gt;Some Details&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;以太坊是基于State状态机模型的区块链系统，Miner在update new Block的时候，会直接修改自身的状态（添加区块奖励给自己）。所以与Bitcoin不同的是，Ethereum的区块中，并没有类似的Coinbase的transaction。&lt;/li&gt;
  &lt;li&gt;在core/transaction.go 中, transaction的的数据结构是有time.Time的参数的。但是在下面的newTransaction的function中只是使用Local的time.now()对Transaction.time进行初始化。&lt;/li&gt;
  &lt;li&gt;在core/transaction.go 的transaction 数据结构定义的时候, 在transaction.time 后面的注释写到（Time first seen locally (spam avoidance), Time 只是用于在本地首次看到的时间。&lt;/li&gt;
  &lt;li&gt;uncle block中的transaction 不会被包括到主链上。&lt;/li&gt;
  &lt;li&gt;go-ethereum有专用函数来控制每次transaction执行完，返还给用户的Gas的量。有根据EIP-3529，每次最多返还50%的gas.&lt;/li&gt;
  &lt;li&gt;不同的Contracts的数据会混合的保存在底层的一个LevelDB instance中。&lt;/li&gt;
  &lt;li&gt;LevelDB中保存的是MPT的Node信息。&lt;/li&gt;
  &lt;li&gt;在以太坊中，通常先执行Finalise函数 -&amp;gt; 然后执行Commit函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;关键函数&quot;&gt;关键函数&lt;/h2&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c&quot;&gt;// 向leveldb中更新Storage 数据&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WritePreimages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ethdb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KeyValueWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preimages&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 向Blockchain中添加新的Block，会涉及到StateDB(Memory)/Trie(Memory)/EthDB(Disk)的更新&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockChain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InsertChain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Blocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BlockChain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insertChain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Blocks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verifySeals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setHead&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// insertChain中调用来执行Block中的所有的交易&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cfg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receipts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;//执行单条Transaction的调用&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applyTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ChainConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChainContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;author&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GasPool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;statedb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockNumber&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;big&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockHash&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Transaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usedGas&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Receipt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 状态转移函数&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateTransition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransitionDb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExecutionResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 执行合约内function&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EVMInterpreter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readOnly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// opSstore的调用&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SetState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;// 被修改的state的值会首先被放在StateObject的dirtyStorage中，而不是直接添加到Trie或者Disk Database中。&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 在Finalizes所有的pending的Storage时候，并且更新到Trie，计算State Trie的Root&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntermediateRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deleteEmptyObjects&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// Finalise 当前内存中的Cache.&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Finalise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deleteEmptyObjects&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 

 &lt;span class=&quot;c&quot;&gt;// Commit StateDB中的Cache到内存数据库中&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StateDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deleteEmptyObjects&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 将StateObject中所有的dirtyStorage转存到PendingStorage中，并清空dirtyStorage，并给prefetcher赋值&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finalise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefetch&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 更新StorageObject对应的Trie, from Pending Storage&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stateObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;updateTrie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Trie&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 最终获取到新的StateObject的Storage Root&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Trie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hashRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 用于在内存数据库中保存MPT节点&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;committer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;

 &lt;span class=&quot;c&quot;&gt;// 向rawdb对应的数据库写数据(leveldb)&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;report&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;common&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;持续更新中，Markdown文件库地址&lt;a href=&quot;https://github.com/hsyodyssey/Understanding-Ethereum-Go-version&quot;&gt;[link]&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[1] Ethereum Yellow Paper &lt;a href=&quot;https://ethereum.github.io/yellowpaper/paper.pdf&quot;&gt;(Paper Link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[2] Ethereum/Go-Ethereum &lt;a href=&quot;https://github.com/ethereum/go-ethereum&quot;&gt;(link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[3] Go-ethereum code analysis &lt;a href=&quot;https://github.com/ZtesoftCS/go-ethereum-code-analysis&quot;&gt;(Link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[4] Ethereum Improvement Proposals &lt;a href=&quot;https://github.com/ethereum/EIPs&quot;&gt;(link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[5] Mastering Bitcoin(Second Edition)&lt;/li&gt;
  &lt;li&gt;[6] Mastering Ethereum &lt;a href=&quot;https://github.com/ethereumbook/ethereumbook&quot;&gt;(link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[7] EIP-2718: Typed Transaction Envelope&lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-2718&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[8] EIP-2930: Optional access lists &lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-2930&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;[9] EIP-1559: Fee market change for ETH 1.0 chain &lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-1559&quot;&gt;[link]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">Preface Background 距中本聪发表比特币白皮书至今已经过了十几年的时光。Blockchain这一理念，从最开始作为支持Bitcoin的分布式账本系统出发，在这十几年的演化中不断发展，从专注于加密货币到如今的逐渐通用化，逐渐成为了集成了包括数据库，分布式系统，点对点网络，编译原理，静态软件分析，众包，密码学，经济学，货币金融学，社会学在内的等多个学科知识的一个全新技术领域。至今仍然是时下最热度最高，最能引起社会讨论的技术话题之一，逐渐从小众的去中心化社区逐渐走向了主流社会的舞台。 目前，市面上绝大多数的热门Blockchain系统都已经开源，并继续以开源的形式在社区的维护下持续开发中。这就为我们提供了一种的极好的学习Blockchain技术的方式: 通过结合文档，结合源代码的方式基于State-of-the-arts的Blockchain Systems出发开始学习。 一个热门的技术总是会有大量的文档，资料，经过不同视角的作者记录下来。不管是探究以加密货币导向（Crypto-based）的Bitcoin, 还是了解致力于实现通用Web3.0框架（General-Purpose）的Ethereum，有丰厚的文档从high-level的角度来讲述它们的基础概念，以及设计的思想。比如，技术社区有非常多的资料来讲述什么是梅克尔树 (Merkle Hash Tree)，什么是梅克尔帕特里夏树 (Merkle Patricia Tree)，什么是有向无环图 (Directed acyclic Graph); BFT (Byzantine Fault Tolerance)和 PoW (Proof-Of-Work) 共识算法算法的区别; 以及介绍Blockchain系统为什么可以抵抗双花攻击 (Double-Spending)，或者为什么Ethereum会遇到 DAO Attack (Decentralized autonomous organization) 等具体问题。 但是，只了解关键组件的实现细节，或者高度抽象的系统工作流，并不代表着可以让读者从真正搞清楚Blockchain的工作原理，反而很容易让读者在一些关键细节上一头雾水，似懂非懂。比如，当我们谈到Blockchain系统中Transaction的生命周期，我们在文档中经常会读到，Miner节点批量地从自己维护的Transaction pool中选择一些Transaction并打包成一个新的Block中。那么究竟miner是怎么从网络中获取到Transaction？又是继续什么样的选择策略从Transaction pool中选取Transaction？最终按照怎么的order把transaction打包进区块链中的呢？如何打包成功的Block是怎么交互给其他节点呢？我尝试去搜索了一下，发现鲜有文章从整体的系统工作流的角度出发，对以细粒度的视角对区块链系统中的具体的实现细节进行解析。与数据库系统(Database Management System)相似，Blockchain系统同样是一个包含网络层，业务逻辑层，任务解析层，存储层的复杂数据管理系统。对它研究同样需要从系统的实现细节出发，从宏观到微观的了解每个执行逻辑的工作流，才能彻底理解和掌握这门技术的秘密。 笔者坚信，随着网络基础架构的不断完善，将带来的显著的带宽上升和通信延迟下降。同时随着存储技术以及算法的不断发展，未来系统的运行效率将会不断逼近硬件极限。在未来的是五到十年内，云端服务/去中心化系统的效率以及覆盖场景一定还会有很大的提升。未来技术世界一定是两极分化的。一极是以大云计算公司（i.e, Google，MS，Oracle，Snowflake，and Alibaba）为代表的中心化服务商。另一极就是以Blockchain技术作为核心的去中心化的世界。在这个世界中，Ethereum及其生态系统是当之无愧的领头羊。Ethereum 不仅在作为Public Chain的自身取得了巨大的成功，构建了强大的生态系统，并且吸引一大批世界上最优秀的工程师，研究人员的持续的发力，不断的将新思想，新理念，新技术引入到Ethereum中，持续的引领Blockchain技术发展。而且Go-Ethereum作为其优秀的开源实现，已经被广泛的订制，来适应不同的私有/联盟场景(e.g., Quorum, Binance Smart Chain)。因此，要想真正掌握好区块链系统的原理，达到可以设计开发区块链系统的水平，研究好Ethereum的原理以及其设计思想是非常有必要。 本系列文章，作为我在博士期间学习/研究的记录，将会从Blockchain中具体业务的工作的视角出发，在源码的层面细粒度的解析以太坊系统中各个模块的实现的细节，以及背后的蕴含的技术和设计思想。同时，在阅读源代码中发现的问题也可以会提交Pr来贡献社区。本系列基于的代码库是Go-ethereum version 1.10.*。Go-ethereum是以太坊协议的Go语言实现版本，目前由以太坊基金会维护。目前除了Go-ethereum之外，Ethereum还有C++, Python，Java, Rust等基于其他语言实现的版本。相比于其他的社区版实现，go-ethereum的用户数量最多，开发人员最多，版本更新最频繁，issues的发现和处理都较快，运行也更更加的稳定。其他语言的Ethereum实现版本因为用户与开发人员的数量相对较少，更新频率相对较低，隐藏问题出现的可能性更高。因此我们选择从Go-ethereum代码库作为我们的主要学习资料，来理解Ethereum系统与网络的设计实现。 为什么要阅读区块链系统的源代码 文档资料相对较少，且内容浅尝辄止，相互独立。比如，很多的科普文章都提到，在打包新的Block的时候，miner负责把a batch of transactions从transaction pool中打包到新的block中。那么我们希望读者思考如下的几个问题： Miner是基于什么样策略从Transaction Pool中选择Transaction呢？ 被选择的Transactions又是以怎样的顺序(Order)被打包到区块中的呢？ 在执行Transaction的EVM是怎么计算gas used，从而限定Block中Transaction的数量的呢? 剩余的gas又是怎么返还给Transaction Proposer的呢？ EVM是怎么解释Contract的Message Call并执行的呢？ 在执行Transaction中是哪个模块，又是怎样去修改Contract中的持久化变量呢？ Smart Contract中的持久化变量又是以什么样的形式存储的呢？ 当新的Block加入到Blockchain中时，World State又是何时怎样更新的呢？ 哪些数据常驻内存，哪些数据又需要保存在Disk中呢？ 目前的Blockchain系统并没有像数据库系统(DBMS)那样统一实现的方法论，每个不同的系统中都集成了大量的细节。从源码的角度出发可以了解到很多容易被忽视的细节。简单的说，一个完整的区块链系统至少包含以下的模块: 密码学模块: 加解密，签名，安全hash，Mining 网络模块: P2P节点通信 分布式共识模块: PoW, BFT 智能合约解释器模块: Solidity编译语言，EVM解释器 数据存储模块: 数据库，数据存储，Index，LevelDB Log日志模块 etc. 而在具体实现中，由于设计理念，以及go语言的特性(没有继承派生关系)，go-ethereum中的模块之间相互调用关系相对复杂。因此，只有通过阅读源码的方式才能更好理解不同模块之间的调用关系，以及业务的workflow的执行流程/细节。 Blockchain System (BCS) VS Database Management System (DBMS) Blockchain 系统在设计层面借鉴了很多数据库系统中的设计逻辑。 Blockchain系统同样也从Transaction作为基本的操作载核，包含一个Parser模块，Transaction Executor模块，和一个Storage 管理模块。 Contents(暂定) PART ONE - General Source Code Analysis: Basic Components 00_万物的起点: Geth Start 01_State-based 模型 &amp;amp; Account 02_Transaction: 一个Transaction的生老病死 [03_从Block到Blockchain: 区块链数据结构的构建] [04_一个新节点是怎么加入网络并同步区块的] [05_一个网吧老板是怎么用闲置的电脑进行挖矿的] PART TWO - General Source Code Analysis: Services [10_StateDB的实例是如何构建的] [11_Blockchain的数据是如何持久化的] [12_Signer: 如何证明Transaction是合法的] [13_节点的调用 RPC and IPC] [14_深入EVM: 设计与实现] PART THREE - Advanced Topics [20_结合BFT Consensus 解决拜占庭将军问题] [21_从Plasma到Rollup] [22_Authenticated data structures Brief] [23_Bloom Filter] [24_图灵机和停机问题] [25_Log-structured merge-tree in Ethereum] [26_Concurrency in Ethereum Transaction] [27_Zero-knowledge Proof] PART FOUR - Ethereum in Practice [30_使用geth构建一个私有网络] [31_如何编写Solidity语言] [32_使用预言机(Oracle)构建随机化的DApp] [33_Query On Ethereum Data] [34_layer2 in Practice] PART FIVE - APPENDIX [40_FQA] [41_Ethereum System Tunning] [42_go-ethereum的开发思想] [43_Metrics in Ethereum] [44_Golang with Ethereum] How to measure the level of understanding of a system？ 如何衡量对一个系统的理解程度? Level 4: 掌握（Mastering） 在完全理解的基础上，可以设计并编写一个新的系统 Level 3: 完全理解（Complete Understanding） 在理解的基础上，完全掌握系统的各项实现的细节，并能做出优化 可以对现有的系统定制化到不同的应用场景 Level 2: 理解（Understanding） 熟练使用系统提供的API 了解系统模块的调用关系 能对系统的部分模块进行简单修改/重构 Level 1:了解（Brief understanding） 了解系统设计的目标，了解系统的应用场景 可以使用系统的部分的API 我们希望读者在阅读完本作之后，对Ethereum的理解能够达到 Level 2 - Level 3的水平。 Some Details 以太坊是基于State状态机模型的区块链系统，Miner在update new Block的时候，会直接修改自身的状态（添加区块奖励给自己）。所以与Bitcoin不同的是，Ethereum的区块中，并没有类似的Coinbase的transaction。 在core/transaction.go 中, transaction的的数据结构是有time.Time的参数的。但是在下面的newTransaction的function中只是使用Local的time.now()对Transaction.time进行初始化。 在core/transaction.go 的transaction 数据结构定义的时候, 在transaction.time 后面的注释写到（Time first seen locally (spam avoidance), Time 只是用于在本地首次看到的时间。 uncle block中的transaction 不会被包括到主链上。 go-ethereum有专用函数来控制每次transaction执行完，返还给用户的Gas的量。有根据EIP-3529，每次最多返还50%的gas. 不同的Contracts的数据会混合的保存在底层的一个LevelDB instance中。 LevelDB中保存的是MPT的Node信息。 在以太坊中，通常先执行Finalise函数 -&amp;gt; 然后执行Commit函数。 关键函数 // 向leveldb中更新Storage 数据 func WritePreimages(db ethdb.KeyValueWriter, preimages map[common.Hash][]byte) // 向Blockchain中添加新的Block，会涉及到StateDB(Memory)/Trie(Memory)/EthDB(Disk)的更新 func (bc *BlockChain) InsertChain(chain types.Blocks) (int, error) func (bc *BlockChain) insertChain(chain types.Blocks, verifySeals, setHead bool) (int, error) // insertChain中调用来执行Block中的所有的交易 func (p *StateProcessor) Process(block *types.Block, statedb *state.StateDB, cfg vm.Config) (types.Receipts, []*types.Log, uint64, error) //执行单条Transaction的调用 func applyTransaction(msg types.Message, config *params.ChainConfig, bc ChainContext, author *common.Address, gp *GasPool, statedb *state.StateDB, blockNumber *big.Int, blockHash common.Hash, tx *types.Transaction, usedGas *uint64, evm *vm.EVM) (*types.Receipt, error) // 状态转移函数 func (st *StateTransition) TransitionDb() (*ExecutionResult, error) // 执行合约内function func (in *EVMInterpreter) Run(contract *Contract, input []byte, readOnly bool) (ret []byte, err error) // opSstore的调用 func (s *StateDB) SetState(addr common.Address, key, value common.Hash) // 被修改的state的值会首先被放在StateObject的dirtyStorage中，而不是直接添加到Trie或者Disk Database中。 func (s *stateObject) setState(key, value common.Hash) // 在Finalizes所有的pending的Storage时候，并且更新到Trie，计算State Trie的Root func (s *StateDB) IntermediateRoot(deleteEmptyObjects bool) common.Hash // Finalise 当前内存中的Cache. func (s *StateDB) Finalise(deleteEmptyObjects bool) // Commit StateDB中的Cache到内存数据库中 func (s *StateDB) Commit(deleteEmptyObjects bool) (common.Hash, error) // 将StateObject中所有的dirtyStorage转存到PendingStorage中，并清空dirtyStorage，并给prefetcher赋值 func (s *stateObject) finalise(prefetch bool) // 更新StorageObject对应的Trie, from Pending Storage func (s *stateObject) updateTrie(db Database) Trie // 最终获取到新的StateObject的Storage Root func (t *Trie) hashRoot() (node, node, error) // 用于在内存数据库中保存MPT节点 func (c *committer) store(n node, db *Database) node // 向rawdb对应的数据库写数据(leveldb) func (db *Database) Commit(node common.Hash, report bool, callback func(common.Hash)) error Conclusion 持续更新中，Markdown文件库地址[link] Reference [1] Ethereum Yellow Paper (Paper Link) [2] Ethereum/Go-Ethereum (link) [3] Go-ethereum code analysis (Link) [4] Ethereum Improvement Proposals (link) [5] Mastering Bitcoin(Second Edition) [6] Mastering Ethereum (link) [7] EIP-2718: Typed Transaction Envelope[link] [8] EIP-2930: Optional access lists [link] [9] EIP-1559: Fee market change for ETH 1.0 chain [link]</summary></entry><entry><title type="html">[Re]怎样当好一名师长</title><link href="http://www.hsyodyssey.com/working/2021/11/13/How_to_be_a_good_Division_Commander.html" rel="alternate" type="text/html" title="[Re]怎样当好一名师长" /><published>2021-11-13T10:00:00+08:00</published><updated>2021-11-13T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/working/2021/11/13/How_to_be_a_good_Division_Commander</id><content type="html" xml:base="http://www.hsyodyssey.com/working/2021/11/13/How_to_be_a_good_Division_Commander.html">&lt;h2 id=&quot;怎样当好一名师长author林彪&quot;&gt;怎样当好一名师长(Author:林彪)&lt;/h2&gt;

&lt;h3 id=&quot;一要勤快&quot;&gt;一、&lt;strong&gt;要勤快&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;不勤快的人办不好事情，不能当好军事指挥员。应该自己干的事情一定要亲自过目，亲自动手。比如，应该上去看的山头就要爬上去，应该了解的情况就要及时了解，应该检查的问题就要严格检查。不能懒，军事指挥员切忌懒，因为懒会带来危险，带来失败。比方说，一个军事指挥员，到了宿营地就进房子，搞水洗脸洗脚，搞鸡蛋煮面吃，吃饱了就睡大觉。他对住的村子有多大，在什么位置，附近有几个山头周围有几条道路，敌情怎么样，群众条件怎么样，可能发生什么情况，部队到齐了没有，哨位在什么地方，发生紧急情况时的处置预案如何，都不过问，都不知道。这样，如果半夜三更发生了情况，敌人来个突然袭击，就没有办法了。到那种时候，即使平时很勇敢的指挥员，也会束手无策，只好三十六计，跑为上计，结果，变成一个机会主义者。机会主义和打败仗，常常是因为没有思想准备，没有组织准备，工作没有做到家，懒的结果。因此，不论大小指挥员都要勤快，要不惜走路，不怕劳累，要多用脑子，要做到心到、眼到、口到、脚到、手到。事情没有做好以前，不能贪闲。贪闲就隐伏着犯错误的根子。什么事都要心中有底，“凡事预则立，不预则废”。雷打不动的干部，牛皮糖式的干部，不管有多大本事，都不是好干部。&lt;/p&gt;

&lt;h3 id=&quot;二要摸清上级的意图&quot;&gt;二、&lt;strong&gt;要摸清上级的意图&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;对上级的意图要真正理解，真正融会贯通，真正认识自己所受领的任务在战役、战斗全局中的地位和作用。这样，才能充分发挥自己的主观能动性；才能打破框框，有敢于和善于在新情况中找到新办法的创造性；才能有大勇，才能决心强、决心狠，敢于彻底胜利，有强烈的吞掉敌人的企图和雄心。指挥员的勇敢集中表现在歼敌决心的坚定顽强上面。指挥员的大勇建立在革命的最高自觉性和正确理解上级意图的基础上面。&lt;/p&gt;

&lt;h3 id=&quot;三要调查研究&quot;&gt;三、&lt;strong&gt;要调查研究&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;对于敌情、地形、部队的情况和社会情况，要经常做到心中有数。要天天摸，天天琢磨，不能间断。这样做，不能看作是重复，实际上这不是重复，而是不断深化不断提高的过程，是取得正确认识的必不可少的手段。平时积累掌握的情况越多，越系统，在战时，特别是在紧张复杂的情况下，就越沉着，越有办法。急中生智的“智”，才有基础。因此，调查研究工作要贯串在各项工作中，要贯串在每一次战役、战斗的整个过程，反对打莽撞仗、糊涂仗，反对急性病，反对不亲自动手做调查研究的懒汉作风。特别是敌情，必须切实摸透。因为敌情是活的，敌人必然会极力隐蔽、伪装他们的真实企图和行动。要尽一切可能不间断地侦察，查清敌人的部署和动向，看他扮演什么角色？是主角还是配角？是主力还是非主力？是骄兵还是败兵？能集中多大兵力向我们进攻和阻挡我们的进攻。查明敌主官的特性，看他惯用和擅长用什么战法，根据他当前的企图判断他可能采用什么打法，等等。只要摸清了敌情、我情、地形的底，决心就快，就硬，就坚定。就不会被任何假象所迷惑，就不会被任何困难所吓住。如果情况不清，就会犹豫不决，举棋不定，坐失良机，或者勉强下了决心，一遇风吹草动，听到畏难叫苦和不正确的建议，就容易动摇，可能一念之差，前功尽弃。&lt;/p&gt;

&lt;h3 id=&quot;四要有个活地图&quot;&gt;四、&lt;strong&gt;要有个活地图&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;指挥员和参谋必须熟悉地图，要经常读地图。熟读地图可以产生见解，产生智慧，产生办法，产生信心。读的方法是把图挂起来，搬个凳子坐下来，对着地图看，从大的方向到活动地区，从地区全貌到每一地段的地形特点，从粗读到细读，逐块逐块地读，用红蓝铅笔把主要的山脉、河流、城镇、村庄、道路标划出来，边读，边划，等到地图差不多快划烂了，也就差不多把地图背熟了，背出来了。在熟读地图的基础上，要亲自组织有关指挥员和参谋对作战地区和战场进行实地勘察，核正地图，把战场的地形情况和敌我双方的兵力部署都装至脑子里去，做到闭上眼睛面前就有一幅鲜明的战场图影，离开地图也能指挥作战。这样，在你死我活、瞬息万变的战斗情况下，可以比敌人来得快，争取先机，先敌一着，掌握主动，稳操胜券。&lt;/p&gt;

&lt;h3 id=&quot;五要把各方面的问题想够想透&quot;&gt;五、&lt;strong&gt;要把各方面的问题想够想透&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;每一次战役、战斗的组织，要让大家提出各种可能出现的问题，要让大家来找答案，而且要从最坏的最严重的情况来找答案。把所有提出来的问题都回答了，再没有问题没有回答的了，这样，打起仗来才不会犯大错误，万一犯了错误，也比较容易纠正。没有得到答案的问题，不能因为想了很久想不出来就把它丢开，留下一个疙瘩。如果这样，是很危险的，在紧要关头，这个疙瘩很可能冒出来，就会使你们心中无数，措手不及。当然，在战争环境中，要考虑的问题很多，不可能一次都提完，也不可能一次都回答完，整个战役、战斗的过程，就是不断提出问题和不断回答问题的过程。有时脑子很疲劳，有的问题可能立即回答不了。这时，除了好好地和别人商量以外，就好好地睡一觉，睡好了，睡醒了，头脑清醒了，再躺在床上好好想一想，就可能开窍，可能想通了，回答了，解决了。总之，对每一个问题不能含糊了事。问题回答完了，战役、战斗的组织才算完成。&lt;/p&gt;

&lt;h3 id=&quot;六要及时下决心&quot;&gt;六、&lt;strong&gt;要及时下决心&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在什么样的情况下可以下决心打呢？指挥员必须以最大努力组织战役、战斗的准备工作，力求确有把握才动手，不打无把握之仗。但是任何一次战斗都不可能完全具备各种条件，不可能有百分之百的把握。一般说有百分之七十左右的把握，就很不错了，就要坚决地打，放手地打。不足的条件，要通过充分发挥人的因素的作用，依靠人民群众的力量，充分发挥人民军队特有的政治上的优势，充分发挥指战员的智慧和英勇顽强的战斗作风来弥补，以主观努力来创造条件，化冒险性为创造性，取得胜利。&lt;/p&gt;

&lt;h3 id=&quot;七要有一个很好的很团结的班子&quot;&gt;七、&lt;strong&gt;要有一个很好的很团结的班子&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;领导班子思想认识要一致，行动要协调、合拍，要雷厉风行，要有革命英雄主义的气概。都要勤快，都千方百计地办好事情，完成任务。不互相扯皮，不互相干扰，不抱旁观者的态度。如果领导班子不好，人多不但无用，反而有害。&lt;/p&gt;

&lt;h3 id=&quot;八要有一个很好的战斗作风&quot;&gt;八、&lt;strong&gt;要有一个很好的战斗作风&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;有好的战斗作风的部队才能打好仗，打胜仗。好的战斗作风首先是不叫苦，抢着去担负最艰巨的任务，英勇顽强，不怕牺牲，猛打猛冲猛追。特别是要勇于穷追。因为把敌人打垮以后，追击是解决战斗、扩大战果、彻底歼灭敌人最关键的一招。在追击时，要跑步追，快步追，走不动的扶着拐棍追，就是爬、滚，也要往前追，只有抓住敌人，才能吃掉敌人。好的战斗作风要靠平时养成，要靠实际锻炼，要在紧张、残酷的战斗中才能锻炼出来。不敢打硬仗、恶仗的部队，让他打几次就打出来了，因为已经见识过硬仗、恶仗的场面，有了体会，有了经验，知道怎么打了，百炼成钢就是这个道理。做工作也要有好的作风，说了就要做，说到那里做到那里，要做得干脆利索，要一竿子插到底，一点不含糊，不做好不撒手。好的作风的养成，关键在于干部。强将手下无弱兵，干部的作风怎么样，部队的作风就会怎么样。因此，首先要抓好干部，要干部做出样子，影响带动部队。只要干部作风好，指挥好战斗，多打胜仗，即使是新建的部队或者原来基础较弱的部队，也会很快打出好作风来，像铁锤一样，砸到那里，那里就碎。&lt;/p&gt;

&lt;h3 id=&quot;九要重视政治亲自做政治工作&quot;&gt;九、&lt;strong&gt;要重视政治，亲自做政治工作&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;部队战斗力的提高要靠平时坚强的党的领导、坚强的政治工作。连队的支部一定要建设好，支部的工作要做活，就是要把所有党团员的革命劲头鼓得足足的，充分发挥他们的模范作用、带头作用，通过他们把全连带动起来，通过他们去做政治工作，提高全体指战员的阶级觉悟。有了坚强的党支部的领导，有了坚强的政治工作，就可以做到一呼百应，争先恐后，不怕牺牲，前赴后继。战术、技术也要练好，特别是技术，如果枪打不准，战场上就不能消灭敌人，就不能解决战斗。因此，军事训练不能马虎，党政工作要领导好训练。艺高人胆大，胆大艺更高，部队有了高度的无产阶级觉悟，有了好的战斗作风，再加上过硬的作战本领，就如虎添翼，就可以无敌于天下。&lt;/p&gt;

&lt;h3 id=&quot;cs-phd-总结版&quot;&gt;CS PhD 总结版&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;要勤快，多阅读，多写作，多思考，多编程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要摸清楚导师和Reviewers的意图。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要多读Paper和源代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对关键技术细节，算法，证明要烂熟于心。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要融会贯通，从多个角度思考问题。Trade-off带来了什么提高，又牺牲了什么。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要及时下决心，赶上deadline。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;团结组内同学，保持跟导师的良好沟通。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;养成良好的工作习惯。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;团队合作的时候要亲自动手。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Working" /><category term="Working" /><summary type="html">怎样当好一名师长(Author:林彪) 一、要勤快 不勤快的人办不好事情，不能当好军事指挥员。应该自己干的事情一定要亲自过目，亲自动手。比如，应该上去看的山头就要爬上去，应该了解的情况就要及时了解，应该检查的问题就要严格检查。不能懒，军事指挥员切忌懒，因为懒会带来危险，带来失败。比方说，一个军事指挥员，到了宿营地就进房子，搞水洗脸洗脚，搞鸡蛋煮面吃，吃饱了就睡大觉。他对住的村子有多大，在什么位置，附近有几个山头周围有几条道路，敌情怎么样，群众条件怎么样，可能发生什么情况，部队到齐了没有，哨位在什么地方，发生紧急情况时的处置预案如何，都不过问，都不知道。这样，如果半夜三更发生了情况，敌人来个突然袭击，就没有办法了。到那种时候，即使平时很勇敢的指挥员，也会束手无策，只好三十六计，跑为上计，结果，变成一个机会主义者。机会主义和打败仗，常常是因为没有思想准备，没有组织准备，工作没有做到家，懒的结果。因此，不论大小指挥员都要勤快，要不惜走路，不怕劳累，要多用脑子，要做到心到、眼到、口到、脚到、手到。事情没有做好以前，不能贪闲。贪闲就隐伏着犯错误的根子。什么事都要心中有底，“凡事预则立，不预则废”。雷打不动的干部，牛皮糖式的干部，不管有多大本事，都不是好干部。 二、要摸清上级的意图 对上级的意图要真正理解，真正融会贯通，真正认识自己所受领的任务在战役、战斗全局中的地位和作用。这样，才能充分发挥自己的主观能动性；才能打破框框，有敢于和善于在新情况中找到新办法的创造性；才能有大勇，才能决心强、决心狠，敢于彻底胜利，有强烈的吞掉敌人的企图和雄心。指挥员的勇敢集中表现在歼敌决心的坚定顽强上面。指挥员的大勇建立在革命的最高自觉性和正确理解上级意图的基础上面。 三、要调查研究 对于敌情、地形、部队的情况和社会情况，要经常做到心中有数。要天天摸，天天琢磨，不能间断。这样做，不能看作是重复，实际上这不是重复，而是不断深化不断提高的过程，是取得正确认识的必不可少的手段。平时积累掌握的情况越多，越系统，在战时，特别是在紧张复杂的情况下，就越沉着，越有办法。急中生智的“智”，才有基础。因此，调查研究工作要贯串在各项工作中，要贯串在每一次战役、战斗的整个过程，反对打莽撞仗、糊涂仗，反对急性病，反对不亲自动手做调查研究的懒汉作风。特别是敌情，必须切实摸透。因为敌情是活的，敌人必然会极力隐蔽、伪装他们的真实企图和行动。要尽一切可能不间断地侦察，查清敌人的部署和动向，看他扮演什么角色？是主角还是配角？是主力还是非主力？是骄兵还是败兵？能集中多大兵力向我们进攻和阻挡我们的进攻。查明敌主官的特性，看他惯用和擅长用什么战法，根据他当前的企图判断他可能采用什么打法，等等。只要摸清了敌情、我情、地形的底，决心就快，就硬，就坚定。就不会被任何假象所迷惑，就不会被任何困难所吓住。如果情况不清，就会犹豫不决，举棋不定，坐失良机，或者勉强下了决心，一遇风吹草动，听到畏难叫苦和不正确的建议，就容易动摇，可能一念之差，前功尽弃。 四、要有个活地图 指挥员和参谋必须熟悉地图，要经常读地图。熟读地图可以产生见解，产生智慧，产生办法，产生信心。读的方法是把图挂起来，搬个凳子坐下来，对着地图看，从大的方向到活动地区，从地区全貌到每一地段的地形特点，从粗读到细读，逐块逐块地读，用红蓝铅笔把主要的山脉、河流、城镇、村庄、道路标划出来，边读，边划，等到地图差不多快划烂了，也就差不多把地图背熟了，背出来了。在熟读地图的基础上，要亲自组织有关指挥员和参谋对作战地区和战场进行实地勘察，核正地图，把战场的地形情况和敌我双方的兵力部署都装至脑子里去，做到闭上眼睛面前就有一幅鲜明的战场图影，离开地图也能指挥作战。这样，在你死我活、瞬息万变的战斗情况下，可以比敌人来得快，争取先机，先敌一着，掌握主动，稳操胜券。 五、要把各方面的问题想够想透 每一次战役、战斗的组织，要让大家提出各种可能出现的问题，要让大家来找答案，而且要从最坏的最严重的情况来找答案。把所有提出来的问题都回答了，再没有问题没有回答的了，这样，打起仗来才不会犯大错误，万一犯了错误，也比较容易纠正。没有得到答案的问题，不能因为想了很久想不出来就把它丢开，留下一个疙瘩。如果这样，是很危险的，在紧要关头，这个疙瘩很可能冒出来，就会使你们心中无数，措手不及。当然，在战争环境中，要考虑的问题很多，不可能一次都提完，也不可能一次都回答完，整个战役、战斗的过程，就是不断提出问题和不断回答问题的过程。有时脑子很疲劳，有的问题可能立即回答不了。这时，除了好好地和别人商量以外，就好好地睡一觉，睡好了，睡醒了，头脑清醒了，再躺在床上好好想一想，就可能开窍，可能想通了，回答了，解决了。总之，对每一个问题不能含糊了事。问题回答完了，战役、战斗的组织才算完成。 六、要及时下决心 在什么样的情况下可以下决心打呢？指挥员必须以最大努力组织战役、战斗的准备工作，力求确有把握才动手，不打无把握之仗。但是任何一次战斗都不可能完全具备各种条件，不可能有百分之百的把握。一般说有百分之七十左右的把握，就很不错了，就要坚决地打，放手地打。不足的条件，要通过充分发挥人的因素的作用，依靠人民群众的力量，充分发挥人民军队特有的政治上的优势，充分发挥指战员的智慧和英勇顽强的战斗作风来弥补，以主观努力来创造条件，化冒险性为创造性，取得胜利。 七、要有一个很好的很团结的班子 领导班子思想认识要一致，行动要协调、合拍，要雷厉风行，要有革命英雄主义的气概。都要勤快，都千方百计地办好事情，完成任务。不互相扯皮，不互相干扰，不抱旁观者的态度。如果领导班子不好，人多不但无用，反而有害。 八、要有一个很好的战斗作风 有好的战斗作风的部队才能打好仗，打胜仗。好的战斗作风首先是不叫苦，抢着去担负最艰巨的任务，英勇顽强，不怕牺牲，猛打猛冲猛追。特别是要勇于穷追。因为把敌人打垮以后，追击是解决战斗、扩大战果、彻底歼灭敌人最关键的一招。在追击时，要跑步追，快步追，走不动的扶着拐棍追，就是爬、滚，也要往前追，只有抓住敌人，才能吃掉敌人。好的战斗作风要靠平时养成，要靠实际锻炼，要在紧张、残酷的战斗中才能锻炼出来。不敢打硬仗、恶仗的部队，让他打几次就打出来了，因为已经见识过硬仗、恶仗的场面，有了体会，有了经验，知道怎么打了，百炼成钢就是这个道理。做工作也要有好的作风，说了就要做，说到那里做到那里，要做得干脆利索，要一竿子插到底，一点不含糊，不做好不撒手。好的作风的养成，关键在于干部。强将手下无弱兵，干部的作风怎么样，部队的作风就会怎么样。因此，首先要抓好干部，要干部做出样子，影响带动部队。只要干部作风好，指挥好战斗，多打胜仗，即使是新建的部队或者原来基础较弱的部队，也会很快打出好作风来，像铁锤一样，砸到那里，那里就碎。 九、要重视政治，亲自做政治工作 部队战斗力的提高要靠平时坚强的党的领导、坚强的政治工作。连队的支部一定要建设好，支部的工作要做活，就是要把所有党团员的革命劲头鼓得足足的，充分发挥他们的模范作用、带头作用，通过他们把全连带动起来，通过他们去做政治工作，提高全体指战员的阶级觉悟。有了坚强的党支部的领导，有了坚强的政治工作，就可以做到一呼百应，争先恐后，不怕牺牲，前赴后继。战术、技术也要练好，特别是技术，如果枪打不准，战场上就不能消灭敌人，就不能解决战斗。因此，军事训练不能马虎，党政工作要领导好训练。艺高人胆大，胆大艺更高，部队有了高度的无产阶级觉悟，有了好的战斗作风，再加上过硬的作战本领，就如虎添翼，就可以无敌于天下。 CS PhD 总结版 要勤快，多阅读，多写作，多思考，多编程。 要摸清楚导师和Reviewers的意图。 要多读Paper和源代码。 对关键技术细节，算法，证明要烂熟于心。 要融会贯通，从多个角度思考问题。Trade-off带来了什么提高，又牺牲了什么。 要及时下决心，赶上deadline。 团结组内同学，保持跟导师的良好沟通。 养成良好的工作习惯。 团队合作的时候要亲自动手。</summary></entry><entry><title type="html">Go语言开发Tips</title><link href="http://www.hsyodyssey.com/blockchain/2021/10/10/golang.html" rel="alternate" type="text/html" title="Go语言开发Tips" /><published>2021-10-10T10:00:00+08:00</published><updated>2021-10-10T10:00:00+08:00</updated><id>http://www.hsyodyssey.com/blockchain/2021/10/10/golang</id><content type="html" xml:base="http://www.hsyodyssey.com/blockchain/2021/10/10/golang.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This repo records the daily programming nodes of Golang.&lt;/p&gt;

&lt;h2 id=&quot;why-golang&quot;&gt;Why Golang?&lt;/h2&gt;

&lt;p&gt;Golang是一种非常适合分布式系统/数据库(Distributed System/database)，区块链(Blockchain)项目开发的编程语言，因为:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;语法简单&lt;/strong&gt;。它学习曲线平滑。有其他高级语言编程经验的开发人员，可以快速上手。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;高并发基因&lt;/strong&gt;。它提供了强大简洁易用稳定的标准库，对高并发，分布式程序有更加灵活简洁全面的标准库支持。不需要依赖第三方库就可以快速构建后端/网络/高并发应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;跨平台&lt;/strong&gt;。它支持跨系统交叉编译。MacOS/Win 也可以编译Linux下可以运行的程序，不需要担心环境依赖的问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;新&lt;/strong&gt;。相对于C/C++，Golang的设计理念更新，历史包袱更少。对各种&lt;del&gt;新型数据结构&lt;/del&gt;比如JSON, CSV提供了简洁流畅的原生标准库支持。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;快&lt;/strong&gt;。它相比C++编译快，相比Python运行快。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以Golang非常适合做一些分布式系统/数据库，区块链领域的学术/工程项目的原型(Prototype)开发工作。&lt;/p&gt;

&lt;h2 id=&quot;不足&quot;&gt;不足&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;轮子少&lt;/strong&gt;。相比于Java生态系统中充足的轮子，Go社区中的轮子的发展还属于初级阶段。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;代码冗余&lt;/strong&gt;。相比于C++，Golang对范型(Generic Programming)支持较差。对同一份逻辑，不同的数据结构需要重复的代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;general-tips&quot;&gt;General Tips&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;保持包名和目录名的一致。&lt;/li&gt;
  &lt;li&gt;包名尽量简短，应该为小写单词，不要使用下划线或者驼峰式命名。&lt;/li&gt;
  &lt;li&gt;文件名为小写单词，使用下划线分割。&lt;/li&gt;
  &lt;li&gt;Go语言区分大小写，小写字母开头的单词为包内访问，相当于Java/C++中的Private。跨包使用的成员变量/函数要使用大写字母开头。&lt;/li&gt;
  &lt;li&gt;变量和结构体的命名使用驼峰式。&lt;/li&gt;
  &lt;li&gt;通过更改首字母的大小写，来控制结构体的使用场景。&lt;/li&gt;
  &lt;li&gt;常量通常使用全部大写字母。&lt;/li&gt;
  &lt;li&gt;Go结构体默认的小写字母开头的变量不是public的不能跨包访问。&lt;/li&gt;
  &lt;li&gt;通过go run *.go 或者 go build .的方式来运行多文件同package的go程序&lt;/li&gt;
  &lt;li&gt;Go语言中包括数组和Slice两种集合型数据结构。&lt;/li&gt;
  &lt;li&gt;Go语言中的数据大小是固定的。&lt;/li&gt;
  &lt;li&gt;Go语言中中Slice(切片)的大小可以是动态的。&lt;/li&gt;
  &lt;li&gt;Go语言中，可以定义一个不指明长度的切片。&lt;/li&gt;
  &lt;li&gt;二维切片需要初始化:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c&quot;&gt;//2-D Slice init&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 初始化一个n行m列的切片&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[][]&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Go 自带了解析CSV的库 “encoding/csv”&lt;/li&gt;
  &lt;li&gt;Go Interface 是一种type&lt;/li&gt;
  &lt;li&gt;要实现Interface 必须实现interface中所有的方法&lt;/li&gt;
  &lt;li&gt;使用runtime Package中的 MemStats 和 ReadMemStats 来测量当前程序中Memory的使用状况。&lt;/li&gt;
  &lt;li&gt;Context 是 Go 1.7 之后新引入的标准库接口。&lt;/li&gt;
  &lt;li&gt;sync/atomic标准库包中提供的原子操作，通常是无锁的。&lt;/li&gt;
  &lt;li&gt;Function Types: A function type denotes the set of all functions with the same parameter and result types.&lt;/li&gt;
  &lt;li&gt;当初始化结构体时，对于结构体中复杂的成员，需要显式的声明它的类型信息，否则编译无法通过。
    &lt;ul&gt;
      &lt;li&gt;For example:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PaperDetails&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PaperDetails&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;&quot;testtitle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Topics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test topic1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test topic2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Authors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test author1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test author2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Comments&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test comment1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Keysentencts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sentence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test topic1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sent1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sent2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test topic2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sent2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sent3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;go-struct&quot;&gt;Go Struct&lt;/h2&gt;

&lt;p&gt;Struct是是Go语言中最重要的自定义的数据结构之一。它的用法与C++/Java中的class既有相同点又有不同点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Struct 有两种初始化方式:
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;指针的方式, 这种方式会返回一个指向新的结构体的指针:&lt;/p&gt;

        &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;or&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;With a struct literal, 这种方式会返回一个值变量(等于第一种方式的*s):&lt;/p&gt;

        &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;map&quot;&gt;Map&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;可以通过第二个返回值的方式来判断map中是否存在目标key。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test001&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test002&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isExist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// value: string: test001, isExist: bool : true&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isExist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;003&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// value: , isExist: bool : false&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;fqa&quot;&gt;FQA&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;What is struct{} and struct{}{} ?
    &lt;ul&gt;
      &lt;li&gt;struct{} 表示一个零元素的struct结构。通常会被用在没有任何信息被存储的场景中。&lt;/li&gt;
      &lt;li&gt;struct{}{} 表示一个存储了struct{}的Composite literal.&lt;/li&gt;
      &lt;li&gt;Source: &lt;a href=&quot;https://stackoverflow.com/questions/45122905/how-do-struct-and-struct-work-in-go&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;interface是一种万能的数据类型，他可以接受任何类型的值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;go-unit-testing&quot;&gt;Go Unit Testing&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Go 单元测试中，执行到t.Error()/ t.Errorf() 测试函数会输出错误的log信息并继续执行。&lt;/li&gt;
  &lt;li&gt;Go 单元测试中，执行到t.Fatal()/ t.Fatalf() 测试函数会输出错误的log信息并结束测试。&lt;/li&gt;
  &lt;li&gt;Go 单元测试中，如果不满足断言assert.Equal() 测试函数会结束并报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;go-and-c-and-python&quot;&gt;Go and C and Python&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Python 可以调用Go编译的动态链接库 and.so (Shared Object)&lt;/li&gt;
  &lt;li&gt;Go编译成so文件时，需要在函数上一行添加//export xxx(函数名).
    &lt;ul&gt;
      &lt;li&gt;注意//与export中间不能有空格&lt;/li&gt;
      &lt;li&gt;Example 位于example/pygo&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;log&quot;&gt;Log&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Log.Fatal会直接退出程序，不会执行defer相关的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Go语言高性能编程&lt;a href=&quot;https://geektutu.com/post/high-performance-go.html&quot;&gt;link&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Go By Example&lt;a href=&quot;https://gobyexample.com/&quot;&gt;link&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Siyuan Han</name><email>shanaj@connect.ust.hk</email></author><category term="Blockchain" /><category term="Blockchain" /><category term="Ethereum" /><category term="Go" /><summary type="html">Introduction This repo records the daily programming nodes of Golang. Why Golang? Golang是一种非常适合分布式系统/数据库(Distributed System/database)，区块链(Blockchain)项目开发的编程语言，因为: 语法简单。它学习曲线平滑。有其他高级语言编程经验的开发人员，可以快速上手。 高并发基因。它提供了强大简洁易用稳定的标准库，对高并发，分布式程序有更加灵活简洁全面的标准库支持。不需要依赖第三方库就可以快速构建后端/网络/高并发应用。 跨平台。它支持跨系统交叉编译。MacOS/Win 也可以编译Linux下可以运行的程序，不需要担心环境依赖的问题。 新。相对于C/C++，Golang的设计理念更新，历史包袱更少。对各种新型数据结构比如JSON, CSV提供了简洁流畅的原生标准库支持。 快。它相比C++编译快，相比Python运行快。 所以Golang非常适合做一些分布式系统/数据库，区块链领域的学术/工程项目的原型(Prototype)开发工作。 不足 轮子少。相比于Java生态系统中充足的轮子，Go社区中的轮子的发展还属于初级阶段。 代码冗余。相比于C++，Golang对范型(Generic Programming)支持较差。对同一份逻辑，不同的数据结构需要重复的代码。 General Tips 保持包名和目录名的一致。 包名尽量简短，应该为小写单词，不要使用下划线或者驼峰式命名。 文件名为小写单词，使用下划线分割。 Go语言区分大小写，小写字母开头的单词为包内访问，相当于Java/C++中的Private。跨包使用的成员变量/函数要使用大写字母开头。 变量和结构体的命名使用驼峰式。 通过更改首字母的大小写，来控制结构体的使用场景。 常量通常使用全部大写字母。 Go结构体默认的小写字母开头的变量不是public的不能跨包访问。 通过go run *.go 或者 go build .的方式来运行多文件同package的go程序 Go语言中包括数组和Slice两种集合型数据结构。 Go语言中的数据大小是固定的。 Go语言中中Slice(切片)的大小可以是动态的。 Go语言中，可以定义一个不指明长度的切片。 二维切片需要初始化: //2-D Slice init // 初始化一个n行m列的切片 var K[][] int. for i := 0; i &amp;lt;=n; i++ { inline := make([]int, m) K := append(K, inline) } Go 自带了解析CSV的库 “encoding/csv” Go Interface 是一种type 要实现Interface 必须实现interface中所有的方法 使用runtime Package中的 MemStats 和 ReadMemStats 来测量当前程序中Memory的使用状况。 Context 是 Go 1.7 之后新引入的标准库接口。 sync/atomic标准库包中提供的原子操作，通常是无锁的。 Function Types: A function type denotes the set of all functions with the same parameter and result types. 当初始化结构体时，对于结构体中复杂的成员，需要显式的声明它的类型信息，否则编译无法通过。 For example: var pd1 PaperDetails = PaperDetails{ Title: &quot;testtitle&quot;, Topics: []string{&quot;test topic1&quot;, &quot;test topic2&quot;}, Authors: []string{&quot;test author1&quot;, &quot;test author2&quot;}, Comments: []string{&quot;test comment1&quot;}, Keysentencts: map[string][]Sentence{&quot;test topic1&quot;: {sent1, sent2}, &quot;test topic2&quot;: {sent2, sent3}}, } Go Struct Struct是是Go语言中最重要的自定义的数据结构之一。它的用法与C++/Java中的class既有相同点又有不同点。 Struct 有两种初始化方式: 指针的方式, 这种方式会返回一个指向新的结构体的指针: var s * Student s = new(Student) s.name = &quot;test&quot; \\or var s = new (Student) s.name = &quot;test&quot; With a struct literal, 这种方式会返回一个值变量(等于第一种方式的*s): s := Student{ name: &quot;test&quot;, } Map 可以通过第二个返回值的方式来判断map中是否存在目标key。 m := make(map[string]sting) m[&quot;001&quot;] = &quot;test001&quot; m[&quot;002&quot;] = &quot;test002&quot; value, isExist := m[&quot;001&quot;] // value: string: test001, isExist: bool : true value, isExist := m[&quot;003&quot;] // value: , isExist: bool : false FQA What is struct{} and struct{}{} ? struct{} 表示一个零元素的struct结构。通常会被用在没有任何信息被存储的场景中。 struct{}{} 表示一个存储了struct{}的Composite literal. Source: Stackoverflow interface是一种万能的数据类型，他可以接受任何类型的值。 Go Unit Testing Go 单元测试中，执行到t.Error()/ t.Errorf() 测试函数会输出错误的log信息并继续执行。 Go 单元测试中，执行到t.Fatal()/ t.Fatalf() 测试函数会输出错误的log信息并结束测试。 Go 单元测试中，如果不满足断言assert.Equal() 测试函数会结束并报错。 Go and C and Python Python 可以调用Go编译的动态链接库 and.so (Shared Object) Go编译成so文件时，需要在函数上一行添加//export xxx(函数名). 注意//与export中间不能有空格 Example 位于example/pygo Log Log.Fatal会直接退出程序，不会执行defer相关的函数 Reference Go语言高性能编程link Go By Examplelink</summary></entry></feed>