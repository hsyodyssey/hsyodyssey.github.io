---
layout: article
title:  "理解Groth16，一些细节上的说明"
date:   2022-03-22 10:00:00 +0800
tags: Blockchain ZKP Groth16
categories: zk-SNARK
---

V神曾经写过一篇非常好的介绍R1CS与QAP问题的[文章](https://vitalik.ca/general/2016/12/10/qap.html)。但是，对于不熟悉密码学的，或者说密码学思想的票友们来说，文章中的一些逻辑上的跨度还是大了一些。尤其是在R1CS转换成多项式形式的地方，初次接触的人可能会一脸懵逼。本文，我就从我的理解来谈一谈，从R1CS到QAP这一过程。

在Groth16的流程中，我们首先把**计算问题**拍平成**电路**。每个电路都由若干的有输入有输出的电路门组成。然后根据电路门，来构造R1CS约束。

这里我们直接使用V神的[博客](https://vitalik.ca/general/2016/12/10/qap.html)中的例子。下面的三个矩阵是就是原问题对应的电路的R1CS的约束矩阵。

```
A
[0, 1, 0, 0, 0, 0]
[0, 0, 0, 1, 0, 0]
[0, 1, 0, 0, 1, 0]
[5, 0, 0, 0, 0, 1]

B
[0, 1, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]

C
[0, 0, 0, 1, 0, 0]
[0, 0, 0, 0, 1, 0]
[0, 0, 0, 0, 0, 1]
[0, 0, 1, 0, 0, 0]
```

这三个矩阵都包含了四个行向量，代表了原始的计算被拍平成了在R1CS约束下的四个电路。到了这一步，我们的原问题”*我们知道原始计算的一个解*“就转化成了，*“我们知道一个解向量，使得它在每个电路约束下都成立”*。我们用$S$来表示解向量，本例中$S$的值如下所示。

```
1
3
35
9
27
30
```

此时，如果我们想证明我们知道原始计算的一个解，那么就需要证明A，B，C矩阵中的**每个**行向量与解向量$S$的内积之后的值是符合R1CS约束的：

$(A_i*S）* (B_i*S) - C_i*S = 0$

在接下来的一步，我们需要将R1CS的约束转换成一个QAP问题，这个地方是理解zk的重点。我觉得原文中没有提到的一点时，我们为什么要这么做的？这样的做的目的是什么？V神的原文只描述了如何做，希望把向量的内积转化为多项式，如何进行拉普拉斯插值求多项式，所以第一次读到这里的时候，我感觉一头雾水。

这里阐述一下我的理解。这样做的原因是，如果只使用R1CS的约束矩阵来验证，我们只能一个电路门，一个电路门的，使用列向量与解向量的内积来验证是否满足R1CS的约束。这样在方式在大规模电路下（几十万，上百万的电路门）显然是十分低效的。那么接下来的自然思考方向就变成了，存不存在一种办法，可以让我们**一次计算**来验证所有约束的正确性？

我们在观察上面的计算过程中，发现解向量中$S$中的S1元素一定与约束矩阵中A11，A21，A31，A41这四个元素相乘。因此，那么我们假设存在这样一个多项式 $A_1(x)$，它经过$(1,0), (2,0), (3,0), (4,5)$这四个点。这个多项式 $A_1(x)$的数学意义是：当x的值为1时，多项式的值为0，当$x=2$时，多项式的值为0，当$x=3$时，多项式的值为0，当$x=4$时，多项式的值为5。这样，我们通过引入额外的参数x，使得可以使用一个的多项式$A_1(x)$来描述[A11，A21，A31，A41]这四个值。

根据原文中提到的拉普拉斯插值法，我们可以求出关于[A11，A21，A31，A41]的多项式为：

$A_1(x) = 0.833*x^3 -5.0 * x^2 +9.166 *x -5.0$。

我们验证一下就可以发现，当x取1时，A_1(x)的值为0，等于原R1CS约束矩阵中的A11的值。

同样的，我们可以构造出其他列向量的多项式$A_i(x),B_i(x),C_i(x)$。那么这样，我们就可以使用这几个多项式来描述，之前判断向量内积是否满足R1CS约束的过程。等式的左边可以写成下面的形式:

$$((1 * A_1(x))+(3 * A_2(x))+(35 * A_3(x)) + (9 * A_4(x)) +(27 * A_5(x))+(30 * A_6(x))) \\ *（(1 * B_1(x)+(3 * B_2(x))+(35 * B_3(x)) + (9 * B_4(x)) +(27 * B_5(x))+(30 * B_6(x))) \\ - （(1 * C_1(x)+(3 * C_2(x))+(35 * C_3(x)) + (9 * C_4(x)) +(27 * C_5(x))+(30 * C_6(x)))$$

现在我们已经将实际的值转换成了多项式，根据x的取值的不同，来描述不同的R1CS约束。那么，更进一步的来说，因为上面的式子中都是多项式，我们可以把等式左边展开成一个更简洁的多项式 $t(x)$:

$$t(x) = (-5.166*x^3+38.5*x^2-73.333*x+43)*(0.666*x^3-5.0*x^2+10.333*x-3.0)-(2.833*x^3-24.5*x^2+10.333*x-41.0)\\
       = -3.440556*x^6+51.471*x^5-294.720056*x^4+805.7885*x^3-1063.749889*x^2+592.652*x-88$$

同时我们需要让等式右边的值等于0。因为，x的取值只有[1，2，3，4]，因此我们就可以先构造一个多项式$z(x)=(x-1)(x-2)(x-3)(x-4)$。显然$z(x)$在x可能的取值情况下都等于0。这里，显然$z(x)$是不等于$t(x)$（多项式的阶不同），所以我们引入另一个多项式$h(x)$，使得$t(x)=z(x)h(x)$。

这样我们就实现了用一个多项式来描述所有的R1CS的约束了。我们可以设置x值取1，2，3，4，来验证对应的电路的R1CS约束是不是合法。

现在的关于**我们是否知道原问题的解的证明**转换成了，**我们是否知道一个多项式$t(x)$使得$t(x)=z(x)h(x)$在x等于1，2，3，4都成立**。

那么，顺着这个逻辑继续思考，我们如何向其他人证明我们知道这个多项式$t(x)$时存在的呢？

在公式$t(x)=z(x)h(x)$中，$z(x)$是公开的多项式，那么作为知道$t(x)$的Prover，我们可以快速的计算出$h(x)=\frac{t(x)}{z(x)}$。那么，我们只要提供$h(x)$给验证者，那么显然，验证者通过计算$z(x)*h(x)$，就可以求的$t(x)$。

那么想象一下，Alice对Bob说，我知道一个计算的解。那么Bob可以要求Alice计算$x=r$时，$h(r)$和$t(r)$的值，并且验证$h(r)*z(r)$是否与$t(r)$的值是否相等来判断Alice说的是否正确。在这个过程我们完美的隐藏掉了原来解向量$S$的存在。

通过，上面的过程，我们就完成了一个简单的零知识问题的转换。但是这个模型并不足够安全，比如Alice可以伪造合法的$h(r)$和$t(r)$的值。因此接下来的问题就变成了如何保证计算是可信的，目前这部分是通过可信的Setup和椭圆加密算法一起完成的，本篇不做详述。