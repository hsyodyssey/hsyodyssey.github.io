I"ʓ<h2 id="什么是geth">什么是Geth？</h2>

<p>Geth是基于Go语言开发以太坊的客户端，它实现了Ethereum协议(黄皮书)中所有需要的实现的功能模块，包括状态管理，挖矿，P2P网络通信，密码学，数据库，EVM解释器等。我们可以通过启动Geth来运行一个Ethereum的节点。Go-ethereum是包含了Geth在内的一个代码库，它包含了Geth，以及编译Geth所需要的其他代码。在本系列中，我们会深入Go-ethereum代码库，从High-level的API接口出发，沿着Ethereum主Workflow，从而理解Ethereum具体实现的细节。</p>

<h3 id="go-ethereum-codebase-结构">Go-ethereum Codebase 结构</h3>

<p>为了更好的从整体工作流的角度来理解Ethereum，根据主要的业务功能，我们将go-ethereum划分成如下几个模块来分析。</p>

<ul>
  <li>Geth Client模块</li>
  <li>Core数据结构模块</li>
  <li>State Management模块
    <ul>
      <li>StateDB 模块</li>
      <li>Trie 模块</li>
      <li>State Optimization (Pruning)</li>
    </ul>
  </li>
  <li>Mining模块</li>
  <li>EVM 模块</li>
  <li>P2P 网络模块
    <ul>
      <li>节点数据同步</li>
    </ul>
  </li>
  <li>…</li>
</ul>

<p>目前，go-ethereum项目的主要目录结构如下所示:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd/ ethereum相关的Command-line程序。该目录下的每个子目录都包含一个可运行的main.go。
   |── clef/ Ethereum官方推出的Account管理程序.
   |── geth/ Geth的本体。
core/   以太坊核心模块，包括核心数据结构，statedb，EVM等算法实现
   |── rawdb/ db相关函数的高层封装(在ethdb和更底层的leveldb之上的封装)
   |── state/
       ├──statedb.go  StateDB结构用于存储所有的与Merkle trie相关的存储, 包括一些循环state结构  
   |── types/  包括Block在内的以太坊核心数据结构
      |── block.go  以太坊block
      |── bloom9.go  一个Bloom Filter的实现
      |── transaction.go 以太坊transaction的数据结构与实现
      |── transaction_signing.go 用于对transaction进行签名的函数的实现
      |── receipt.go  以太坊收据的实现，用于说明以太坊交易的结果
   |── vm/
   |── genesis.go     创世区块相关的函数，在每个geth初始化的都需要调用这个模块
   |── tx_pool.go     Ethereum Transaction Pool的实现
consensus/
   |── consensus.go   共识相关的参数设定，包括Block Reward的数量
console/
   |── bridge.go
   |── console.go  Geth Web3 控制台的入口
ethdb/    Ethereum 本地存储的相关实现, 包括leveldb的调用
   |── leveldb/   Go-Ethereum使用的与Bitcoin Core version一样的Leveldb作为本机存储用的数据库
miner/
   |── miner.go   矿工模块的实现。
   |── worker.go  真正的block generation的实现实现，包括打包transaction，计算合法的Block
p2p/     Ethereum 的P2P模块
   |── params    Ethereum 的一些参数的配置，例如: bootnode的enode地址
   |── bootnodes.go  bootnode的enode地址 like: aws的一些节点，azure的一些节点，Ethereum Foundation的节点和 Rinkeby测试网的节点
rlp/     RLP的Encode与Decode的相关
rpc/     Ethereum RPC客户端的实现
les/     Ethereum light client的实现
trie/    Ethereum 中至关重要的数据结构 Merkle Patrica Trie(MPT)的实现
   |── committer.go    Trie向Memory Database提交数据的工具函数。
   |── database.go     Memory Database，是Trie数据和Disk Database提交的中间层。同时还实现了Trie剪枝的功能。**非常重要**
   |── node.go         MPT中的节点的定义以及相关的函数。
   |── secure_trie.go  基于Trie的封装的Trie结构。与trie中的函数功能相同，不过secure_trie中的key是经过hashKey()函数hash过的，无法通过路径获得原始的key值
   |── stack_trie.go   Block中使用的Transaction/Receipt Trie的实现
   |── trie.go         MPT具体功能的函数实现
</code></pre></div></div>

<h2 id="geth-start">Geth Start</h2>

<h3 id="前奏-geth-console">前奏: Geth Console</h3>

<p>当我们想要部署一个Ethereum节点的时候，最直接的方式就是下载官方提供的发行版的geth程序。Geth是一个基于CLI的应用，启动Geth和调用Geth的功能性API需要使用对应的指令来操作。Geth提供了一个相对友好的console来方便用户调用各种指令。当我第一次阅读Ethereum的文档的时候，我曾经有过这样的疑问，为什么Geth是由Go语言编写的，但是在官方文档中的Web3的API却是基于Javascript的调用？</p>

<p>这是因为Geth内置了一个Javascript的解释器:å<em>Goja</em> (interpreter)，来作为用户与Geth交互的CLI Console。我们可以在<code class="language-plaintext highlighter-rouge">console/console.go</code>中找到它的定义。</p>

<!-- /*Goja is an implementation of ECMAScript 5.1 in Pure GO*/ -->

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Console is a JavaScript interpreted runtime environment. It is a fully fledged</span>
<span class="c">// JavaScript console attached to a running node via an external or in-process RPC</span>
<span class="c">// client.</span>
<span class="k">type</span> <span class="n">Console</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">client</span>   <span class="o">*</span><span class="n">rpc</span><span class="o">.</span><span class="n">Client</span>         <span class="c">// RPC client to execute Ethereum requests through</span>
 <span class="n">jsre</span>     <span class="o">*</span><span class="n">jsre</span><span class="o">.</span><span class="n">JSRE</span>          <span class="c">// JavaScript runtime environment running the interpreter</span>
 <span class="n">prompt</span>   <span class="kt">string</span>              <span class="c">// Input prompt prefix string</span>
 <span class="n">prompter</span> <span class="n">prompt</span><span class="o">.</span><span class="n">UserPrompter</span> <span class="c">// Input prompter to allow interactive user feedback</span>
 <span class="n">histPath</span> <span class="kt">string</span>              <span class="c">// Absolute path to the console scrollback history</span>
 <span class="n">history</span>  <span class="p">[]</span><span class="kt">string</span>            <span class="c">// Scroll history maintained by the console</span>
 <span class="n">printer</span>  <span class="n">io</span><span class="o">.</span><span class="n">Writer</span>           <span class="c">// Output writer to serialize any display strings to</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="启动">启动</h3>

<p>了解Ethereum，我们首先要了解Ethereum客户端Geth是怎么运行的。</p>

<p><!-- `geth console 2` --></p>

<p>Geth的启动点位于<code class="language-plaintext highlighter-rouge">cmd/geth/main.go/main()</code>函数处，如下所示。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
 <span class="k">if</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">app</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Fprintln</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stderr</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
  <span class="n">os</span><span class="o">.</span><span class="n">Exit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们可以看到<code class="language-plaintext highlighter-rouge">main()</code>函数非常的简短，其主要功能就是启动一个解析 command line命令的工具: <code class="language-plaintext highlighter-rouge">gopkg.in/urfave/cli.v1</code>。我们会发现在cli app初始化的时候会调用<code class="language-plaintext highlighter-rouge">app.Action = geth</code>，来调用<code class="language-plaintext highlighter-rouge">geth()</code>函数。<code class="language-plaintext highlighter-rouge">geth()</code>函数就是用于启动Ethereum节点的顶层函数，其代码如下所示。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">geth</span><span class="p">(</span><span class="n">ctx</span> <span class="o">*</span><span class="n">cli</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
 <span class="k">if</span> <span class="n">args</span> <span class="o">:=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Args</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="s">"invalid command: %q"</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
 <span class="p">}</span>

 <span class="n">prepare</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
 <span class="n">stack</span><span class="p">,</span> <span class="n">backend</span> <span class="o">:=</span> <span class="n">makeFullNode</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
 <span class="k">defer</span> <span class="n">stack</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>

 <span class="n">startNode</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="no">false</span><span class="p">)</span>
 <span class="n">stack</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
 <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在<code class="language-plaintext highlighter-rouge">geth()</code>函数，我们可以看到有三个比较重要的函数调用，分别是：<code class="language-plaintext highlighter-rouge">prepare()</code>，<code class="language-plaintext highlighter-rouge">makeFullNode()</code>，以及<code class="language-plaintext highlighter-rouge">startNode()</code>。</p>

<p><code class="language-plaintext highlighter-rouge">prepare()</code> 函数的实现就在当前的<code class="language-plaintext highlighter-rouge">main.go</code>文件中。它主要用于设置一些节点初始化需要的配置。比如，我们在节点启动时看到的这句话: <em>Starting Geth on Ethereum mainnet…</em> 就是在<code class="language-plaintext highlighter-rouge">prepare()</code>函数中被打印出来的。</p>

<p><code class="language-plaintext highlighter-rouge">makeFullNode()</code>函数的实现位于<code class="language-plaintext highlighter-rouge">cmd/geth/config.go</code>文件中。它会将Geth启动时的命令的上下文加载到配置中，并生成<code class="language-plaintext highlighter-rouge">stack</code>和<code class="language-plaintext highlighter-rouge">backend</code>这两个实例。其中<code class="language-plaintext highlighter-rouge">stack</code>是一个Node类型的实例，它是通过<code class="language-plaintext highlighter-rouge">makeFullNode()</code>函数调用<code class="language-plaintext highlighter-rouge">makeConfigNode()</code>函数来生成。Node是Geth生命周期中最顶级的实例，它的开启和关闭与Geth的启动和关闭直接对应。关于Node类型的定义位于<code class="language-plaintext highlighter-rouge">node/node.go</code>文件中。</p>

<p><code class="language-plaintext highlighter-rouge">backend</code>实例是指的是具体Ethereum Client的功能性实例。它是一个Ethereum类型的实例，负责提供更为具体的以太坊的功能性Service，比如管理Blockchain，共识算法等具体模块。它根据上下文的配置信息在调用<code class="language-plaintext highlighter-rouge">utils.RegisterEthService()</code>函数生成。在<code class="language-plaintext highlighter-rouge">utils.RegisterEthService()</code>函数中，首先会根据当前的config来判断需要生成的Ethereum backend的类型，是light node backend还是full node backend。我们可以在<code class="language-plaintext highlighter-rouge">eth/backend/new()</code>函数和<code class="language-plaintext highlighter-rouge">les/client.go/new()</code>中找到这两种Ethereum backend的实例是如何初始化的。Ethereum backend的实例定义了一些更底层的配置，比如chainid，链使用的共识算法的类型等。这两种后端服务的一个典型的区别是light node backend不能启动Mining服务。在<code class="language-plaintext highlighter-rouge">utils.RegisterEthService()</code>函数的最后，调用了<code class="language-plaintext highlighter-rouge">Nodes.RegisterAPIs()</code>函数，将刚刚生成的backend实例注册到<code class="language-plaintext highlighter-rouge">stack</code>实例中。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">eth</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">Ethereum</span><span class="p">{</span>
  <span class="n">config</span><span class="o">:</span>            <span class="n">config</span><span class="p">,</span>
  <span class="n">merger</span><span class="o">:</span>            <span class="n">merger</span><span class="p">,</span>
  <span class="n">chainDb</span><span class="o">:</span>           <span class="n">chainDb</span><span class="p">,</span>
  <span class="n">eventMux</span><span class="o">:</span>          <span class="n">stack</span><span class="o">.</span><span class="n">EventMux</span><span class="p">(),</span>
  <span class="n">accountManager</span><span class="o">:</span>    <span class="n">stack</span><span class="o">.</span><span class="n">AccountManager</span><span class="p">(),</span>
  <span class="n">engine</span><span class="o">:</span>            <span class="n">ethconfig</span><span class="o">.</span><span class="n">CreateConsensusEngine</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">chainConfig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ethashConfig</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">Miner</span><span class="o">.</span><span class="n">Notify</span><span class="p">,</span> <span class="n">config</span><span class="o">.</span><span class="n">Miner</span><span class="o">.</span><span class="n">Noverify</span><span class="p">,</span> <span class="n">chainDb</span><span class="p">),</span>
  <span class="n">closeBloomHandler</span><span class="o">:</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">struct</span><span class="p">{}),</span>
  <span class="n">networkID</span><span class="o">:</span>         <span class="n">config</span><span class="o">.</span><span class="n">NetworkId</span><span class="p">,</span>
  <span class="n">gasPrice</span><span class="o">:</span>          <span class="n">config</span><span class="o">.</span><span class="n">Miner</span><span class="o">.</span><span class="n">GasPrice</span><span class="p">,</span>
  <span class="n">etherbase</span><span class="o">:</span>         <span class="n">config</span><span class="o">.</span><span class="n">Miner</span><span class="o">.</span><span class="n">Etherbase</span><span class="p">,</span>
  <span class="n">bloomRequests</span><span class="o">:</span>     <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="k">chan</span> <span class="o">*</span><span class="n">bloombits</span><span class="o">.</span><span class="n">Retrieval</span><span class="p">),</span>
  <span class="n">bloomIndexer</span><span class="o">:</span>      <span class="n">core</span><span class="o">.</span><span class="n">NewBloomIndexer</span><span class="p">(</span><span class="n">chainDb</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">BloomBitsBlocks</span><span class="p">,</span> <span class="n">params</span><span class="o">.</span><span class="n">BloomConfirms</span><span class="p">),</span>
  <span class="n">p2pServer</span><span class="o">:</span>         <span class="n">stack</span><span class="o">.</span><span class="n">Server</span><span class="p">(),</span>
  <span class="n">shutdownTracker</span><span class="o">:</span>   <span class="n">shutdowncheck</span><span class="o">.</span><span class="n">NewShutdownTracker</span><span class="p">(</span><span class="n">chainDb</span><span class="p">),</span>
 <span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">startNode()</code>函数的作用是正式的启动一个Ethereum Node。它通过调用<code class="language-plaintext highlighter-rouge">utils.StartNode()</code>函数来触发<code class="language-plaintext highlighter-rouge">Node.Start()</code>函数来启动<code class="language-plaintext highlighter-rouge">Stack</code>实例（Node）。在<code class="language-plaintext highlighter-rouge">Node.Start()</code>函数中，会遍历<code class="language-plaintext highlighter-rouge">Node.lifecycles</code>中注册的后端实例，并在启动它们。此外，在<code class="language-plaintext highlighter-rouge">startNode()</code>函数中，还是调用了<code class="language-plaintext highlighter-rouge">unlockAccounts()</code>函数，并将解锁的钱包注册到<code class="language-plaintext highlighter-rouge">stack</code>中，以及通过<code class="language-plaintext highlighter-rouge">stack.Attach()</code>函数创建了与local Geth交互的RPClient模块。</p>

<p>在<code class="language-plaintext highlighter-rouge">geth()</code>函数的最后，函数通过执行<code class="language-plaintext highlighter-rouge">stack.Wait()</code>，使得主线程进入了监听状态，其他的功能模块的服务被分散到其他的子协程中进行维护。</p>

<h3 id="node">Node</h3>

<p>正如我们前面提到的，Node类型在Geth的生命周期性中属于顶级实例，它负责作为与外部通信的外部接口，比如管理rpc server，http server，Web Socket，以及P2P Server外部接口。同时，Node中维护了节点运行所需要的后端的实例和服务(<code class="language-plaintext highlighter-rouge">lifecycles  []Lifecycle</code>)。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Node is a container on which services can be registered.</span>
<span class="k">type</span> <span class="n">Node</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">eventmux</span>      <span class="o">*</span><span class="n">event</span><span class="o">.</span><span class="n">TypeMux</span>
 <span class="n">config</span>        <span class="o">*</span><span class="n">Config</span>
 <span class="n">accman</span>        <span class="o">*</span><span class="n">accounts</span><span class="o">.</span><span class="n">Manager</span>
 <span class="n">log</span>           <span class="n">log</span><span class="o">.</span><span class="n">Logger</span>
 <span class="n">keyDir</span>        <span class="kt">string</span>            <span class="c">// key store directory</span>
 <span class="n">keyDirTemp</span>    <span class="kt">bool</span>              <span class="c">// If true, key directory will be removed by Stop</span>
 <span class="n">dirLock</span>       <span class="n">fileutil</span><span class="o">.</span><span class="n">Releaser</span> <span class="c">// prevents concurrent use of instance directory</span>
 <span class="n">stop</span>          <span class="k">chan</span> <span class="k">struct</span><span class="p">{}</span>     <span class="c">// Channel to wait for termination notifications</span>
 <span class="n">server</span>        <span class="o">*</span><span class="n">p2p</span><span class="o">.</span><span class="n">Server</span>       <span class="c">// Currently running P2P networking layer</span>
 <span class="n">startStopLock</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>        <span class="c">// Start/Stop are protected by an additional lock</span>
 <span class="n">state</span>         <span class="kt">int</span>               <span class="c">// Tracks state of node lifecycle</span>

 <span class="n">lock</span>          <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
 <span class="n">lifecycles</span>    <span class="p">[]</span><span class="n">Lifecycle</span> <span class="c">// All registered backends, services, and auxiliary services that have a lifecycle</span>
 <span class="n">rpcAPIs</span>       <span class="p">[]</span><span class="n">rpc</span><span class="o">.</span><span class="n">API</span>   <span class="c">// List of APIs currently provided by the node</span>
 <span class="n">http</span>          <span class="o">*</span><span class="n">httpServer</span> <span class="c">//</span>
 <span class="n">ws</span>            <span class="o">*</span><span class="n">httpServer</span> <span class="c">//</span>
 <span class="n">httpAuth</span>      <span class="o">*</span><span class="n">httpServer</span> <span class="c">//</span>
 <span class="n">wsAuth</span>        <span class="o">*</span><span class="n">httpServer</span> <span class="c">//</span>
 <span class="n">ipc</span>           <span class="o">*</span><span class="n">ipcServer</span>  <span class="c">// Stores information about the ipc http server</span>
 <span class="n">inprocHandler</span> <span class="o">*</span><span class="n">rpc</span><span class="o">.</span><span class="n">Server</span> <span class="c">// In-process RPC request handler to process the API requests</span>

 <span class="n">databases</span> <span class="k">map</span><span class="p">[</span><span class="o">*</span><span class="n">closeTrackingDB</span><span class="p">]</span><span class="k">struct</span><span class="p">{}</span> <span class="c">// All open databases</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="ethereum-api-backend">Ethereum API Backend</h3>

<p>我们可以在<code class="language-plaintext highlighter-rouge">eth/backend.go</code>中找到<code class="language-plaintext highlighter-rouge">Ethereum</code>这个结构体的定义。这个结构体包含的成员变量以及接收的方法实现了一个Ethereum full node所需要的全部功能和数据结构。我们可以在下面的代码定义中看到，Ethereum结构体中包含了<code class="language-plaintext highlighter-rouge">TxPool</code>，<code class="language-plaintext highlighter-rouge">Blockchain</code>，<code class="language-plaintext highlighter-rouge">consensus.Engine</code>，<code class="language-plaintext highlighter-rouge">miner</code>等最核心的几个数据结构作为成员变量，我们会在后面的章节中详细的讲述这些核心数据结构的主要功能，以及它们的实现的方法。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Ethereum implements the Ethereum full node service.</span>
<span class="k">type</span> <span class="n">Ethereum</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">config</span> <span class="o">*</span><span class="n">ethconfig</span><span class="o">.</span><span class="n">Config</span>

 <span class="c">// Handlers</span>
 <span class="n">txPool</span>             <span class="o">*</span><span class="n">core</span><span class="o">.</span><span class="n">TxPool</span>
 <span class="n">blockchain</span>         <span class="o">*</span><span class="n">core</span><span class="o">.</span><span class="n">BlockChain</span>
 <span class="n">handler</span>            <span class="o">*</span><span class="n">handler</span>
 <span class="n">ethDialCandidates</span>  <span class="n">enode</span><span class="o">.</span><span class="n">Iterator</span>
 <span class="n">snapDialCandidates</span> <span class="n">enode</span><span class="o">.</span><span class="n">Iterator</span>
 <span class="n">merger</span>             <span class="o">*</span><span class="n">consensus</span><span class="o">.</span><span class="n">Merger</span>

 <span class="c">// DB interfaces</span>
 <span class="n">chainDb</span> <span class="n">ethdb</span><span class="o">.</span><span class="n">Database</span> <span class="c">// Block chain database</span>

 <span class="n">eventMux</span>       <span class="o">*</span><span class="n">event</span><span class="o">.</span><span class="n">TypeMux</span>
 <span class="n">engine</span>         <span class="n">consensus</span><span class="o">.</span><span class="n">Engine</span>
 <span class="n">accountManager</span> <span class="o">*</span><span class="n">accounts</span><span class="o">.</span><span class="n">Manager</span>

 <span class="n">bloomRequests</span>     <span class="k">chan</span> <span class="k">chan</span> <span class="o">*</span><span class="n">bloombits</span><span class="o">.</span><span class="n">Retrieval</span> <span class="c">// Channel receiving bloom data retrieval requests</span>
 <span class="n">bloomIndexer</span>      <span class="o">*</span><span class="n">core</span><span class="o">.</span><span class="n">ChainIndexer</span>             <span class="c">// Bloom indexer operating during block imports</span>
 <span class="n">closeBloomHandler</span> <span class="k">chan</span> <span class="k">struct</span><span class="p">{}</span>

 <span class="n">APIBackend</span> <span class="o">*</span><span class="n">EthAPIBackend</span>

 <span class="n">miner</span>     <span class="o">*</span><span class="n">miner</span><span class="o">.</span><span class="n">Miner</span>
 <span class="n">gasPrice</span>  <span class="o">*</span><span class="n">big</span><span class="o">.</span><span class="n">Int</span>
 <span class="n">etherbase</span> <span class="n">common</span><span class="o">.</span><span class="n">Address</span>

 <span class="n">networkID</span>     <span class="kt">uint64</span>
 <span class="n">netRPCService</span> <span class="o">*</span><span class="n">ethapi</span><span class="o">.</span><span class="n">PublicNetAPI</span>

 <span class="n">p2pServer</span> <span class="o">*</span><span class="n">p2p</span><span class="o">.</span><span class="n">Server</span>

 <span class="n">lock</span> <span class="n">sync</span><span class="o">.</span><span class="n">RWMutex</span> <span class="c">// Protects the variadic fields (e.g. gas price and etherbase)</span>

 <span class="n">shutdownTracker</span> <span class="o">*</span><span class="n">shutdowncheck</span><span class="o">.</span><span class="n">ShutdownTracker</span> <span class="c">// Tracks if and when the node has shutdown ungracefully</span>
<span class="p">}</span>

</code></pre></div></div>

<p>节点启动和停止Mining的就是通过调用<code class="language-plaintext highlighter-rouge">Ethereum.StartMining()</code>和<code class="language-plaintext highlighter-rouge">Ethereum.StopMining()</code>实现的。设置Mining的收益账户是通过调用<code class="language-plaintext highlighter-rouge">Ethereum.SetEtherbase()</code>实现的。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// StartMining starts the miner with the given number of CPU threads. If mining</span>
<span class="c">// is already running, this method adjust the number of threads allowed to use</span>
<span class="c">// and updates the minimum price required by the transaction pool.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">Ethereum</span><span class="p">)</span> <span class="n">StartMining</span><span class="p">(</span><span class="n">threads</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="o">...</span>
 <span class="c">// If the miner was not running, initialize it</span>
 <span class="k">if</span> <span class="o">!</span><span class="n">s</span><span class="o">.</span><span class="n">IsMining</span><span class="p">()</span> <span class="p">{</span>
      <span class="o">...</span>
      <span class="c">// Start Mining</span>
  <span class="k">go</span> <span class="n">s</span><span class="o">.</span><span class="n">miner</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span>
 <span class="p">}</span>
 <span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里我们额外关注一下<code class="language-plaintext highlighter-rouge">handler</code>这个成员变量。<code class="language-plaintext highlighter-rouge">handler</code>的定义在<code class="language-plaintext highlighter-rouge">eth/handler.go</code>中。</p>

<p>我们从从宏观角度来看，一个节点的主工作流需要: 1.从网络中获取/同步Transaction和Block的数据 2. 将网络中获取到Block添加到Blockchain中。而<code class="language-plaintext highlighter-rouge">handler</code>就维护了backend中同步/请求数据的实例，比如<code class="language-plaintext highlighter-rouge">downloader.Downloader</code>，<code class="language-plaintext highlighter-rouge">fetcher.TxFetcher</code>。关于这些成员变量的具体实现，我们会在后续的文章中详细介绍。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">handler</span> <span class="k">struct</span> <span class="p">{</span>
 <span class="n">networkID</span>  <span class="kt">uint64</span>
 <span class="n">forkFilter</span> <span class="n">forkid</span><span class="o">.</span><span class="n">Filter</span> <span class="c">// Fork ID filter, constant across the lifetime of the node</span>

 <span class="n">snapSync</span>  <span class="kt">uint32</span> <span class="c">// Flag whether snap sync is enabled (gets disabled if we already have blocks)</span>
 <span class="n">acceptTxs</span> <span class="kt">uint32</span> <span class="c">// Flag whether we're considered synchronised (enables transaction processing)</span>

 <span class="n">checkpointNumber</span> <span class="kt">uint64</span>      <span class="c">// Block number for the sync progress validator to cross reference</span>
 <span class="n">checkpointHash</span>   <span class="n">common</span><span class="o">.</span><span class="n">Hash</span> <span class="c">// Block hash for the sync progress validator to cross reference</span>

 <span class="n">database</span> <span class="n">ethdb</span><span class="o">.</span><span class="n">Database</span>
 <span class="n">txpool</span>   <span class="n">txPool</span>
 <span class="n">chain</span>    <span class="o">*</span><span class="n">core</span><span class="o">.</span><span class="n">BlockChain</span>
 <span class="n">maxPeers</span> <span class="kt">int</span>

 <span class="n">downloader</span>   <span class="o">*</span><span class="n">downloader</span><span class="o">.</span><span class="n">Downloader</span>
 <span class="n">blockFetcher</span> <span class="o">*</span><span class="n">fetcher</span><span class="o">.</span><span class="n">BlockFetcher</span>
 <span class="n">txFetcher</span>    <span class="o">*</span><span class="n">fetcher</span><span class="o">.</span><span class="n">TxFetcher</span>
 <span class="n">peers</span>        <span class="o">*</span><span class="n">peerSet</span>
 <span class="n">merger</span>       <span class="o">*</span><span class="n">consensus</span><span class="o">.</span><span class="n">Merger</span>

 <span class="n">eventMux</span>      <span class="o">*</span><span class="n">event</span><span class="o">.</span><span class="n">TypeMux</span>
 <span class="n">txsCh</span>         <span class="k">chan</span> <span class="n">core</span><span class="o">.</span><span class="n">NewTxsEvent</span>
 <span class="n">txsSub</span>        <span class="n">event</span><span class="o">.</span><span class="n">Subscription</span>
 <span class="n">minedBlockSub</span> <span class="o">*</span><span class="n">event</span><span class="o">.</span><span class="n">TypeMuxSubscription</span>

 <span class="n">peerRequiredBlocks</span> <span class="k">map</span><span class="p">[</span><span class="kt">uint64</span><span class="p">]</span><span class="n">common</span><span class="o">.</span><span class="n">Hash</span>

 <span class="c">// channels for fetcher, syncer, txsyncLoop</span>
 <span class="n">quitSync</span> <span class="k">chan</span> <span class="k">struct</span><span class="p">{}</span>

 <span class="n">chainSync</span> <span class="o">*</span><span class="n">chainSyncer</span>
 <span class="n">wg</span>        <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
 <span class="n">peerWG</span>    <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样，我们就介绍了Geth及其所需要的基本模块是如何启动的。我们在接下来将视角转入到各个模块中，从更细粒度的角度深入Ethereum的实现。</p>

<h3 id="appendix">Appendix</h3>

<p>这里补充一个Go语言的语法知识: <strong>类型断言</strong>。在<code class="language-plaintext highlighter-rouge">Ethereum.StartMining()</code>函数中，出现了<code class="language-plaintext highlighter-rouge">if c, ok := s.engine.(*clique.Clique); ok</code>的写法。这中写法是Golang中的语法糖，称为类型断言。具体的语法是<code class="language-plaintext highlighter-rouge">value, ok := element.(T)</code>，它的含义是如果<code class="language-plaintext highlighter-rouge">element</code>是<code class="language-plaintext highlighter-rouge">T</code>类型的话，那么ok等于<code class="language-plaintext highlighter-rouge">True</code>, <code class="language-plaintext highlighter-rouge">value</code>等于<code class="language-plaintext highlighter-rouge">element</code>的值。在<code class="language-plaintext highlighter-rouge">if c, ok := s.engine.(*clique.Clique); ok</code>语句中，就是在判断<code class="language-plaintext highlighter-rouge">s.engine</code>的是否为<code class="language-plaintext highlighter-rouge">*clique.Clique</code>类型。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">var</span> <span class="n">cli</span> <span class="o">*</span><span class="n">clique</span><span class="o">.</span><span class="n">Clique</span>
  <span class="k">if</span> <span class="n">c</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">clique</span><span class="o">.</span><span class="n">Clique</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
   <span class="n">cli</span> <span class="o">=</span> <span class="n">c</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">cl</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">beacon</span><span class="o">.</span><span class="n">Beacon</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">c</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">cl</span><span class="o">.</span><span class="n">InnerEngine</span><span class="p">()</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">clique</span><span class="o">.</span><span class="n">Clique</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">cli</span> <span class="o">=</span> <span class="n">c</span>
   <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>
:ET