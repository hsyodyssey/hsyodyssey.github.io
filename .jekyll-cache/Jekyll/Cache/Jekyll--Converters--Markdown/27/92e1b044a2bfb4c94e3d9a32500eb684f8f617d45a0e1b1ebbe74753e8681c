I"S&<p>V神曾经写过一篇非常好的介绍R1CS与QAP问题的<a href="https://vitalik.ca/general/2016/12/10/qap.html">文章</a>。但是，对于不熟悉密码学的，或者说如何使用密码学的思想来解决问题的票友们来说，文章中的一些逻辑上的跨度还是大了一些。尤其是在R1CS转换成多项式形式的地方，初次接触的人可能会一脸懵逼。下面我就从我的理解来谈一谈，从R1CS到QAP这一过程。</p>

<p>在Groth16的流程中，我们首先需要把<strong>计算问题</strong>拍平成<strong>电路</strong>。电路由若干的有输入有输出的算数电路门组成。然后根据电路门，来构造R1CS约束。</p>

<p>这里我们直接使用V神的<a href="https://vitalik.ca/general/2016/12/10/qap.html">博客</a>中的例子。下面的三个矩阵是就是原问题对应的电路的R1CS的约束矩阵。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A
[0, 1, 0, 0, 0, 0]
[0, 0, 0, 1, 0, 0]
[0, 1, 0, 0, 1, 0]
[5, 0, 0, 0, 0, 1]

B
[0, 1, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]

C
[0, 0, 0, 1, 0, 0]
[0, 0, 0, 0, 1, 0]
[0, 0, 0, 0, 0, 1]
[0, 0, 1, 0, 0, 0]
</code></pre></div></div>

<p>这三个矩阵都包含了四个行向量，代表了原始的计算被拍平成了在R1CS约束下的四个电路门。到了这一步，我们的原问题”<em>我们知道原始计算的一个解</em>“就转化成了，<em>“我们知道一个解向量，使得它在每个电路约束下都成立”</em>。我们用$S$来表示解向量，本例中$S$的值如下所示。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
3
35
9
27
30
</code></pre></div></div>

<p>此时，如果我们想证明我们知道原始计算的一个解，那么就需要证明A，B，C矩阵中的<strong>每个</strong>行向量与解向量$S$的内积之后的值是符合R1CS约束的：</p>

\[(A_i*S)* (B_i*S) - C_i*S = 0\]

<p>在接下来的一步，我们需要将R1CS的约束转换成一个QAP问题，这个地方是理解zk的重点。我觉得原文中没有提到的一点时，我们为什么要这么做的？这样的转换目的是什么？V神的原文只描述了如何做，希望把向量的内积转化为多项式，如何进行拉普拉斯插值求多项式，所以第一次读到这里的时候，我感觉一头雾水。</p>

<p>这里阐述一下我的理解。这样做的原因是，如果只使用R1CS的约束矩阵来验证，我们只能一个电路门，一个电路门的，使用列向量与解向量的内积来验证是否满足R1CS的约束。这样在方式在大规模电路下（几十万，上百万的电路门）显然是十分低效的。</p>

<p>那么接下来的自然思考方向就变成了，存不存在一种办法，可以让我们<strong>一次/个计算</strong>来验证所有约束的正确性？</p>

<p>我们在观察上面的计算过程中，发现解向量中$S$中的S1元素一定与约束矩阵中A11，A21，A31，A41这四个元素相乘。因此，那么我们假设存在这样一个多项式 $A_1(x)$，它经过$(1,0), (2,0), (3,0), (4,5)$这四个点。这个多项式 $A_1(x)$的数学意义是：当x的值为1时，多项式的值为0，当$x=2$时，多项式的值为0，当$x=3$时，多项式的值为0，当$x=4$时，多项式的值为5。这样，我们通过引入额外的参数x，使得可以使用一个的多项式$A_1(x)$来描述[A11，A21，A31，A41]这四个值。</p>

<p>根据原文中提到的拉普拉斯插值法，我们可以求出关于[A11，A21，A31，A41]的多项式为：</p>

\[A_1(x) = 0.833*x^3 -5.0*x^2 +9.166*x -5.0\]

<p>我们验证一下就可以发现，当x取1时，A_1(x)的值为0，等于原R1CS约束矩阵中的A11的值。</p>

<p>同样的，我们可以构造出其他列向量的多项式$A_i(x),B_i(x),C_i(x)$。那么这样，我们就可以使用这几个多项式来描述，之前判断向量内积是否满足R1CS约束的过程。等式的左边可以写成下面的形式:</p>

\[((1 * A_1(x))+(3 * A_2(x))+(35 * A_3(x)) + (9 * A_4(x)) +(27 * A_5(x))+(30 * A_6(x))) \\ *（(1 * B_1(x)+(3 * B_2(x))+(35 * B_3(x)) + (9 * B_4(x)) +(27 * B_5(x))+(30 * B_6(x))) \\ - （(1 * C_1(x)+(3 * C_2(x))+(35 * C_3(x)) + (9 * C_4(x)) +(27 * C_5(x))+(30 * C_6(x)))\]

<p>现在我们已经将实际的值转换成了多项式，根据x的取值的不同，来描述不同的R1CS约束。那么，更进一步的来说，因为上面的式子中都是多项式，我们可以把等式左边展开成一个更简洁的多项式 $t(x)$:</p>

\[t(x) = (-5.166*x^3+38.5*x^2-73.333*x+43)*(0.666*x^3-5.0*x^2+10.333*x-3.0)-(2.833*x^3-24.5*x^2+10.333*x-41.0)\\
       = -3.440556*x^6+51.471*x^5-294.720056*x^4+805.7885*x^3-1063.749889*x^2+592.652*x-88\]

<p>同时我们需要让等式右边的值等于0。因此我们就可以先构造一个多项式$z(x)=(x-1)(x-2)(x-3)(x-4)$。显然$z(x)$在x的取值为[1，2，3，4]值情况下都等于0。在本例中，显然$z(x)$是不等于$t(x)$（多项式的阶不同），所以我们引入另一个多项式$h(x)$，使得$t(x)=z(x)h(x)$。</p>

<p>这里，其实依赖了一个数学引理: <a href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">Schwartz–Zippel lemma</a>。简单的说，对于两个多项式$f(x)$,$g(x)$来说，这两个多项式在某点处，相等的概率很低。感兴趣的读者可以深入了解一下这个引理。</p>

<p>这样我们就实现了用一个多项式来描述所有的R1CS的约束了。我们可以设置x值取1，2，3，4，来验证对应的电路的R1CS约束是不是合法。在实际问题上，x的取值远不止范围1，2，3，4四个值。在ZK-System中，x所选用的field通常是在一个椭圆曲线上的循环群。</p>

<p>现在的关于<strong>我们是否知道原问题的解的证明</strong>转换成了，<strong>我们是否知道一个多项式$t(x)$使得$t(x)=z(x)h(x)$在x在一个循环群的域上都成立</strong>。</p>

<p>那么，顺着这个逻辑继续思考，<em>我们如何向其他人证明我们知道这个多项式$t(x)$的存在的呢？</em></p>

<p>一个简单的想法可以是这样的。在公式$t(x)=z(x)h(x)$中，$z(x)$是公开的多项式，那么作为知道$t(x)$的Prover，我们可以快速的计算出$h(x)=\frac{t(x)}{z(x)}$。那么，我们只要提供某个x对应的$h(x)$,$t(x)$的值给验证者。那么显然，验证者通过计算$z(x)*h(x)$的值，与Prover提供的$t(x)$的值进行比较验证。那么作为Prover，我们不需要公开$t(x)$的细节，就可以向Verifier证明我们知道多项式$t(x)$。</p>

<p>那么想象一下，Alice对Bob说，我知道一个计算的解。那么Bob可以要求Alice计算$x=r$时，$h(r)$和$t(r)$的值，并且验证$h(r)*z(r)$是否与$t(r)$的值是否相等来判断Alice说的是否正确。在这个过程我们完美的隐藏掉了原来解向量$S$的存在。</p>

<p>通过，上面的过程，我们就完成了一个简单的零知识问题的转换。但是这个模型并不足够安全，比如Alice可以伪造合法的$h(r)$和$t(r)$的值，使得$t(r)=z(r)h(r)$成立。具体的来说，比如不管Bob请求任意r下的$h(r)$值，Alice总是返回$h(r),t(r) == 0$。用稍微正式的语言来描述这个现象就是：Alice知道了$r$的具体值之后，可以计算出另一组值$t(r’)$,$h(r’)$，使得$t(r’)=z(r)h(r’)$成立。因此在这种情况下，等式的左右两边仍然是相同的，但是不符合我们的目标。</p>

<p>因此，顺着这个逻辑思考，接下来的需要解决的问题就变成了，<em>如何保证Prover不会伪造</em>$h(r)$,$t(r)$的值呢？</p>

<p>目前这部分主要是通过Polynomial Commitment Scheme (PCS)这项技术来解决的。Groth16中，使用的PCS是 Kate Commitments(KZG Commitments), 它是一种Pairing-based PCS。Kate Commitments需要对多项式(电路)建立Common Reference String(CRS)。这也就是我们常常听到的Trusted Setup。Trusted Setup带了不少负面效果。一旦Trusted Setup时的信息发生了泄漏，整个的Proof System的安全性保证也就不存在了。同时在Groth16中，我们需要对每个多项式都进行Trusted Setup的。换句话说，我们需要对每个计算电路都要进行一次的Trusted Setup，这对于图灵完备的通用计算来说成本是非常高的。这也是为什么ZCash可以良好的运行ZK-SNARKs，而很少见到在General-Purpose Blockchain中使用ZK-SNARKs的原因。</p>

<p>为了解决这方面的问题，研究人员提出了<a href="https://crypto.stanford.edu/bulletproofs/">BulletProof</a>，这是一种基于inner produce-base PCS，在BulletProof中，不需要Trusted Setup，但是需要更多的Proof Size。</p>

<p>另一方面，研究人员提出了Plonk协议。在Plonk体系中，只需要一次的Trusted Setup就可以给多个多项式进行验证。比较热门的基于zk-rollup技术的Layer-2系统ZKSync就是基于Plonk协议开发的。</p>

<p>关于PCS的技术在本篇中不做详解。感兴趣的读者可以搜索相关的关键词进行学习。</p>

<h2 id="references">References</h2>

<ol>
  <li>Bulletproofs: Short Proofs for Confidential Transactions and More, <a href="https://crypto.stanford.edu/bulletproofs/">[link]</a></li>
  <li>Schwartz–Zippel lemma, <a href="https://en.wikipedia.org/wiki/Schwartz%E2%80%93Zippel_lemma">[link]</a></li>
  <li>Quadratic Arithmetic Programs: from Zero to Hero, <a href="https://vitalik.ca/general/2016/12/10/qap.html">[link]</a></li>
  <li>Kate Commitments: A Primer, <a href="https://hackmd.io/@tompocock/Hk2A7BD6U">[link]</a></li>
</ol>
:ET